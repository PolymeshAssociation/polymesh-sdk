export type Maybe<T> = T;
export type InputMaybe<T> = T;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = {
  [_ in K]?: never;
};
export type Incremental<T> =
  | T
  | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string };
  String: { input: string; output: string };
  Boolean: { input: boolean; output: boolean };
  Int: { input: number; output: number };
  Float: { input: number; output: number };
  BigFloat: { input: any; output: any };
  Cursor: { input: any; output: any };
  Date: { input: any; output: any };
  Datetime: { input: any; output: any };
  JSON: { input: any; output: any };
};

/**
 * Represents a public/private key pair. Most actions must be signed by an appropriately permissioned Account
 *
 * Before an Account can sign most Extrinsics it must first be attached to an Identity
 */
export type Account = Node & {
  __typename?: 'Account';
  address: Scalars['String']['output'];
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `Account`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  datetime: Scalars['Datetime']['output'];
  eventId: EventIdEnum;
  id: Scalars['String']['output'];
  /** Reads a single `Identity` that is related to this `Account`. */
  identity?: Maybe<Identity>;
  identityId?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Permission` that is related to this `Account`. */
  permissions?: Maybe<Permission>;
  permissionsId?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `Account`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
};

export type AccountAggregates = {
  __typename?: 'AccountAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A filter to be used against `Account` object types. All fields are combined with a logical ‘and.’ */
export type AccountFilter = {
  /** Filter by the object’s `address` field. */
  address?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AccountFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `datetime` field. */
  datetime?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `eventId` field. */
  eventId?: InputMaybe<EventIdEnumFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `identityId` field. */
  identityId?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AccountFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AccountFilter>>;
  /** Filter by the object’s `permissionsId` field. */
  permissionsId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
};

/** A connection to a list of `AccountHistory` values. */
export type AccountHistoriesConnection = {
  __typename?: 'AccountHistoriesConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AccountHistoryAggregates>;
  /** A list of edges which contains the `AccountHistory` and cursor to aid in pagination. */
  edges: Array<AccountHistoriesEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AccountHistoryAggregates>>;
  /** A list of `AccountHistory` objects. */
  nodes: Array<Maybe<AccountHistory>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AccountHistory` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `AccountHistory` values. */
export type AccountHistoriesConnectionGroupedAggregatesArgs = {
  groupBy: Array<AccountHistoriesGroupBy>;
  having?: InputMaybe<AccountHistoriesHavingInput>;
};

/** A `AccountHistory` edge in the connection. */
export type AccountHistoriesEdge = {
  __typename?: 'AccountHistoriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AccountHistory` at the end of the edge. */
  node?: Maybe<AccountHistory>;
};

/** Grouping methods for `AccountHistory` for usage during aggregation. */
export enum AccountHistoriesGroupBy {
  Account = 'ACCOUNT',
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  Datetime = 'DATETIME',
  EventId = 'EVENT_ID',
  Identity = 'IDENTITY',
  Permissions = 'PERMISSIONS',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
}

/** Conditions for `AccountHistory` aggregates. */
export type AccountHistoriesHavingInput = {
  AND?: InputMaybe<Array<AccountHistoriesHavingInput>>;
  OR?: InputMaybe<Array<AccountHistoriesHavingInput>>;
};

/** Methods to use when ordering `AccountHistory`. */
export enum AccountHistoriesOrderBy {
  AccountAsc = 'ACCOUNT_ASC',
  AccountDesc = 'ACCOUNT_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  DatetimeAsc = 'DATETIME_ASC',
  DatetimeDesc = 'DATETIME_DESC',
  EventIdAsc = 'EVENT_ID_ASC',
  EventIdDesc = 'EVENT_ID_DESC',
  IdentityAsc = 'IDENTITY_ASC',
  IdentityDesc = 'IDENTITY_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PermissionsAsc = 'PERMISSIONS_ASC',
  PermissionsDesc = 'PERMISSIONS_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
}

/** Represents historical data of identities assigned to an account */
export type AccountHistory = Node & {
  __typename?: 'AccountHistory';
  account: Scalars['String']['output'];
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `AccountHistory`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  datetime: Scalars['Datetime']['output'];
  eventId: EventIdEnum;
  id: Scalars['String']['output'];
  identity: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  permissions?: Maybe<Scalars['JSON']['output']>;
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `AccountHistory`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
};

export type AccountHistoryAggregates = {
  __typename?: 'AccountHistoryAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A filter to be used against `AccountHistory` object types. All fields are combined with a logical ‘and.’ */
export type AccountHistoryFilter = {
  /** Filter by the object’s `account` field. */
  account?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AccountHistoryFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `datetime` field. */
  datetime?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `eventId` field. */
  eventId?: InputMaybe<EventIdEnumFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `identity` field. */
  identity?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AccountHistoryFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AccountHistoryFilter>>;
  /** Filter by the object’s `permissions` field. */
  permissions?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
};

/** A connection to a list of `Account` values. */
export type AccountsConnection = {
  __typename?: 'AccountsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AccountAggregates>;
  /** A list of edges which contains the `Account` and cursor to aid in pagination. */
  edges: Array<AccountsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AccountAggregates>>;
  /** A list of `Account` objects. */
  nodes: Array<Maybe<Account>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Account` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Account` values. */
export type AccountsConnectionGroupedAggregatesArgs = {
  groupBy: Array<AccountsGroupBy>;
  having?: InputMaybe<AccountsHavingInput>;
};

/** A `Account` edge in the connection. */
export type AccountsEdge = {
  __typename?: 'AccountsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Account` at the end of the edge. */
  node?: Maybe<Account>;
};

/** Grouping methods for `Account` for usage during aggregation. */
export enum AccountsGroupBy {
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  Datetime = 'DATETIME',
  EventId = 'EVENT_ID',
  IdentityId = 'IDENTITY_ID',
  PermissionsId = 'PERMISSIONS_ID',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
}

/** Conditions for `Account` aggregates. */
export type AccountsHavingInput = {
  AND?: InputMaybe<Array<AccountsHavingInput>>;
  OR?: InputMaybe<Array<AccountsHavingInput>>;
};

/** Methods to use when ordering `Account`. */
export enum AccountsOrderBy {
  AddressAsc = 'ADDRESS_ASC',
  AddressDesc = 'ADDRESS_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  DatetimeAsc = 'DATETIME_ASC',
  DatetimeDesc = 'DATETIME_DESC',
  EventIdAsc = 'EVENT_ID_ASC',
  EventIdDesc = 'EVENT_ID_DESC',
  IdentityIdAsc = 'IDENTITY_ID_ASC',
  IdentityIdDesc = 'IDENTITY_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PermissionsIdAsc = 'PERMISSIONS_ID_ASC',
  PermissionsIdDesc = 'PERMISSIONS_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
}

/** Represents a set of agents authorized to perform actions for a given Asset */
export type AgentGroup = Node & {
  __typename?: 'AgentGroup';
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAgentGroupMembershipGroupIdAndCreatedBlockId: AgentGroupBlocksByAgentGroupMembershipGroupIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAgentGroupMembershipGroupIdAndUpdatedBlockId: AgentGroupBlocksByAgentGroupMembershipGroupIdAndUpdatedBlockIdManyToManyConnection;
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `AgentGroup`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  id: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `AgentGroupMembership`. */
  members: AgentGroupMembershipsConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  permissions: Scalars['String']['output'];
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `AgentGroup`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
};

/** Represents a set of agents authorized to perform actions for a given Asset */
export type AgentGroupBlocksByAgentGroupMembershipGroupIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a set of agents authorized to perform actions for a given Asset */
export type AgentGroupBlocksByAgentGroupMembershipGroupIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a set of agents authorized to perform actions for a given Asset */
export type AgentGroupMembersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AgentGroupMembershipFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AgentGroupMembershipsOrderBy>>;
};

export type AgentGroupAggregates = {
  __typename?: 'AgentGroupAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A connection to a list of `Block` values, with data from `AgentGroupMembership`. */
export type AgentGroupBlocksByAgentGroupMembershipGroupIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'AgentGroupBlocksByAgentGroupMembershipGroupIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `AgentGroupMembership`, and the cursor to aid in pagination. */
  edges: Array<AgentGroupBlocksByAgentGroupMembershipGroupIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `AgentGroupMembership`. */
export type AgentGroupBlocksByAgentGroupMembershipGroupIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AgentGroupMembership`. */
export type AgentGroupBlocksByAgentGroupMembershipGroupIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'AgentGroupBlocksByAgentGroupMembershipGroupIdAndCreatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AgentGroupMembership`. */
  agentGroupMembershipsByCreatedBlockId: AgentGroupMembershipsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `AgentGroupMembership`. */
export type AgentGroupBlocksByAgentGroupMembershipGroupIdAndCreatedBlockIdManyToManyEdgeAgentGroupMembershipsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AgentGroupMembershipFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AgentGroupMembershipsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `AgentGroupMembership`. */
export type AgentGroupBlocksByAgentGroupMembershipGroupIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'AgentGroupBlocksByAgentGroupMembershipGroupIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `AgentGroupMembership`, and the cursor to aid in pagination. */
  edges: Array<AgentGroupBlocksByAgentGroupMembershipGroupIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `AgentGroupMembership`. */
export type AgentGroupBlocksByAgentGroupMembershipGroupIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AgentGroupMembership`. */
export type AgentGroupBlocksByAgentGroupMembershipGroupIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'AgentGroupBlocksByAgentGroupMembershipGroupIdAndUpdatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AgentGroupMembership`. */
  agentGroupMembershipsByUpdatedBlockId: AgentGroupMembershipsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `AgentGroupMembership`. */
export type AgentGroupBlocksByAgentGroupMembershipGroupIdAndUpdatedBlockIdManyToManyEdgeAgentGroupMembershipsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AgentGroupMembershipFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AgentGroupMembershipsOrderBy>>;
  };

/** A filter to be used against `AgentGroup` object types. All fields are combined with a logical ‘and.’ */
export type AgentGroupFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AgentGroupFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AgentGroupFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AgentGroupFilter>>;
  /** Filter by the object’s `permissions` field. */
  permissions?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
};

/** Represent membership in a group. Tracks which members belong to which groups */
export type AgentGroupMembership = Node & {
  __typename?: 'AgentGroupMembership';
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `AgentGroupMembership`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  /** Reads a single `AgentGroup` that is related to this `AgentGroupMembership`. */
  group?: Maybe<AgentGroup>;
  groupId: Scalars['String']['output'];
  id: Scalars['String']['output'];
  member: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `AgentGroupMembership`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
};

export type AgentGroupMembershipAggregates = {
  __typename?: 'AgentGroupMembershipAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A filter to be used against `AgentGroupMembership` object types. All fields are combined with a logical ‘and.’ */
export type AgentGroupMembershipFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AgentGroupMembershipFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `groupId` field. */
  groupId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `member` field. */
  member?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AgentGroupMembershipFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AgentGroupMembershipFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
};

/** A connection to a list of `AgentGroupMembership` values. */
export type AgentGroupMembershipsConnection = {
  __typename?: 'AgentGroupMembershipsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AgentGroupMembershipAggregates>;
  /** A list of edges which contains the `AgentGroupMembership` and cursor to aid in pagination. */
  edges: Array<AgentGroupMembershipsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AgentGroupMembershipAggregates>>;
  /** A list of `AgentGroupMembership` objects. */
  nodes: Array<Maybe<AgentGroupMembership>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AgentGroupMembership` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `AgentGroupMembership` values. */
export type AgentGroupMembershipsConnectionGroupedAggregatesArgs = {
  groupBy: Array<AgentGroupMembershipsGroupBy>;
  having?: InputMaybe<AgentGroupMembershipsHavingInput>;
};

/** A `AgentGroupMembership` edge in the connection. */
export type AgentGroupMembershipsEdge = {
  __typename?: 'AgentGroupMembershipsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AgentGroupMembership` at the end of the edge. */
  node?: Maybe<AgentGroupMembership>;
};

/** Grouping methods for `AgentGroupMembership` for usage during aggregation. */
export enum AgentGroupMembershipsGroupBy {
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  GroupId = 'GROUP_ID',
  Member = 'MEMBER',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
}

/** Conditions for `AgentGroupMembership` aggregates. */
export type AgentGroupMembershipsHavingInput = {
  AND?: InputMaybe<Array<AgentGroupMembershipsHavingInput>>;
  OR?: InputMaybe<Array<AgentGroupMembershipsHavingInput>>;
};

/** Methods to use when ordering `AgentGroupMembership`. */
export enum AgentGroupMembershipsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  GroupIdAsc = 'GROUP_ID_ASC',
  GroupIdDesc = 'GROUP_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MemberAsc = 'MEMBER_ASC',
  MemberDesc = 'MEMBER_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
}

/** A connection to a list of `AgentGroup` values. */
export type AgentGroupsConnection = {
  __typename?: 'AgentGroupsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AgentGroupAggregates>;
  /** A list of edges which contains the `AgentGroup` and cursor to aid in pagination. */
  edges: Array<AgentGroupsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AgentGroupAggregates>>;
  /** A list of `AgentGroup` objects. */
  nodes: Array<Maybe<AgentGroup>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AgentGroup` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `AgentGroup` values. */
export type AgentGroupsConnectionGroupedAggregatesArgs = {
  groupBy: Array<AgentGroupsGroupBy>;
  having?: InputMaybe<AgentGroupsHavingInput>;
};

/** A `AgentGroup` edge in the connection. */
export type AgentGroupsEdge = {
  __typename?: 'AgentGroupsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AgentGroup` at the end of the edge. */
  node?: Maybe<AgentGroup>;
};

/** Grouping methods for `AgentGroup` for usage during aggregation. */
export enum AgentGroupsGroupBy {
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  Permissions = 'PERMISSIONS',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
}

/** Conditions for `AgentGroup` aggregates. */
export type AgentGroupsHavingInput = {
  AND?: InputMaybe<Array<AgentGroupsHavingInput>>;
  OR?: InputMaybe<Array<AgentGroupsHavingInput>>;
};

/** Methods to use when ordering `AgentGroup`. */
export enum AgentGroupsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MembersCountAsc = 'MEMBERS_COUNT_ASC',
  MembersCountDesc = 'MEMBERS_COUNT_DESC',
  Natural = 'NATURAL',
  PermissionsAsc = 'PERMISSIONS_ASC',
  PermissionsDesc = 'PERMISSIONS_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
}

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type Asset = Node & {
  __typename?: 'Asset';
  /** Reads and enables pagination through a set of `AssetTransaction`. */
  assetTransactions: AssetTransactionsConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetDocumentAssetIdAndCreatedBlockId: AssetBlocksByAssetDocumentAssetIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetDocumentAssetIdAndUpdatedBlockId: AssetBlocksByAssetDocumentAssetIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetHolderAssetIdAndCreatedBlockId: AssetBlocksByAssetHolderAssetIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetHolderAssetIdAndUpdatedBlockId: AssetBlocksByAssetHolderAssetIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetTransactionAssetIdAndCreatedBlockId: AssetBlocksByAssetTransactionAssetIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetTransactionAssetIdAndUpdatedBlockId: AssetBlocksByAssetTransactionAssetIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByComplianceAssetIdAndCreatedBlockId: AssetBlocksByComplianceAssetIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByComplianceAssetIdAndUpdatedBlockId: AssetBlocksByComplianceAssetIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByDistributionAssetIdAndCreatedBlockId: AssetBlocksByDistributionAssetIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByDistributionAssetIdAndUpdatedBlockId: AssetBlocksByDistributionAssetIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByFundingAssetIdAndCreatedBlockId: AssetBlocksByFundingAssetIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByFundingAssetIdAndUpdatedBlockId: AssetBlocksByFundingAssetIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByPortfolioMovementAssetIdAndCreatedBlockId: AssetBlocksByPortfolioMovementAssetIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByPortfolioMovementAssetIdAndUpdatedBlockId: AssetBlocksByPortfolioMovementAssetIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByStatTypeAssetIdAndCreatedBlockId: AssetBlocksByStatTypeAssetIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByStatTypeAssetIdAndUpdatedBlockId: AssetBlocksByStatTypeAssetIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByStoOfferingAssetIdAndCreatedBlockId: AssetBlocksByStoOfferingAssetIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByStoOfferingAssetIdAndUpdatedBlockId: AssetBlocksByStoOfferingAssetIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTickerExternalAgentActionAssetIdAndCreatedBlockId: AssetBlocksByTickerExternalAgentActionAssetIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTickerExternalAgentActionAssetIdAndUpdatedBlockId: AssetBlocksByTickerExternalAgentActionAssetIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTickerExternalAgentAssetIdAndCreatedBlockId: AssetBlocksByTickerExternalAgentAssetIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTickerExternalAgentAssetIdAndUpdatedBlockId: AssetBlocksByTickerExternalAgentAssetIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTickerExternalAgentHistoryAssetIdAndCreatedBlockId: AssetBlocksByTickerExternalAgentHistoryAssetIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTickerExternalAgentHistoryAssetIdAndUpdatedBlockId: AssetBlocksByTickerExternalAgentHistoryAssetIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTransferComplianceAssetIdAndCreatedBlockId: AssetBlocksByTransferComplianceAssetIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTransferComplianceAssetIdAndUpdatedBlockId: AssetBlocksByTransferComplianceAssetIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTransferComplianceExemptionAssetIdAndCreatedBlockId: AssetBlocksByTransferComplianceExemptionAssetIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTransferComplianceExemptionAssetIdAndUpdatedBlockId: AssetBlocksByTransferComplianceExemptionAssetIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTransferManagerAssetIdAndCreatedBlockId: AssetBlocksByTransferManagerAssetIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTransferManagerAssetIdAndUpdatedBlockId: AssetBlocksByTransferManagerAssetIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTrustedClaimIssuerAssetIdAndCreatedBlockId: AssetBlocksByTrustedClaimIssuerAssetIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTrustedClaimIssuerAssetIdAndUpdatedBlockId: AssetBlocksByTrustedClaimIssuerAssetIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Compliance`. */
  compliance: CompliancesConnection;
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `Asset`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `Distribution`. */
  distributions: DistributionsConnection;
  /** Reads and enables pagination through a set of `AssetDocument`. */
  documents: AssetDocumentsConnection;
  eventIdx: Scalars['Int']['output'];
  fundingRound?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `Funding`. */
  fundings: FundingsConnection;
  /** Reads and enables pagination through a set of `AssetHolder`. */
  holders: AssetHoldersConnection;
  id: Scalars['String']['output'];
  identifiers: Scalars['JSON']['output'];
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByAssetHolderAssetIdAndIdentityId: AssetIdentitiesByAssetHolderAssetIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByDistributionAssetIdAndIdentityId: AssetIdentitiesByDistributionAssetIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByStatTypeAssetIdAndClaimIssuerId: AssetIdentitiesByStatTypeAssetIdAndClaimIssuerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByStoOfferingAssetIdAndCreatorId: AssetIdentitiesByStoOfferingAssetIdAndCreatorIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByTickerExternalAgentActionAssetIdAndCallerId: AssetIdentitiesByTickerExternalAgentActionAssetIdAndCallerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByTickerExternalAgentAssetIdAndCallerId: AssetIdentitiesByTickerExternalAgentAssetIdAndCallerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByTickerExternalAgentHistoryAssetIdAndIdentityId: AssetIdentitiesByTickerExternalAgentHistoryAssetIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByTransferComplianceAssetIdAndClaimIssuerId: AssetIdentitiesByTransferComplianceAssetIdAndClaimIssuerIdManyToManyConnection;
  isCompliancePaused: Scalars['Boolean']['output'];
  isDivisible: Scalars['Boolean']['output'];
  isFrozen: Scalars['Boolean']['output'];
  isUniquenessRequired: Scalars['Boolean']['output'];
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Identity` that is related to this `Asset`. */
  owner?: Maybe<Identity>;
  ownerId: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovements: PortfolioMovementsConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByAssetTransactionAssetIdAndFromPortfolioId: AssetPortfoliosByAssetTransactionAssetIdAndFromPortfolioIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByAssetTransactionAssetIdAndToPortfolioId: AssetPortfoliosByAssetTransactionAssetIdAndToPortfolioIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByDistributionAssetIdAndPortfolioId: AssetPortfoliosByDistributionAssetIdAndPortfolioIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByPortfolioMovementAssetIdAndFromId: AssetPortfoliosByPortfolioMovementAssetIdAndFromIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByPortfolioMovementAssetIdAndToId: AssetPortfoliosByPortfolioMovementAssetIdAndToIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByStoOfferingAssetIdAndOfferingPortfolioId: AssetPortfoliosByStoOfferingAssetIdAndOfferingPortfolioIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByStoOfferingAssetIdAndRaisingPortfolioId: AssetPortfoliosByStoOfferingAssetIdAndRaisingPortfolioIdManyToManyConnection;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypes: StatTypesConnection;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypesByTransferComplianceAssetIdAndStatTypeId: AssetStatTypesByTransferComplianceAssetIdAndStatTypeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByOfferingAssetId: StosConnection;
  ticker: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `TickerExternalAgentAction`. */
  tickerExternalAgentActions: TickerExternalAgentActionsConnection;
  /** Reads and enables pagination through a set of `TickerExternalAgentHistory`. */
  tickerExternalAgentHistories: TickerExternalAgentHistoriesConnection;
  /** Reads and enables pagination through a set of `TickerExternalAgent`. */
  tickerExternalAgents: TickerExternalAgentsConnection;
  totalSupply: Scalars['BigFloat']['output'];
  totalTransfers: Scalars['BigFloat']['output'];
  /** Reads and enables pagination through a set of `TransferComplianceExemption`. */
  transferComplianceExemptions: TransferComplianceExemptionsConnection;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliances: TransferCompliancesConnection;
  /** Reads and enables pagination through a set of `TransferManager`. */
  transferManagers: TransferManagersConnection;
  /** Reads and enables pagination through a set of `TrustedClaimIssuer`. */
  trustedClaimIssuers: TrustedClaimIssuersConnection;
  type?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `Asset`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `Venue`. */
  venuesByStoOfferingAssetIdAndVenueId: AssetVenuesByStoOfferingAssetIdAndVenueIdManyToManyConnection;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetAssetTransactionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetTransactionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetTransactionsOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetBlocksByAssetDocumentAssetIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetBlocksByAssetDocumentAssetIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetBlocksByAssetHolderAssetIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetBlocksByAssetHolderAssetIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetBlocksByAssetTransactionAssetIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetBlocksByAssetTransactionAssetIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetBlocksByComplianceAssetIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetBlocksByComplianceAssetIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetBlocksByDistributionAssetIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetBlocksByDistributionAssetIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetBlocksByFundingAssetIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetBlocksByFundingAssetIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetBlocksByPortfolioMovementAssetIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetBlocksByPortfolioMovementAssetIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetBlocksByStatTypeAssetIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetBlocksByStatTypeAssetIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetBlocksByStoOfferingAssetIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetBlocksByStoOfferingAssetIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetBlocksByTickerExternalAgentActionAssetIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetBlocksByTickerExternalAgentActionAssetIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetBlocksByTickerExternalAgentAssetIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetBlocksByTickerExternalAgentAssetIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetBlocksByTickerExternalAgentHistoryAssetIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetBlocksByTickerExternalAgentHistoryAssetIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetBlocksByTransferComplianceAssetIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetBlocksByTransferComplianceAssetIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetBlocksByTransferComplianceExemptionAssetIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetBlocksByTransferComplianceExemptionAssetIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetBlocksByTransferManagerAssetIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetBlocksByTransferManagerAssetIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetBlocksByTrustedClaimIssuerAssetIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetBlocksByTrustedClaimIssuerAssetIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetComplianceArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ComplianceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CompliancesOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetDistributionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<DistributionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DistributionsOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetDocumentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetDocumentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetDocumentsOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetFundingsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<FundingFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FundingsOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetHoldersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetHolderFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetHoldersOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetIdentitiesByAssetHolderAssetIdAndIdentityIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetIdentitiesByDistributionAssetIdAndIdentityIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetIdentitiesByStatTypeAssetIdAndClaimIssuerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetIdentitiesByStoOfferingAssetIdAndCreatorIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetIdentitiesByTickerExternalAgentActionAssetIdAndCallerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetIdentitiesByTickerExternalAgentAssetIdAndCallerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetIdentitiesByTickerExternalAgentHistoryAssetIdAndIdentityIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetIdentitiesByTransferComplianceAssetIdAndClaimIssuerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetPortfolioMovementsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioMovementFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfolioMovementsOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetPortfoliosByAssetTransactionAssetIdAndFromPortfolioIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetPortfoliosByAssetTransactionAssetIdAndToPortfolioIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetPortfoliosByDistributionAssetIdAndPortfolioIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetPortfoliosByPortfolioMovementAssetIdAndFromIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetPortfoliosByPortfolioMovementAssetIdAndToIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetPortfoliosByStoOfferingAssetIdAndOfferingPortfolioIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetPortfoliosByStoOfferingAssetIdAndRaisingPortfolioIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetStatTypesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StatTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StatTypesOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetStatTypesByTransferComplianceAssetIdAndStatTypeIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StatTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StatTypesOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetStosByOfferingAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StoFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StosOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetTickerExternalAgentActionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<TickerExternalAgentActionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TickerExternalAgentActionsOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetTickerExternalAgentHistoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<TickerExternalAgentHistoryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TickerExternalAgentHistoriesOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetTickerExternalAgentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<TickerExternalAgentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TickerExternalAgentsOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetTransferComplianceExemptionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<TransferComplianceExemptionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TransferComplianceExemptionsOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetTransferCompliancesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<TransferComplianceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TransferCompliancesOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetTransferManagersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<TransferManagerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TransferManagersOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetTrustedClaimIssuersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<TrustedClaimIssuerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TrustedClaimIssuersOrderBy>>;
};

/** Represents a tokenized Asset on the Polymesh chain. The central data structure for the ecosystem */
export type AssetVenuesByStoOfferingAssetIdAndVenueIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<VenueFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VenuesOrderBy>>;
};

export type AssetAggregates = {
  __typename?: 'AssetAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A connection to a list of `Block` values, with data from `AssetDocument`. */
export type AssetBlocksByAssetDocumentAssetIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByAssetDocumentAssetIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `AssetDocument`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByAssetDocumentAssetIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `AssetDocument`. */
export type AssetBlocksByAssetDocumentAssetIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AssetDocument`. */
export type AssetBlocksByAssetDocumentAssetIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByAssetDocumentAssetIdAndCreatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AssetDocument`. */
  assetDocumentsByCreatedBlockId: AssetDocumentsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `AssetDocument`. */
export type AssetBlocksByAssetDocumentAssetIdAndCreatedBlockIdManyToManyEdgeAssetDocumentsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AssetDocumentFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AssetDocumentsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `AssetDocument`. */
export type AssetBlocksByAssetDocumentAssetIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByAssetDocumentAssetIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `AssetDocument`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByAssetDocumentAssetIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `AssetDocument`. */
export type AssetBlocksByAssetDocumentAssetIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AssetDocument`. */
export type AssetBlocksByAssetDocumentAssetIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByAssetDocumentAssetIdAndUpdatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AssetDocument`. */
  assetDocumentsByUpdatedBlockId: AssetDocumentsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `AssetDocument`. */
export type AssetBlocksByAssetDocumentAssetIdAndUpdatedBlockIdManyToManyEdgeAssetDocumentsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AssetDocumentFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AssetDocumentsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `AssetHolder`. */
export type AssetBlocksByAssetHolderAssetIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByAssetHolderAssetIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `AssetHolder`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByAssetHolderAssetIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `AssetHolder`. */
export type AssetBlocksByAssetHolderAssetIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AssetHolder`. */
export type AssetBlocksByAssetHolderAssetIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByAssetHolderAssetIdAndCreatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AssetHolder`. */
  assetHoldersByCreatedBlockId: AssetHoldersConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `AssetHolder`. */
export type AssetBlocksByAssetHolderAssetIdAndCreatedBlockIdManyToManyEdgeAssetHoldersByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AssetHolderFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AssetHoldersOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `AssetHolder`. */
export type AssetBlocksByAssetHolderAssetIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByAssetHolderAssetIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `AssetHolder`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByAssetHolderAssetIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `AssetHolder`. */
export type AssetBlocksByAssetHolderAssetIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AssetHolder`. */
export type AssetBlocksByAssetHolderAssetIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByAssetHolderAssetIdAndUpdatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AssetHolder`. */
  assetHoldersByUpdatedBlockId: AssetHoldersConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `AssetHolder`. */
export type AssetBlocksByAssetHolderAssetIdAndUpdatedBlockIdManyToManyEdgeAssetHoldersByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AssetHolderFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AssetHoldersOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `AssetTransaction`. */
export type AssetBlocksByAssetTransactionAssetIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByAssetTransactionAssetIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `AssetTransaction`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByAssetTransactionAssetIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `AssetTransaction`. */
export type AssetBlocksByAssetTransactionAssetIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AssetTransaction`. */
export type AssetBlocksByAssetTransactionAssetIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByAssetTransactionAssetIdAndCreatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AssetTransaction`. */
  assetTransactionsByCreatedBlockId: AssetTransactionsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `AssetTransaction`. */
export type AssetBlocksByAssetTransactionAssetIdAndCreatedBlockIdManyToManyEdgeAssetTransactionsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AssetTransactionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AssetTransactionsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `AssetTransaction`. */
export type AssetBlocksByAssetTransactionAssetIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByAssetTransactionAssetIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `AssetTransaction`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByAssetTransactionAssetIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `AssetTransaction`. */
export type AssetBlocksByAssetTransactionAssetIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AssetTransaction`. */
export type AssetBlocksByAssetTransactionAssetIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByAssetTransactionAssetIdAndUpdatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AssetTransaction`. */
  assetTransactionsByUpdatedBlockId: AssetTransactionsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `AssetTransaction`. */
export type AssetBlocksByAssetTransactionAssetIdAndUpdatedBlockIdManyToManyEdgeAssetTransactionsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AssetTransactionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AssetTransactionsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Compliance`. */
export type AssetBlocksByComplianceAssetIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByComplianceAssetIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Compliance`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByComplianceAssetIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Compliance`. */
export type AssetBlocksByComplianceAssetIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Compliance`. */
export type AssetBlocksByComplianceAssetIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByComplianceAssetIdAndCreatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Compliance`. */
  compliancesByCreatedBlockId: CompliancesConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Compliance`. */
export type AssetBlocksByComplianceAssetIdAndCreatedBlockIdManyToManyEdgeCompliancesByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<ComplianceFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<CompliancesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Compliance`. */
export type AssetBlocksByComplianceAssetIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByComplianceAssetIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Compliance`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByComplianceAssetIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Compliance`. */
export type AssetBlocksByComplianceAssetIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Compliance`. */
export type AssetBlocksByComplianceAssetIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByComplianceAssetIdAndUpdatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Compliance`. */
  compliancesByUpdatedBlockId: CompliancesConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Compliance`. */
export type AssetBlocksByComplianceAssetIdAndUpdatedBlockIdManyToManyEdgeCompliancesByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<ComplianceFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<CompliancesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Distribution`. */
export type AssetBlocksByDistributionAssetIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByDistributionAssetIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByDistributionAssetIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Distribution`. */
export type AssetBlocksByDistributionAssetIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Distribution`. */
export type AssetBlocksByDistributionAssetIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByDistributionAssetIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributionsByCreatedBlockId: DistributionsConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Distribution`. */
export type AssetBlocksByDistributionAssetIdAndCreatedBlockIdManyToManyEdgeDistributionsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<DistributionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<DistributionsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Distribution`. */
export type AssetBlocksByDistributionAssetIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByDistributionAssetIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByDistributionAssetIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Distribution`. */
export type AssetBlocksByDistributionAssetIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Distribution`. */
export type AssetBlocksByDistributionAssetIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByDistributionAssetIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributionsByUpdatedBlockId: DistributionsConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Distribution`. */
export type AssetBlocksByDistributionAssetIdAndUpdatedBlockIdManyToManyEdgeDistributionsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<DistributionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<DistributionsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Funding`. */
export type AssetBlocksByFundingAssetIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByFundingAssetIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Funding`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByFundingAssetIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Funding`. */
export type AssetBlocksByFundingAssetIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Funding`. */
export type AssetBlocksByFundingAssetIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByFundingAssetIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Funding`. */
  fundingsByCreatedBlockId: FundingsConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Funding`. */
export type AssetBlocksByFundingAssetIdAndCreatedBlockIdManyToManyEdgeFundingsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<FundingFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<FundingsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Funding`. */
export type AssetBlocksByFundingAssetIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByFundingAssetIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Funding`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByFundingAssetIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Funding`. */
export type AssetBlocksByFundingAssetIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Funding`. */
export type AssetBlocksByFundingAssetIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByFundingAssetIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Funding`. */
  fundingsByUpdatedBlockId: FundingsConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Funding`. */
export type AssetBlocksByFundingAssetIdAndUpdatedBlockIdManyToManyEdgeFundingsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<FundingFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<FundingsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `PortfolioMovement`. */
export type AssetBlocksByPortfolioMovementAssetIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByPortfolioMovementAssetIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByPortfolioMovementAssetIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `PortfolioMovement`. */
export type AssetBlocksByPortfolioMovementAssetIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `PortfolioMovement`. */
export type AssetBlocksByPortfolioMovementAssetIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByPortfolioMovementAssetIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByCreatedBlockId: PortfolioMovementsConnection;
};

/** A `Block` edge in the connection, with data from `PortfolioMovement`. */
export type AssetBlocksByPortfolioMovementAssetIdAndCreatedBlockIdManyToManyEdgePortfolioMovementsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<PortfolioMovementFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<PortfolioMovementsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `PortfolioMovement`. */
export type AssetBlocksByPortfolioMovementAssetIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByPortfolioMovementAssetIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByPortfolioMovementAssetIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `PortfolioMovement`. */
export type AssetBlocksByPortfolioMovementAssetIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `PortfolioMovement`. */
export type AssetBlocksByPortfolioMovementAssetIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByPortfolioMovementAssetIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByUpdatedBlockId: PortfolioMovementsConnection;
};

/** A `Block` edge in the connection, with data from `PortfolioMovement`. */
export type AssetBlocksByPortfolioMovementAssetIdAndUpdatedBlockIdManyToManyEdgePortfolioMovementsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<PortfolioMovementFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<PortfolioMovementsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `StatType`. */
export type AssetBlocksByStatTypeAssetIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByStatTypeAssetIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `StatType`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByStatTypeAssetIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `StatType`. */
export type AssetBlocksByStatTypeAssetIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `StatType`. */
export type AssetBlocksByStatTypeAssetIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByStatTypeAssetIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypesByCreatedBlockId: StatTypesConnection;
};

/** A `Block` edge in the connection, with data from `StatType`. */
export type AssetBlocksByStatTypeAssetIdAndCreatedBlockIdManyToManyEdgeStatTypesByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StatTypeFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StatTypesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `StatType`. */
export type AssetBlocksByStatTypeAssetIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByStatTypeAssetIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `StatType`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByStatTypeAssetIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `StatType`. */
export type AssetBlocksByStatTypeAssetIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `StatType`. */
export type AssetBlocksByStatTypeAssetIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByStatTypeAssetIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypesByUpdatedBlockId: StatTypesConnection;
};

/** A `Block` edge in the connection, with data from `StatType`. */
export type AssetBlocksByStatTypeAssetIdAndUpdatedBlockIdManyToManyEdgeStatTypesByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StatTypeFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StatTypesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Sto`. */
export type AssetBlocksByStoOfferingAssetIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByStoOfferingAssetIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByStoOfferingAssetIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Sto`. */
export type AssetBlocksByStoOfferingAssetIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Sto`. */
export type AssetBlocksByStoOfferingAssetIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByStoOfferingAssetIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByCreatedBlockId: StosConnection;
};

/** A `Block` edge in the connection, with data from `Sto`. */
export type AssetBlocksByStoOfferingAssetIdAndCreatedBlockIdManyToManyEdgeStosByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StoFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StosOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Sto`. */
export type AssetBlocksByStoOfferingAssetIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByStoOfferingAssetIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByStoOfferingAssetIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Sto`. */
export type AssetBlocksByStoOfferingAssetIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Sto`. */
export type AssetBlocksByStoOfferingAssetIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByStoOfferingAssetIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByUpdatedBlockId: StosConnection;
};

/** A `Block` edge in the connection, with data from `Sto`. */
export type AssetBlocksByStoOfferingAssetIdAndUpdatedBlockIdManyToManyEdgeStosByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StoFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StosOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentAction`. */
export type AssetBlocksByTickerExternalAgentActionAssetIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByTickerExternalAgentActionAssetIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `TickerExternalAgentAction`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByTickerExternalAgentActionAssetIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `TickerExternalAgentAction`. */
export type AssetBlocksByTickerExternalAgentActionAssetIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TickerExternalAgentAction`. */
export type AssetBlocksByTickerExternalAgentActionAssetIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByTickerExternalAgentActionAssetIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TickerExternalAgentAction`. */
  tickerExternalAgentActionsByCreatedBlockId: TickerExternalAgentActionsConnection;
};

/** A `Block` edge in the connection, with data from `TickerExternalAgentAction`. */
export type AssetBlocksByTickerExternalAgentActionAssetIdAndCreatedBlockIdManyToManyEdgeTickerExternalAgentActionsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TickerExternalAgentActionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TickerExternalAgentActionsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentAction`. */
export type AssetBlocksByTickerExternalAgentActionAssetIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByTickerExternalAgentActionAssetIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `TickerExternalAgentAction`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByTickerExternalAgentActionAssetIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `TickerExternalAgentAction`. */
export type AssetBlocksByTickerExternalAgentActionAssetIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TickerExternalAgentAction`. */
export type AssetBlocksByTickerExternalAgentActionAssetIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByTickerExternalAgentActionAssetIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TickerExternalAgentAction`. */
  tickerExternalAgentActionsByUpdatedBlockId: TickerExternalAgentActionsConnection;
};

/** A `Block` edge in the connection, with data from `TickerExternalAgentAction`. */
export type AssetBlocksByTickerExternalAgentActionAssetIdAndUpdatedBlockIdManyToManyEdgeTickerExternalAgentActionsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TickerExternalAgentActionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TickerExternalAgentActionsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgent`. */
export type AssetBlocksByTickerExternalAgentAssetIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByTickerExternalAgentAssetIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `TickerExternalAgent`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByTickerExternalAgentAssetIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `TickerExternalAgent`. */
export type AssetBlocksByTickerExternalAgentAssetIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TickerExternalAgent`. */
export type AssetBlocksByTickerExternalAgentAssetIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByTickerExternalAgentAssetIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TickerExternalAgent`. */
  tickerExternalAgentsByCreatedBlockId: TickerExternalAgentsConnection;
};

/** A `Block` edge in the connection, with data from `TickerExternalAgent`. */
export type AssetBlocksByTickerExternalAgentAssetIdAndCreatedBlockIdManyToManyEdgeTickerExternalAgentsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TickerExternalAgentFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TickerExternalAgentsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgent`. */
export type AssetBlocksByTickerExternalAgentAssetIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByTickerExternalAgentAssetIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `TickerExternalAgent`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByTickerExternalAgentAssetIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `TickerExternalAgent`. */
export type AssetBlocksByTickerExternalAgentAssetIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TickerExternalAgent`. */
export type AssetBlocksByTickerExternalAgentAssetIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByTickerExternalAgentAssetIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TickerExternalAgent`. */
  tickerExternalAgentsByUpdatedBlockId: TickerExternalAgentsConnection;
};

/** A `Block` edge in the connection, with data from `TickerExternalAgent`. */
export type AssetBlocksByTickerExternalAgentAssetIdAndUpdatedBlockIdManyToManyEdgeTickerExternalAgentsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TickerExternalAgentFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TickerExternalAgentsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentHistory`. */
export type AssetBlocksByTickerExternalAgentHistoryAssetIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByTickerExternalAgentHistoryAssetIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `TickerExternalAgentHistory`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByTickerExternalAgentHistoryAssetIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `TickerExternalAgentHistory`. */
export type AssetBlocksByTickerExternalAgentHistoryAssetIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type AssetBlocksByTickerExternalAgentHistoryAssetIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByTickerExternalAgentHistoryAssetIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TickerExternalAgentHistory`. */
  tickerExternalAgentHistoriesByCreatedBlockId: TickerExternalAgentHistoriesConnection;
};

/** A `Block` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type AssetBlocksByTickerExternalAgentHistoryAssetIdAndCreatedBlockIdManyToManyEdgeTickerExternalAgentHistoriesByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TickerExternalAgentHistoryFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TickerExternalAgentHistoriesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentHistory`. */
export type AssetBlocksByTickerExternalAgentHistoryAssetIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByTickerExternalAgentHistoryAssetIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `TickerExternalAgentHistory`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByTickerExternalAgentHistoryAssetIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `TickerExternalAgentHistory`. */
export type AssetBlocksByTickerExternalAgentHistoryAssetIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type AssetBlocksByTickerExternalAgentHistoryAssetIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByTickerExternalAgentHistoryAssetIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TickerExternalAgentHistory`. */
  tickerExternalAgentHistoriesByUpdatedBlockId: TickerExternalAgentHistoriesConnection;
};

/** A `Block` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type AssetBlocksByTickerExternalAgentHistoryAssetIdAndUpdatedBlockIdManyToManyEdgeTickerExternalAgentHistoriesByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TickerExternalAgentHistoryFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TickerExternalAgentHistoriesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `TransferCompliance`. */
export type AssetBlocksByTransferComplianceAssetIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByTransferComplianceAssetIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByTransferComplianceAssetIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `TransferCompliance`. */
export type AssetBlocksByTransferComplianceAssetIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TransferCompliance`. */
export type AssetBlocksByTransferComplianceAssetIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByTransferComplianceAssetIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliancesByCreatedBlockId: TransferCompliancesConnection;
};

/** A `Block` edge in the connection, with data from `TransferCompliance`. */
export type AssetBlocksByTransferComplianceAssetIdAndCreatedBlockIdManyToManyEdgeTransferCompliancesByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TransferComplianceFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TransferCompliancesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `TransferCompliance`. */
export type AssetBlocksByTransferComplianceAssetIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByTransferComplianceAssetIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByTransferComplianceAssetIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `TransferCompliance`. */
export type AssetBlocksByTransferComplianceAssetIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TransferCompliance`. */
export type AssetBlocksByTransferComplianceAssetIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByTransferComplianceAssetIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliancesByUpdatedBlockId: TransferCompliancesConnection;
};

/** A `Block` edge in the connection, with data from `TransferCompliance`. */
export type AssetBlocksByTransferComplianceAssetIdAndUpdatedBlockIdManyToManyEdgeTransferCompliancesByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TransferComplianceFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TransferCompliancesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `TransferComplianceExemption`. */
export type AssetBlocksByTransferComplianceExemptionAssetIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByTransferComplianceExemptionAssetIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `TransferComplianceExemption`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByTransferComplianceExemptionAssetIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `TransferComplianceExemption`. */
export type AssetBlocksByTransferComplianceExemptionAssetIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TransferComplianceExemption`. */
export type AssetBlocksByTransferComplianceExemptionAssetIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByTransferComplianceExemptionAssetIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TransferComplianceExemption`. */
  transferComplianceExemptionsByCreatedBlockId: TransferComplianceExemptionsConnection;
};

/** A `Block` edge in the connection, with data from `TransferComplianceExemption`. */
export type AssetBlocksByTransferComplianceExemptionAssetIdAndCreatedBlockIdManyToManyEdgeTransferComplianceExemptionsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TransferComplianceExemptionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TransferComplianceExemptionsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `TransferComplianceExemption`. */
export type AssetBlocksByTransferComplianceExemptionAssetIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByTransferComplianceExemptionAssetIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `TransferComplianceExemption`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByTransferComplianceExemptionAssetIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `TransferComplianceExemption`. */
export type AssetBlocksByTransferComplianceExemptionAssetIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TransferComplianceExemption`. */
export type AssetBlocksByTransferComplianceExemptionAssetIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByTransferComplianceExemptionAssetIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TransferComplianceExemption`. */
  transferComplianceExemptionsByUpdatedBlockId: TransferComplianceExemptionsConnection;
};

/** A `Block` edge in the connection, with data from `TransferComplianceExemption`. */
export type AssetBlocksByTransferComplianceExemptionAssetIdAndUpdatedBlockIdManyToManyEdgeTransferComplianceExemptionsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TransferComplianceExemptionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TransferComplianceExemptionsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `TransferManager`. */
export type AssetBlocksByTransferManagerAssetIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByTransferManagerAssetIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `TransferManager`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByTransferManagerAssetIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `TransferManager`. */
export type AssetBlocksByTransferManagerAssetIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TransferManager`. */
export type AssetBlocksByTransferManagerAssetIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByTransferManagerAssetIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TransferManager`. */
  transferManagersByCreatedBlockId: TransferManagersConnection;
};

/** A `Block` edge in the connection, with data from `TransferManager`. */
export type AssetBlocksByTransferManagerAssetIdAndCreatedBlockIdManyToManyEdgeTransferManagersByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TransferManagerFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TransferManagersOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `TransferManager`. */
export type AssetBlocksByTransferManagerAssetIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByTransferManagerAssetIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `TransferManager`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByTransferManagerAssetIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `TransferManager`. */
export type AssetBlocksByTransferManagerAssetIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TransferManager`. */
export type AssetBlocksByTransferManagerAssetIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByTransferManagerAssetIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TransferManager`. */
  transferManagersByUpdatedBlockId: TransferManagersConnection;
};

/** A `Block` edge in the connection, with data from `TransferManager`. */
export type AssetBlocksByTransferManagerAssetIdAndUpdatedBlockIdManyToManyEdgeTransferManagersByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TransferManagerFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TransferManagersOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `TrustedClaimIssuer`. */
export type AssetBlocksByTrustedClaimIssuerAssetIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByTrustedClaimIssuerAssetIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `TrustedClaimIssuer`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByTrustedClaimIssuerAssetIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `TrustedClaimIssuer`. */
export type AssetBlocksByTrustedClaimIssuerAssetIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TrustedClaimIssuer`. */
export type AssetBlocksByTrustedClaimIssuerAssetIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByTrustedClaimIssuerAssetIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TrustedClaimIssuer`. */
  trustedClaimIssuersByCreatedBlockId: TrustedClaimIssuersConnection;
};

/** A `Block` edge in the connection, with data from `TrustedClaimIssuer`. */
export type AssetBlocksByTrustedClaimIssuerAssetIdAndCreatedBlockIdManyToManyEdgeTrustedClaimIssuersByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TrustedClaimIssuerFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TrustedClaimIssuersOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `TrustedClaimIssuer`. */
export type AssetBlocksByTrustedClaimIssuerAssetIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByTrustedClaimIssuerAssetIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `TrustedClaimIssuer`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByTrustedClaimIssuerAssetIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `TrustedClaimIssuer`. */
export type AssetBlocksByTrustedClaimIssuerAssetIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TrustedClaimIssuer`. */
export type AssetBlocksByTrustedClaimIssuerAssetIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByTrustedClaimIssuerAssetIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TrustedClaimIssuer`. */
  trustedClaimIssuersByUpdatedBlockId: TrustedClaimIssuersConnection;
};

/** A `Block` edge in the connection, with data from `TrustedClaimIssuer`. */
export type AssetBlocksByTrustedClaimIssuerAssetIdAndUpdatedBlockIdManyToManyEdgeTrustedClaimIssuersByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TrustedClaimIssuerFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TrustedClaimIssuersOrderBy>>;
  };

/**
 * Represents off chain documentation for an Asset. A hash should be included on chain so readers can be sure their copy has not been tampered with
 *
 * e.g. A companies 10-K report
 */
export type AssetDocument = Node & {
  __typename?: 'AssetDocument';
  /** Reads a single `Asset` that is related to this `AssetDocument`. */
  asset?: Maybe<Asset>;
  assetId: Scalars['String']['output'];
  contentHash?: Maybe<Scalars['JSON']['output']>;
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `AssetDocument`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  documentId: Scalars['Int']['output'];
  filedAt?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['String']['output'];
  link: Scalars['String']['output'];
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  type?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `AssetDocument`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
};

export type AssetDocumentAggregates = {
  __typename?: 'AssetDocumentAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A filter to be used against `AssetDocument` object types. All fields are combined with a logical ‘and.’ */
export type AssetDocumentFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AssetDocumentFilter>>;
  /** Filter by the object’s `assetId` field. */
  assetId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `contentHash` field. */
  contentHash?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `documentId` field. */
  documentId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `filedAt` field. */
  filedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `link` field. */
  link?: InputMaybe<StringFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AssetDocumentFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AssetDocumentFilter>>;
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
};

/** A connection to a list of `AssetDocument` values. */
export type AssetDocumentsConnection = {
  __typename?: 'AssetDocumentsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetDocumentAggregates>;
  /** A list of edges which contains the `AssetDocument` and cursor to aid in pagination. */
  edges: Array<AssetDocumentsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetDocumentAggregates>>;
  /** A list of `AssetDocument` objects. */
  nodes: Array<Maybe<AssetDocument>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AssetDocument` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `AssetDocument` values. */
export type AssetDocumentsConnectionGroupedAggregatesArgs = {
  groupBy: Array<AssetDocumentsGroupBy>;
  having?: InputMaybe<AssetDocumentsHavingInput>;
};

/** A `AssetDocument` edge in the connection. */
export type AssetDocumentsEdge = {
  __typename?: 'AssetDocumentsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AssetDocument` at the end of the edge. */
  node?: Maybe<AssetDocument>;
};

/** Grouping methods for `AssetDocument` for usage during aggregation. */
export enum AssetDocumentsGroupBy {
  AssetId = 'ASSET_ID',
  ContentHash = 'CONTENT_HASH',
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  DocumentId = 'DOCUMENT_ID',
  FiledAt = 'FILED_AT',
  Link = 'LINK',
  Name = 'NAME',
  Type = 'TYPE',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
}

/** Conditions for `AssetDocument` aggregates. */
export type AssetDocumentsHavingInput = {
  AND?: InputMaybe<Array<AssetDocumentsHavingInput>>;
  OR?: InputMaybe<Array<AssetDocumentsHavingInput>>;
};

/** Methods to use when ordering `AssetDocument`. */
export enum AssetDocumentsOrderBy {
  AssetIdAsc = 'ASSET_ID_ASC',
  AssetIdDesc = 'ASSET_ID_DESC',
  ContentHashAsc = 'CONTENT_HASH_ASC',
  ContentHashDesc = 'CONTENT_HASH_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  DocumentIdAsc = 'DOCUMENT_ID_ASC',
  DocumentIdDesc = 'DOCUMENT_ID_DESC',
  FiledAtAsc = 'FILED_AT_ASC',
  FiledAtDesc = 'FILED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LinkAsc = 'LINK_ASC',
  LinkDesc = 'LINK_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
}

/** A filter to be used against `Asset` object types. All fields are combined with a logical ‘and.’ */
export type AssetFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AssetFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `eventIdx` field. */
  eventIdx?: InputMaybe<IntFilter>;
  /** Filter by the object’s `fundingRound` field. */
  fundingRound?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `identifiers` field. */
  identifiers?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `isCompliancePaused` field. */
  isCompliancePaused?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isDivisible` field. */
  isDivisible?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isFrozen` field. */
  isFrozen?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isUniquenessRequired` field. */
  isUniquenessRequired?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AssetFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AssetFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `ticker` field. */
  ticker?: InputMaybe<StringFilter>;
  /** Filter by the object’s `totalSupply` field. */
  totalSupply?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totalTransfers` field. */
  totalTransfers?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
};

/** Represents how much of a given Asset an Identity owns */
export type AssetHolder = Node & {
  __typename?: 'AssetHolder';
  amount: Scalars['BigFloat']['output'];
  /** Reads a single `Asset` that is related to this `AssetHolder`. */
  asset?: Maybe<Asset>;
  assetId: Scalars['String']['output'];
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `AssetHolder`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  id: Scalars['String']['output'];
  /** Reads a single `Identity` that is related to this `AssetHolder`. */
  identity?: Maybe<Identity>;
  identityId: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `AssetHolder`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
};

export type AssetHolderAggregates = {
  __typename?: 'AssetHolderAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A filter to be used against `AssetHolder` object types. All fields are combined with a logical ‘and.’ */
export type AssetHolderFilter = {
  /** Filter by the object’s `amount` field. */
  amount?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AssetHolderFilter>>;
  /** Filter by the object’s `assetId` field. */
  assetId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `identityId` field. */
  identityId?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AssetHolderFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AssetHolderFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
};

/** A connection to a list of `AssetHolder` values. */
export type AssetHoldersConnection = {
  __typename?: 'AssetHoldersConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetHolderAggregates>;
  /** A list of edges which contains the `AssetHolder` and cursor to aid in pagination. */
  edges: Array<AssetHoldersEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetHolderAggregates>>;
  /** A list of `AssetHolder` objects. */
  nodes: Array<Maybe<AssetHolder>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AssetHolder` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `AssetHolder` values. */
export type AssetHoldersConnectionGroupedAggregatesArgs = {
  groupBy: Array<AssetHoldersGroupBy>;
  having?: InputMaybe<AssetHoldersHavingInput>;
};

/** A `AssetHolder` edge in the connection. */
export type AssetHoldersEdge = {
  __typename?: 'AssetHoldersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AssetHolder` at the end of the edge. */
  node?: Maybe<AssetHolder>;
};

/** Grouping methods for `AssetHolder` for usage during aggregation. */
export enum AssetHoldersGroupBy {
  Amount = 'AMOUNT',
  AssetId = 'ASSET_ID',
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  IdentityId = 'IDENTITY_ID',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
}

/** Conditions for `AssetHolder` aggregates. */
export type AssetHoldersHavingInput = {
  AND?: InputMaybe<Array<AssetHoldersHavingInput>>;
  OR?: InputMaybe<Array<AssetHoldersHavingInput>>;
};

/** Methods to use when ordering `AssetHolder`. */
export enum AssetHoldersOrderBy {
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  AssetIdAsc = 'ASSET_ID_ASC',
  AssetIdDesc = 'ASSET_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  IdentityIdAsc = 'IDENTITY_ID_ASC',
  IdentityIdDesc = 'IDENTITY_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
}

/** A connection to a list of `Identity` values, with data from `AssetHolder`. */
export type AssetIdentitiesByAssetHolderAssetIdAndIdentityIdManyToManyConnection = {
  __typename?: 'AssetIdentitiesByAssetHolderAssetIdAndIdentityIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `AssetHolder`, and the cursor to aid in pagination. */
  edges: Array<AssetIdentitiesByAssetHolderAssetIdAndIdentityIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `AssetHolder`. */
export type AssetIdentitiesByAssetHolderAssetIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `AssetHolder`. */
export type AssetIdentitiesByAssetHolderAssetIdAndIdentityIdManyToManyEdge = {
  __typename?: 'AssetIdentitiesByAssetHolderAssetIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `AssetHolder`. */
  heldAssets: AssetHoldersConnection;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
};

/** A `Identity` edge in the connection, with data from `AssetHolder`. */
export type AssetIdentitiesByAssetHolderAssetIdAndIdentityIdManyToManyEdgeHeldAssetsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetHolderFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetHoldersOrderBy>>;
};

/** A connection to a list of `Identity` values, with data from `Distribution`. */
export type AssetIdentitiesByDistributionAssetIdAndIdentityIdManyToManyConnection = {
  __typename?: 'AssetIdentitiesByDistributionAssetIdAndIdentityIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<AssetIdentitiesByDistributionAssetIdAndIdentityIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `Distribution`. */
export type AssetIdentitiesByDistributionAssetIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Distribution`. */
export type AssetIdentitiesByDistributionAssetIdAndIdentityIdManyToManyEdge = {
  __typename?: 'AssetIdentitiesByDistributionAssetIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributions: DistributionsConnection;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
};

/** A `Identity` edge in the connection, with data from `Distribution`. */
export type AssetIdentitiesByDistributionAssetIdAndIdentityIdManyToManyEdgeDistributionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<DistributionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DistributionsOrderBy>>;
};

/** A connection to a list of `Identity` values, with data from `StatType`. */
export type AssetIdentitiesByStatTypeAssetIdAndClaimIssuerIdManyToManyConnection = {
  __typename?: 'AssetIdentitiesByStatTypeAssetIdAndClaimIssuerIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `StatType`, and the cursor to aid in pagination. */
  edges: Array<AssetIdentitiesByStatTypeAssetIdAndClaimIssuerIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `StatType`. */
export type AssetIdentitiesByStatTypeAssetIdAndClaimIssuerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `StatType`. */
export type AssetIdentitiesByStatTypeAssetIdAndClaimIssuerIdManyToManyEdge = {
  __typename?: 'AssetIdentitiesByStatTypeAssetIdAndClaimIssuerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypesByClaimIssuerId: StatTypesConnection;
};

/** A `Identity` edge in the connection, with data from `StatType`. */
export type AssetIdentitiesByStatTypeAssetIdAndClaimIssuerIdManyToManyEdgeStatTypesByClaimIssuerIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StatTypeFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StatTypesOrderBy>>;
  };

/** A connection to a list of `Identity` values, with data from `Sto`. */
export type AssetIdentitiesByStoOfferingAssetIdAndCreatorIdManyToManyConnection = {
  __typename?: 'AssetIdentitiesByStoOfferingAssetIdAndCreatorIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<AssetIdentitiesByStoOfferingAssetIdAndCreatorIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `Sto`. */
export type AssetIdentitiesByStoOfferingAssetIdAndCreatorIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Sto`. */
export type AssetIdentitiesByStoOfferingAssetIdAndCreatorIdManyToManyEdge = {
  __typename?: 'AssetIdentitiesByStoOfferingAssetIdAndCreatorIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByCreatorId: StosConnection;
};

/** A `Identity` edge in the connection, with data from `Sto`. */
export type AssetIdentitiesByStoOfferingAssetIdAndCreatorIdManyToManyEdgeStosByCreatorIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StoFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StosOrderBy>>;
};

/** A connection to a list of `Identity` values, with data from `TickerExternalAgentAction`. */
export type AssetIdentitiesByTickerExternalAgentActionAssetIdAndCallerIdManyToManyConnection = {
  __typename?: 'AssetIdentitiesByTickerExternalAgentActionAssetIdAndCallerIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `TickerExternalAgentAction`, and the cursor to aid in pagination. */
  edges: Array<AssetIdentitiesByTickerExternalAgentActionAssetIdAndCallerIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `TickerExternalAgentAction`. */
export type AssetIdentitiesByTickerExternalAgentActionAssetIdAndCallerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `TickerExternalAgentAction`. */
export type AssetIdentitiesByTickerExternalAgentActionAssetIdAndCallerIdManyToManyEdge = {
  __typename?: 'AssetIdentitiesByTickerExternalAgentActionAssetIdAndCallerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `TickerExternalAgentAction`. */
  tickerExternalAgentActionsByCallerId: TickerExternalAgentActionsConnection;
};

/** A `Identity` edge in the connection, with data from `TickerExternalAgentAction`. */
export type AssetIdentitiesByTickerExternalAgentActionAssetIdAndCallerIdManyToManyEdgeTickerExternalAgentActionsByCallerIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TickerExternalAgentActionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TickerExternalAgentActionsOrderBy>>;
  };

/** A connection to a list of `Identity` values, with data from `TickerExternalAgent`. */
export type AssetIdentitiesByTickerExternalAgentAssetIdAndCallerIdManyToManyConnection = {
  __typename?: 'AssetIdentitiesByTickerExternalAgentAssetIdAndCallerIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `TickerExternalAgent`, and the cursor to aid in pagination. */
  edges: Array<AssetIdentitiesByTickerExternalAgentAssetIdAndCallerIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `TickerExternalAgent`. */
export type AssetIdentitiesByTickerExternalAgentAssetIdAndCallerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `TickerExternalAgent`. */
export type AssetIdentitiesByTickerExternalAgentAssetIdAndCallerIdManyToManyEdge = {
  __typename?: 'AssetIdentitiesByTickerExternalAgentAssetIdAndCallerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `TickerExternalAgent`. */
  tickerExternalAgentsByCallerId: TickerExternalAgentsConnection;
};

/** A `Identity` edge in the connection, with data from `TickerExternalAgent`. */
export type AssetIdentitiesByTickerExternalAgentAssetIdAndCallerIdManyToManyEdgeTickerExternalAgentsByCallerIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TickerExternalAgentFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TickerExternalAgentsOrderBy>>;
  };

/** A connection to a list of `Identity` values, with data from `TickerExternalAgentHistory`. */
export type AssetIdentitiesByTickerExternalAgentHistoryAssetIdAndIdentityIdManyToManyConnection = {
  __typename?: 'AssetIdentitiesByTickerExternalAgentHistoryAssetIdAndIdentityIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `TickerExternalAgentHistory`, and the cursor to aid in pagination. */
  edges: Array<AssetIdentitiesByTickerExternalAgentHistoryAssetIdAndIdentityIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `TickerExternalAgentHistory`. */
export type AssetIdentitiesByTickerExternalAgentHistoryAssetIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type AssetIdentitiesByTickerExternalAgentHistoryAssetIdAndIdentityIdManyToManyEdge = {
  __typename?: 'AssetIdentitiesByTickerExternalAgentHistoryAssetIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `TickerExternalAgentHistory`. */
  tickerExternalAgentHistories: TickerExternalAgentHistoriesConnection;
};

/** A `Identity` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type AssetIdentitiesByTickerExternalAgentHistoryAssetIdAndIdentityIdManyToManyEdgeTickerExternalAgentHistoriesArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TickerExternalAgentHistoryFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TickerExternalAgentHistoriesOrderBy>>;
  };

/** A connection to a list of `Identity` values, with data from `TransferCompliance`. */
export type AssetIdentitiesByTransferComplianceAssetIdAndClaimIssuerIdManyToManyConnection = {
  __typename?: 'AssetIdentitiesByTransferComplianceAssetIdAndClaimIssuerIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
  edges: Array<AssetIdentitiesByTransferComplianceAssetIdAndClaimIssuerIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `TransferCompliance`. */
export type AssetIdentitiesByTransferComplianceAssetIdAndClaimIssuerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `TransferCompliance`. */
export type AssetIdentitiesByTransferComplianceAssetIdAndClaimIssuerIdManyToManyEdge = {
  __typename?: 'AssetIdentitiesByTransferComplianceAssetIdAndClaimIssuerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliancesByClaimIssuerId: TransferCompliancesConnection;
};

/** A `Identity` edge in the connection, with data from `TransferCompliance`. */
export type AssetIdentitiesByTransferComplianceAssetIdAndClaimIssuerIdManyToManyEdgeTransferCompliancesByClaimIssuerIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TransferComplianceFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TransferCompliancesOrderBy>>;
  };

/** Represents a request to take ownership of a particular Asset */
export type AssetPendingOwnershipTransfer = Node & {
  __typename?: 'AssetPendingOwnershipTransfer';
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `AssetPendingOwnershipTransfer`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  data?: Maybe<Scalars['String']['output']>;
  from: Scalars['String']['output'];
  id: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ticker: Scalars['String']['output'];
  to: Scalars['String']['output'];
  type: Scalars['String']['output'];
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `AssetPendingOwnershipTransfer`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
};

export type AssetPendingOwnershipTransferAggregates = {
  __typename?: 'AssetPendingOwnershipTransferAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A filter to be used against `AssetPendingOwnershipTransfer` object types. All fields are combined with a logical ‘and.’ */
export type AssetPendingOwnershipTransferFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AssetPendingOwnershipTransferFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `data` field. */
  data?: InputMaybe<StringFilter>;
  /** Filter by the object’s `from` field. */
  from?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AssetPendingOwnershipTransferFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AssetPendingOwnershipTransferFilter>>;
  /** Filter by the object’s `ticker` field. */
  ticker?: InputMaybe<StringFilter>;
  /** Filter by the object’s `to` field. */
  to?: InputMaybe<StringFilter>;
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
};

/** A connection to a list of `AssetPendingOwnershipTransfer` values. */
export type AssetPendingOwnershipTransfersConnection = {
  __typename?: 'AssetPendingOwnershipTransfersConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetPendingOwnershipTransferAggregates>;
  /** A list of edges which contains the `AssetPendingOwnershipTransfer` and cursor to aid in pagination. */
  edges: Array<AssetPendingOwnershipTransfersEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetPendingOwnershipTransferAggregates>>;
  /** A list of `AssetPendingOwnershipTransfer` objects. */
  nodes: Array<Maybe<AssetPendingOwnershipTransfer>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AssetPendingOwnershipTransfer` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `AssetPendingOwnershipTransfer` values. */
export type AssetPendingOwnershipTransfersConnectionGroupedAggregatesArgs = {
  groupBy: Array<AssetPendingOwnershipTransfersGroupBy>;
  having?: InputMaybe<AssetPendingOwnershipTransfersHavingInput>;
};

/** A `AssetPendingOwnershipTransfer` edge in the connection. */
export type AssetPendingOwnershipTransfersEdge = {
  __typename?: 'AssetPendingOwnershipTransfersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AssetPendingOwnershipTransfer` at the end of the edge. */
  node?: Maybe<AssetPendingOwnershipTransfer>;
};

/** Grouping methods for `AssetPendingOwnershipTransfer` for usage during aggregation. */
export enum AssetPendingOwnershipTransfersGroupBy {
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  Data = 'DATA',
  From = 'FROM',
  Ticker = 'TICKER',
  To = 'TO',
  Type = 'TYPE',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
}

/** Conditions for `AssetPendingOwnershipTransfer` aggregates. */
export type AssetPendingOwnershipTransfersHavingInput = {
  AND?: InputMaybe<Array<AssetPendingOwnershipTransfersHavingInput>>;
  OR?: InputMaybe<Array<AssetPendingOwnershipTransfersHavingInput>>;
};

/** Methods to use when ordering `AssetPendingOwnershipTransfer`. */
export enum AssetPendingOwnershipTransfersOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  DataAsc = 'DATA_ASC',
  DataDesc = 'DATA_DESC',
  FromAsc = 'FROM_ASC',
  FromDesc = 'FROM_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TickerAsc = 'TICKER_ASC',
  TickerDesc = 'TICKER_DESC',
  ToAsc = 'TO_ASC',
  ToDesc = 'TO_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
}

/** A connection to a list of `Portfolio` values, with data from `AssetTransaction`. */
export type AssetPortfoliosByAssetTransactionAssetIdAndFromPortfolioIdManyToManyConnection = {
  __typename?: 'AssetPortfoliosByAssetTransactionAssetIdAndFromPortfolioIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `AssetTransaction`, and the cursor to aid in pagination. */
  edges: Array<AssetPortfoliosByAssetTransactionAssetIdAndFromPortfolioIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `AssetTransaction`. */
export type AssetPortfoliosByAssetTransactionAssetIdAndFromPortfolioIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: InputMaybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `AssetTransaction`. */
export type AssetPortfoliosByAssetTransactionAssetIdAndFromPortfolioIdManyToManyEdge = {
  __typename?: 'AssetPortfoliosByAssetTransactionAssetIdAndFromPortfolioIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AssetTransaction`. */
  assetTransactionsByFromPortfolioId: AssetTransactionsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
};

/** A `Portfolio` edge in the connection, with data from `AssetTransaction`. */
export type AssetPortfoliosByAssetTransactionAssetIdAndFromPortfolioIdManyToManyEdgeAssetTransactionsByFromPortfolioIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AssetTransactionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AssetTransactionsOrderBy>>;
  };

/** A connection to a list of `Portfolio` values, with data from `AssetTransaction`. */
export type AssetPortfoliosByAssetTransactionAssetIdAndToPortfolioIdManyToManyConnection = {
  __typename?: 'AssetPortfoliosByAssetTransactionAssetIdAndToPortfolioIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `AssetTransaction`, and the cursor to aid in pagination. */
  edges: Array<AssetPortfoliosByAssetTransactionAssetIdAndToPortfolioIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `AssetTransaction`. */
export type AssetPortfoliosByAssetTransactionAssetIdAndToPortfolioIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: InputMaybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `AssetTransaction`. */
export type AssetPortfoliosByAssetTransactionAssetIdAndToPortfolioIdManyToManyEdge = {
  __typename?: 'AssetPortfoliosByAssetTransactionAssetIdAndToPortfolioIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AssetTransaction`. */
  assetTransactionsByToPortfolioId: AssetTransactionsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
};

/** A `Portfolio` edge in the connection, with data from `AssetTransaction`. */
export type AssetPortfoliosByAssetTransactionAssetIdAndToPortfolioIdManyToManyEdgeAssetTransactionsByToPortfolioIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AssetTransactionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AssetTransactionsOrderBy>>;
  };

/** A connection to a list of `Portfolio` values, with data from `Distribution`. */
export type AssetPortfoliosByDistributionAssetIdAndPortfolioIdManyToManyConnection = {
  __typename?: 'AssetPortfoliosByDistributionAssetIdAndPortfolioIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<AssetPortfoliosByDistributionAssetIdAndPortfolioIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `Distribution`. */
export type AssetPortfoliosByDistributionAssetIdAndPortfolioIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: InputMaybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `Distribution`. */
export type AssetPortfoliosByDistributionAssetIdAndPortfolioIdManyToManyEdge = {
  __typename?: 'AssetPortfoliosByDistributionAssetIdAndPortfolioIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributions: DistributionsConnection;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
};

/** A `Portfolio` edge in the connection, with data from `Distribution`. */
export type AssetPortfoliosByDistributionAssetIdAndPortfolioIdManyToManyEdgeDistributionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<DistributionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DistributionsOrderBy>>;
};

/** A connection to a list of `Portfolio` values, with data from `PortfolioMovement`. */
export type AssetPortfoliosByPortfolioMovementAssetIdAndFromIdManyToManyConnection = {
  __typename?: 'AssetPortfoliosByPortfolioMovementAssetIdAndFromIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<AssetPortfoliosByPortfolioMovementAssetIdAndFromIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `PortfolioMovement`. */
export type AssetPortfoliosByPortfolioMovementAssetIdAndFromIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: InputMaybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `PortfolioMovement`. */
export type AssetPortfoliosByPortfolioMovementAssetIdAndFromIdManyToManyEdge = {
  __typename?: 'AssetPortfoliosByPortfolioMovementAssetIdAndFromIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByFromId: PortfolioMovementsConnection;
};

/** A `Portfolio` edge in the connection, with data from `PortfolioMovement`. */
export type AssetPortfoliosByPortfolioMovementAssetIdAndFromIdManyToManyEdgePortfolioMovementsByFromIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<PortfolioMovementFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<PortfolioMovementsOrderBy>>;
  };

/** A connection to a list of `Portfolio` values, with data from `PortfolioMovement`. */
export type AssetPortfoliosByPortfolioMovementAssetIdAndToIdManyToManyConnection = {
  __typename?: 'AssetPortfoliosByPortfolioMovementAssetIdAndToIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<AssetPortfoliosByPortfolioMovementAssetIdAndToIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `PortfolioMovement`. */
export type AssetPortfoliosByPortfolioMovementAssetIdAndToIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: InputMaybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `PortfolioMovement`. */
export type AssetPortfoliosByPortfolioMovementAssetIdAndToIdManyToManyEdge = {
  __typename?: 'AssetPortfoliosByPortfolioMovementAssetIdAndToIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByToId: PortfolioMovementsConnection;
};

/** A `Portfolio` edge in the connection, with data from `PortfolioMovement`. */
export type AssetPortfoliosByPortfolioMovementAssetIdAndToIdManyToManyEdgePortfolioMovementsByToIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<PortfolioMovementFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<PortfolioMovementsOrderBy>>;
  };

/** A connection to a list of `Portfolio` values, with data from `Sto`. */
export type AssetPortfoliosByStoOfferingAssetIdAndOfferingPortfolioIdManyToManyConnection = {
  __typename?: 'AssetPortfoliosByStoOfferingAssetIdAndOfferingPortfolioIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<AssetPortfoliosByStoOfferingAssetIdAndOfferingPortfolioIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `Sto`. */
export type AssetPortfoliosByStoOfferingAssetIdAndOfferingPortfolioIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: InputMaybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `Sto`. */
export type AssetPortfoliosByStoOfferingAssetIdAndOfferingPortfolioIdManyToManyEdge = {
  __typename?: 'AssetPortfoliosByStoOfferingAssetIdAndOfferingPortfolioIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByOfferingPortfolioId: StosConnection;
};

/** A `Portfolio` edge in the connection, with data from `Sto`. */
export type AssetPortfoliosByStoOfferingAssetIdAndOfferingPortfolioIdManyToManyEdgeStosByOfferingPortfolioIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StoFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StosOrderBy>>;
  };

/** A connection to a list of `Portfolio` values, with data from `Sto`. */
export type AssetPortfoliosByStoOfferingAssetIdAndRaisingPortfolioIdManyToManyConnection = {
  __typename?: 'AssetPortfoliosByStoOfferingAssetIdAndRaisingPortfolioIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<AssetPortfoliosByStoOfferingAssetIdAndRaisingPortfolioIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `Sto`. */
export type AssetPortfoliosByStoOfferingAssetIdAndRaisingPortfolioIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: InputMaybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `Sto`. */
export type AssetPortfoliosByStoOfferingAssetIdAndRaisingPortfolioIdManyToManyEdge = {
  __typename?: 'AssetPortfoliosByStoOfferingAssetIdAndRaisingPortfolioIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByRaisingPortfolioId: StosConnection;
};

/** A `Portfolio` edge in the connection, with data from `Sto`. */
export type AssetPortfoliosByStoOfferingAssetIdAndRaisingPortfolioIdManyToManyEdgeStosByRaisingPortfolioIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StoFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StosOrderBy>>;
  };

/** A connection to a list of `StatType` values, with data from `TransferCompliance`. */
export type AssetStatTypesByTransferComplianceAssetIdAndStatTypeIdManyToManyConnection = {
  __typename?: 'AssetStatTypesByTransferComplianceAssetIdAndStatTypeIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<StatTypeAggregates>;
  /** A list of edges which contains the `StatType`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
  edges: Array<AssetStatTypesByTransferComplianceAssetIdAndStatTypeIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<StatTypeAggregates>>;
  /** A list of `StatType` objects. */
  nodes: Array<Maybe<StatType>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `StatType` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `StatType` values, with data from `TransferCompliance`. */
export type AssetStatTypesByTransferComplianceAssetIdAndStatTypeIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<StatTypesGroupBy>;
    having?: InputMaybe<StatTypesHavingInput>;
  };

/** A `StatType` edge in the connection, with data from `TransferCompliance`. */
export type AssetStatTypesByTransferComplianceAssetIdAndStatTypeIdManyToManyEdge = {
  __typename?: 'AssetStatTypesByTransferComplianceAssetIdAndStatTypeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `StatType` at the end of the edge. */
  node?: Maybe<StatType>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliances: TransferCompliancesConnection;
};

/** A `StatType` edge in the connection, with data from `TransferCompliance`. */
export type AssetStatTypesByTransferComplianceAssetIdAndStatTypeIdManyToManyEdgeTransferCompliancesArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TransferComplianceFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TransferCompliancesOrderBy>>;
  };

/** Represents all the transactions related to an Asset */
export type AssetTransaction = Node & {
  __typename?: 'AssetTransaction';
  amount: Scalars['BigFloat']['output'];
  /** Reads a single `Asset` that is related to this `AssetTransaction`. */
  asset?: Maybe<Asset>;
  assetId: Scalars['String']['output'];
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `AssetTransaction`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  datetime: Scalars['Datetime']['output'];
  eventId: EventIdEnum;
  eventIdx: Scalars['Int']['output'];
  /** `extrinsicIdx` will be null for scheduled transactions */
  extrinsicIdx?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `Portfolio` that is related to this `AssetTransaction`. */
  fromPortfolio?: Maybe<Portfolio>;
  /** `fromPortfolioId` will be null in transactions where the Asset was issued */
  fromPortfolioId?: Maybe<Scalars['String']['output']>;
  /** `fundingRound` will only be present for the cases where Assets are issued with a fundingRound name */
  fundingRound?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Portfolio` that is related to this `AssetTransaction`. */
  toPortfolio?: Maybe<Portfolio>;
  /** `toPortfolioId` will be null in transactions where the Asset was redeemed */
  toPortfolioId?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `AssetTransaction`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
};

export type AssetTransactionAggregates = {
  __typename?: 'AssetTransactionAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A filter to be used against `AssetTransaction` object types. All fields are combined with a logical ‘and.’ */
export type AssetTransactionFilter = {
  /** Filter by the object’s `amount` field. */
  amount?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AssetTransactionFilter>>;
  /** Filter by the object’s `assetId` field. */
  assetId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `datetime` field. */
  datetime?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `eventId` field. */
  eventId?: InputMaybe<EventIdEnumFilter>;
  /** Filter by the object’s `eventIdx` field. */
  eventIdx?: InputMaybe<IntFilter>;
  /** Filter by the object’s `extrinsicIdx` field. */
  extrinsicIdx?: InputMaybe<IntFilter>;
  /** Filter by the object’s `fromPortfolioId` field. */
  fromPortfolioId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `fundingRound` field. */
  fundingRound?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AssetTransactionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AssetTransactionFilter>>;
  /** Filter by the object’s `toPortfolioId` field. */
  toPortfolioId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
};

/** A connection to a list of `AssetTransaction` values. */
export type AssetTransactionsConnection = {
  __typename?: 'AssetTransactionsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetTransactionAggregates>;
  /** A list of edges which contains the `AssetTransaction` and cursor to aid in pagination. */
  edges: Array<AssetTransactionsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetTransactionAggregates>>;
  /** A list of `AssetTransaction` objects. */
  nodes: Array<Maybe<AssetTransaction>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AssetTransaction` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `AssetTransaction` values. */
export type AssetTransactionsConnectionGroupedAggregatesArgs = {
  groupBy: Array<AssetTransactionsGroupBy>;
  having?: InputMaybe<AssetTransactionsHavingInput>;
};

/** A `AssetTransaction` edge in the connection. */
export type AssetTransactionsEdge = {
  __typename?: 'AssetTransactionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AssetTransaction` at the end of the edge. */
  node?: Maybe<AssetTransaction>;
};

/** Grouping methods for `AssetTransaction` for usage during aggregation. */
export enum AssetTransactionsGroupBy {
  Amount = 'AMOUNT',
  AssetId = 'ASSET_ID',
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  Datetime = 'DATETIME',
  EventId = 'EVENT_ID',
  EventIdx = 'EVENT_IDX',
  ExtrinsicIdx = 'EXTRINSIC_IDX',
  FromPortfolioId = 'FROM_PORTFOLIO_ID',
  FundingRound = 'FUNDING_ROUND',
  ToPortfolioId = 'TO_PORTFOLIO_ID',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
}

/** Conditions for `AssetTransaction` aggregates. */
export type AssetTransactionsHavingInput = {
  AND?: InputMaybe<Array<AssetTransactionsHavingInput>>;
  OR?: InputMaybe<Array<AssetTransactionsHavingInput>>;
};

/** Methods to use when ordering `AssetTransaction`. */
export enum AssetTransactionsOrderBy {
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  AssetIdAsc = 'ASSET_ID_ASC',
  AssetIdDesc = 'ASSET_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  DatetimeAsc = 'DATETIME_ASC',
  DatetimeDesc = 'DATETIME_DESC',
  EventIdxAsc = 'EVENT_IDX_ASC',
  EventIdxDesc = 'EVENT_IDX_DESC',
  EventIdAsc = 'EVENT_ID_ASC',
  EventIdDesc = 'EVENT_ID_DESC',
  ExtrinsicIdxAsc = 'EXTRINSIC_IDX_ASC',
  ExtrinsicIdxDesc = 'EXTRINSIC_IDX_DESC',
  FromPortfolioIdAsc = 'FROM_PORTFOLIO_ID_ASC',
  FromPortfolioIdDesc = 'FROM_PORTFOLIO_ID_DESC',
  FundingRoundAsc = 'FUNDING_ROUND_ASC',
  FundingRoundDesc = 'FUNDING_ROUND_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ToPortfolioIdAsc = 'TO_PORTFOLIO_ID_ASC',
  ToPortfolioIdDesc = 'TO_PORTFOLIO_ID_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
}

/** A connection to a list of `Venue` values, with data from `Sto`. */
export type AssetVenuesByStoOfferingAssetIdAndVenueIdManyToManyConnection = {
  __typename?: 'AssetVenuesByStoOfferingAssetIdAndVenueIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<VenueAggregates>;
  /** A list of edges which contains the `Venue`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<AssetVenuesByStoOfferingAssetIdAndVenueIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<VenueAggregates>>;
  /** A list of `Venue` objects. */
  nodes: Array<Maybe<Venue>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Venue` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Venue` values, with data from `Sto`. */
export type AssetVenuesByStoOfferingAssetIdAndVenueIdManyToManyConnectionGroupedAggregatesArgs = {
  groupBy: Array<VenuesGroupBy>;
  having?: InputMaybe<VenuesHavingInput>;
};

/** A `Venue` edge in the connection, with data from `Sto`. */
export type AssetVenuesByStoOfferingAssetIdAndVenueIdManyToManyEdge = {
  __typename?: 'AssetVenuesByStoOfferingAssetIdAndVenueIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Venue` at the end of the edge. */
  node?: Maybe<Venue>;
  /** Reads and enables pagination through a set of `Sto`. */
  stos: StosConnection;
};

/** A `Venue` edge in the connection, with data from `Sto`. */
export type AssetVenuesByStoOfferingAssetIdAndVenueIdManyToManyEdgeStosArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StoFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StosOrderBy>>;
};

/** A connection to a list of `Asset` values. */
export type AssetsConnection = {
  __typename?: 'AssetsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset` and cursor to aid in pagination. */
  edges: Array<AssetsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values. */
export type AssetsConnectionGroupedAggregatesArgs = {
  groupBy: Array<AssetsGroupBy>;
  having?: InputMaybe<AssetsHavingInput>;
};

/** A `Asset` edge in the connection. */
export type AssetsEdge = {
  __typename?: 'AssetsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
};

/** Grouping methods for `Asset` for usage during aggregation. */
export enum AssetsGroupBy {
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  EventIdx = 'EVENT_IDX',
  FundingRound = 'FUNDING_ROUND',
  Identifiers = 'IDENTIFIERS',
  IsCompliancePaused = 'IS_COMPLIANCE_PAUSED',
  IsDivisible = 'IS_DIVISIBLE',
  IsFrozen = 'IS_FROZEN',
  IsUniquenessRequired = 'IS_UNIQUENESS_REQUIRED',
  Name = 'NAME',
  OwnerId = 'OWNER_ID',
  TotalSupply = 'TOTAL_SUPPLY',
  TotalTransfers = 'TOTAL_TRANSFERS',
  Type = 'TYPE',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
}

/** Conditions for `Asset` aggregates. */
export type AssetsHavingInput = {
  AND?: InputMaybe<Array<AssetsHavingInput>>;
  OR?: InputMaybe<Array<AssetsHavingInput>>;
};

/** Methods to use when ordering `Asset`. */
export enum AssetsOrderBy {
  AssetTransactionsCountAsc = 'ASSET_TRANSACTIONS_COUNT_ASC',
  AssetTransactionsCountDesc = 'ASSET_TRANSACTIONS_COUNT_DESC',
  ComplianceCountAsc = 'COMPLIANCE_COUNT_ASC',
  ComplianceCountDesc = 'COMPLIANCE_COUNT_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  DistributionsCountAsc = 'DISTRIBUTIONS_COUNT_ASC',
  DistributionsCountDesc = 'DISTRIBUTIONS_COUNT_DESC',
  DocumentsCountAsc = 'DOCUMENTS_COUNT_ASC',
  DocumentsCountDesc = 'DOCUMENTS_COUNT_DESC',
  EventIdxAsc = 'EVENT_IDX_ASC',
  EventIdxDesc = 'EVENT_IDX_DESC',
  FundingsCountAsc = 'FUNDINGS_COUNT_ASC',
  FundingsCountDesc = 'FUNDINGS_COUNT_DESC',
  FundingRoundAsc = 'FUNDING_ROUND_ASC',
  FundingRoundDesc = 'FUNDING_ROUND_DESC',
  HoldersCountAsc = 'HOLDERS_COUNT_ASC',
  HoldersCountDesc = 'HOLDERS_COUNT_DESC',
  IdentifiersAsc = 'IDENTIFIERS_ASC',
  IdentifiersDesc = 'IDENTIFIERS_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsCompliancePausedAsc = 'IS_COMPLIANCE_PAUSED_ASC',
  IsCompliancePausedDesc = 'IS_COMPLIANCE_PAUSED_DESC',
  IsDivisibleAsc = 'IS_DIVISIBLE_ASC',
  IsDivisibleDesc = 'IS_DIVISIBLE_DESC',
  IsFrozenAsc = 'IS_FROZEN_ASC',
  IsFrozenDesc = 'IS_FROZEN_DESC',
  IsUniquenessRequiredAsc = 'IS_UNIQUENESS_REQUIRED_ASC',
  IsUniquenessRequiredDesc = 'IS_UNIQUENESS_REQUIRED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PortfolioMovementsCountAsc = 'PORTFOLIO_MOVEMENTS_COUNT_ASC',
  PortfolioMovementsCountDesc = 'PORTFOLIO_MOVEMENTS_COUNT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  StatTypesCountAsc = 'STAT_TYPES_COUNT_ASC',
  StatTypesCountDesc = 'STAT_TYPES_COUNT_DESC',
  StosByOfferingAssetIdCountAsc = 'STOS_BY_OFFERING_ASSET_ID_COUNT_ASC',
  StosByOfferingAssetIdCountDesc = 'STOS_BY_OFFERING_ASSET_ID_COUNT_DESC',
  TickerAsc = 'TICKER_ASC',
  TickerDesc = 'TICKER_DESC',
  TickerExternalAgentsCountAsc = 'TICKER_EXTERNAL_AGENTS_COUNT_ASC',
  TickerExternalAgentsCountDesc = 'TICKER_EXTERNAL_AGENTS_COUNT_DESC',
  TickerExternalAgentActionsCountAsc = 'TICKER_EXTERNAL_AGENT_ACTIONS_COUNT_ASC',
  TickerExternalAgentActionsCountDesc = 'TICKER_EXTERNAL_AGENT_ACTIONS_COUNT_DESC',
  TickerExternalAgentHistoriesCountAsc = 'TICKER_EXTERNAL_AGENT_HISTORIES_COUNT_ASC',
  TickerExternalAgentHistoriesCountDesc = 'TICKER_EXTERNAL_AGENT_HISTORIES_COUNT_DESC',
  TotalSupplyAsc = 'TOTAL_SUPPLY_ASC',
  TotalSupplyDesc = 'TOTAL_SUPPLY_DESC',
  TotalTransfersAsc = 'TOTAL_TRANSFERS_ASC',
  TotalTransfersDesc = 'TOTAL_TRANSFERS_DESC',
  TransferCompliancesCountAsc = 'TRANSFER_COMPLIANCES_COUNT_ASC',
  TransferCompliancesCountDesc = 'TRANSFER_COMPLIANCES_COUNT_DESC',
  TransferComplianceExemptionsCountAsc = 'TRANSFER_COMPLIANCE_EXEMPTIONS_COUNT_ASC',
  TransferComplianceExemptionsCountDesc = 'TRANSFER_COMPLIANCE_EXEMPTIONS_COUNT_DESC',
  TransferManagersCountAsc = 'TRANSFER_MANAGERS_COUNT_ASC',
  TransferManagersCountDesc = 'TRANSFER_MANAGERS_COUNT_DESC',
  TrustedClaimIssuersCountAsc = 'TRUSTED_CLAIM_ISSUERS_COUNT_ASC',
  TrustedClaimIssuersCountDesc = 'TRUSTED_CLAIM_ISSUERS_COUNT_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
}

/**  Represents all possible authorization types */
export enum AuthTypeEnum {
  AddMultiSigSigner = 'AddMultiSigSigner',
  AddRelayerPayingKey = 'AddRelayerPayingKey',
  AttestPrimaryKeyRotation = 'AttestPrimaryKeyRotation',
  BecomeAgent = 'BecomeAgent',
  Custom = 'Custom',
  JoinIdentity = 'JoinIdentity',
  NoData = 'NoData',
  PortfolioCustody = 'PortfolioCustody',
  RotatePrimaryKey = 'RotatePrimaryKey',
  RotatePrimaryKeyToSecondary = 'RotatePrimaryKeyToSecondary',
  TransferAssetOwnership = 'TransferAssetOwnership',
  TransferPrimaryIssuanceAgent = 'TransferPrimaryIssuanceAgent',
  TransferTicker = 'TransferTicker',
}

/** A filter to be used against AuthTypeEnum fields. All fields are combined with a logical ‘and.’ */
export type AuthTypeEnumFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<AuthTypeEnum>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<AuthTypeEnum>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<AuthTypeEnum>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<AuthTypeEnum>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<AuthTypeEnum>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<AuthTypeEnum>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<AuthTypeEnum>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<AuthTypeEnum>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<AuthTypeEnum>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<AuthTypeEnum>>;
};

/** Represents a request to grant an Account some permission to perform actions for an Identity. e.g. become a Portfolio custodian */
export type Authorization = Node & {
  __typename?: 'Authorization';
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `Authorization`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  data?: Maybe<Scalars['String']['output']>;
  expiry?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `Identity` that is related to this `Authorization`. */
  from?: Maybe<Identity>;
  fromId: Scalars['String']['output'];
  id: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  status: AuthorizationStatusEnum;
  toId?: Maybe<Scalars['String']['output']>;
  toKey?: Maybe<Scalars['String']['output']>;
  type: AuthTypeEnum;
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `Authorization`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
};

export type AuthorizationAggregates = {
  __typename?: 'AuthorizationAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A filter to be used against `Authorization` object types. All fields are combined with a logical ‘and.’ */
export type AuthorizationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AuthorizationFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `data` field. */
  data?: InputMaybe<StringFilter>;
  /** Filter by the object’s `expiry` field. */
  expiry?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `fromId` field. */
  fromId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AuthorizationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AuthorizationFilter>>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<AuthorizationStatusEnumFilter>;
  /** Filter by the object’s `toId` field. */
  toId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `toKey` field. */
  toKey?: InputMaybe<StringFilter>;
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<AuthTypeEnumFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
};

/**  Represents all possible authorization statuses */
export enum AuthorizationStatusEnum {
  Consumed = 'Consumed',
  Pending = 'Pending',
  Rejected = 'Rejected',
  Revoked = 'Revoked',
}

/** A filter to be used against AuthorizationStatusEnum fields. All fields are combined with a logical ‘and.’ */
export type AuthorizationStatusEnumFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<AuthorizationStatusEnum>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<AuthorizationStatusEnum>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<AuthorizationStatusEnum>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<AuthorizationStatusEnum>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<AuthorizationStatusEnum>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<AuthorizationStatusEnum>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<AuthorizationStatusEnum>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<AuthorizationStatusEnum>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<AuthorizationStatusEnum>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<AuthorizationStatusEnum>>;
};

/** A connection to a list of `Authorization` values. */
export type AuthorizationsConnection = {
  __typename?: 'AuthorizationsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AuthorizationAggregates>;
  /** A list of edges which contains the `Authorization` and cursor to aid in pagination. */
  edges: Array<AuthorizationsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AuthorizationAggregates>>;
  /** A list of `Authorization` objects. */
  nodes: Array<Maybe<Authorization>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Authorization` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Authorization` values. */
export type AuthorizationsConnectionGroupedAggregatesArgs = {
  groupBy: Array<AuthorizationsGroupBy>;
  having?: InputMaybe<AuthorizationsHavingInput>;
};

/** A `Authorization` edge in the connection. */
export type AuthorizationsEdge = {
  __typename?: 'AuthorizationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Authorization` at the end of the edge. */
  node?: Maybe<Authorization>;
};

/** Grouping methods for `Authorization` for usage during aggregation. */
export enum AuthorizationsGroupBy {
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  Data = 'DATA',
  Expiry = 'EXPIRY',
  FromId = 'FROM_ID',
  Status = 'STATUS',
  ToId = 'TO_ID',
  ToKey = 'TO_KEY',
  Type = 'TYPE',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
}

/** Conditions for `Authorization` aggregates. */
export type AuthorizationsHavingInput = {
  AND?: InputMaybe<Array<AuthorizationsHavingInput>>;
  OR?: InputMaybe<Array<AuthorizationsHavingInput>>;
};

/** Methods to use when ordering `Authorization`. */
export enum AuthorizationsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  DataAsc = 'DATA_ASC',
  DataDesc = 'DATA_DESC',
  ExpiryAsc = 'EXPIRY_ASC',
  ExpiryDesc = 'EXPIRY_DESC',
  FromIdAsc = 'FROM_ID_ASC',
  FromIdDesc = 'FROM_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  ToIdAsc = 'TO_ID_ASC',
  ToIdDesc = 'TO_ID_DESC',
  ToKeyAsc = 'TO_KEY_ASC',
  ToKeyDesc = 'TO_KEY_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
}

/**  Represents possible all possible balance types */
export enum BalanceTypeEnum {
  Bonded = 'Bonded',
  Free = 'Free',
  Locked = 'Locked',
  Reserved = 'Reserved',
  Unbonded = 'Unbonded',
}

/** A filter to be used against BalanceTypeEnum fields. All fields are combined with a logical ‘and.’ */
export type BalanceTypeEnumFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<BalanceTypeEnum>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<BalanceTypeEnum>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<BalanceTypeEnum>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<BalanceTypeEnum>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<BalanceTypeEnum>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<BalanceTypeEnum>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<BalanceTypeEnum>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<BalanceTypeEnum>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<BalanceTypeEnum>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<BalanceTypeEnum>>;
};

/** A filter to be used against BigFloat fields. All fields are combined with a logical ‘and.’ */
export type BigFloatFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['BigFloat']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['BigFloat']['input']>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type Block = Node & {
  __typename?: 'Block';
  /** Reads and enables pagination through a set of `AccountHistory`. */
  accountHistoriesByCreatedBlockId: AccountHistoriesConnection;
  /** Reads and enables pagination through a set of `AccountHistory`. */
  accountHistoriesByUpdatedBlockId: AccountHistoriesConnection;
  /** Reads and enables pagination through a set of `Account`. */
  accountsByCreatedBlockId: AccountsConnection;
  /** Reads and enables pagination through a set of `Account`. */
  accountsByUpdatedBlockId: AccountsConnection;
  /** Reads and enables pagination through a set of `AgentGroupMembership`. */
  agentGroupMembershipsByCreatedBlockId: AgentGroupMembershipsConnection;
  /** Reads and enables pagination through a set of `AgentGroupMembership`. */
  agentGroupMembershipsByUpdatedBlockId: AgentGroupMembershipsConnection;
  /** Reads and enables pagination through a set of `AgentGroup`. */
  agentGroupsByAgentGroupMembershipCreatedBlockIdAndGroupId: BlockAgentGroupsByAgentGroupMembershipCreatedBlockIdAndGroupIdManyToManyConnection;
  /** Reads and enables pagination through a set of `AgentGroup`. */
  agentGroupsByAgentGroupMembershipUpdatedBlockIdAndGroupId: BlockAgentGroupsByAgentGroupMembershipUpdatedBlockIdAndGroupIdManyToManyConnection;
  /** Reads and enables pagination through a set of `AgentGroup`. */
  agentGroupsByCreatedBlockId: AgentGroupsConnection;
  /** Reads and enables pagination through a set of `AgentGroup`. */
  agentGroupsByUpdatedBlockId: AgentGroupsConnection;
  /** Reads and enables pagination through a set of `AssetDocument`. */
  assetDocumentsByCreatedBlockId: AssetDocumentsConnection;
  /** Reads and enables pagination through a set of `AssetDocument`. */
  assetDocumentsByUpdatedBlockId: AssetDocumentsConnection;
  /** Reads and enables pagination through a set of `AssetHolder`. */
  assetHoldersByCreatedBlockId: AssetHoldersConnection;
  /** Reads and enables pagination through a set of `AssetHolder`. */
  assetHoldersByUpdatedBlockId: AssetHoldersConnection;
  /** Reads and enables pagination through a set of `AssetPendingOwnershipTransfer`. */
  assetPendingOwnershipTransfersByCreatedBlockId: AssetPendingOwnershipTransfersConnection;
  /** Reads and enables pagination through a set of `AssetPendingOwnershipTransfer`. */
  assetPendingOwnershipTransfersByUpdatedBlockId: AssetPendingOwnershipTransfersConnection;
  /** Reads and enables pagination through a set of `AssetTransaction`. */
  assetTransactionsByCreatedBlockId: AssetTransactionsConnection;
  /** Reads and enables pagination through a set of `AssetTransaction`. */
  assetTransactionsByUpdatedBlockId: AssetTransactionsConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByAssetDocumentCreatedBlockIdAndAssetId: BlockAssetsByAssetDocumentCreatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByAssetDocumentUpdatedBlockIdAndAssetId: BlockAssetsByAssetDocumentUpdatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByAssetHolderCreatedBlockIdAndAssetId: BlockAssetsByAssetHolderCreatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByAssetHolderUpdatedBlockIdAndAssetId: BlockAssetsByAssetHolderUpdatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByAssetTransactionCreatedBlockIdAndAssetId: BlockAssetsByAssetTransactionCreatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByAssetTransactionUpdatedBlockIdAndAssetId: BlockAssetsByAssetTransactionUpdatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByComplianceCreatedBlockIdAndAssetId: BlockAssetsByComplianceCreatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByComplianceUpdatedBlockIdAndAssetId: BlockAssetsByComplianceUpdatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByCreatedBlockId: AssetsConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByDistributionCreatedBlockIdAndAssetId: BlockAssetsByDistributionCreatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByDistributionUpdatedBlockIdAndAssetId: BlockAssetsByDistributionUpdatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByFundingCreatedBlockIdAndAssetId: BlockAssetsByFundingCreatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByFundingUpdatedBlockIdAndAssetId: BlockAssetsByFundingUpdatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByPortfolioMovementCreatedBlockIdAndAssetId: BlockAssetsByPortfolioMovementCreatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByPortfolioMovementUpdatedBlockIdAndAssetId: BlockAssetsByPortfolioMovementUpdatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByStatTypeCreatedBlockIdAndAssetId: BlockAssetsByStatTypeCreatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByStatTypeUpdatedBlockIdAndAssetId: BlockAssetsByStatTypeUpdatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByStoCreatedBlockIdAndOfferingAssetId: BlockAssetsByStoCreatedBlockIdAndOfferingAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByStoUpdatedBlockIdAndOfferingAssetId: BlockAssetsByStoUpdatedBlockIdAndOfferingAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTickerExternalAgentActionCreatedBlockIdAndAssetId: BlockAssetsByTickerExternalAgentActionCreatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTickerExternalAgentActionUpdatedBlockIdAndAssetId: BlockAssetsByTickerExternalAgentActionUpdatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTickerExternalAgentCreatedBlockIdAndAssetId: BlockAssetsByTickerExternalAgentCreatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTickerExternalAgentHistoryCreatedBlockIdAndAssetId: BlockAssetsByTickerExternalAgentHistoryCreatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTickerExternalAgentHistoryUpdatedBlockIdAndAssetId: BlockAssetsByTickerExternalAgentHistoryUpdatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTickerExternalAgentUpdatedBlockIdAndAssetId: BlockAssetsByTickerExternalAgentUpdatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTransferComplianceCreatedBlockIdAndAssetId: BlockAssetsByTransferComplianceCreatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTransferComplianceExemptionCreatedBlockIdAndAssetId: BlockAssetsByTransferComplianceExemptionCreatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTransferComplianceExemptionUpdatedBlockIdAndAssetId: BlockAssetsByTransferComplianceExemptionUpdatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTransferComplianceUpdatedBlockIdAndAssetId: BlockAssetsByTransferComplianceUpdatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTransferManagerCreatedBlockIdAndAssetId: BlockAssetsByTransferManagerCreatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTransferManagerUpdatedBlockIdAndAssetId: BlockAssetsByTransferManagerUpdatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTrustedClaimIssuerCreatedBlockIdAndAssetId: BlockAssetsByTrustedClaimIssuerCreatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTrustedClaimIssuerUpdatedBlockIdAndAssetId: BlockAssetsByTrustedClaimIssuerUpdatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByUpdatedBlockId: AssetsConnection;
  /** Reads and enables pagination through a set of `Authorization`. */
  authorizationsByCreatedBlockId: AuthorizationsConnection;
  /** Reads and enables pagination through a set of `Authorization`. */
  authorizationsByUpdatedBlockId: AuthorizationsConnection;
  blockId: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAccountCreatedBlockIdAndUpdatedBlockId: BlockBlocksByAccountCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAccountHistoryCreatedBlockIdAndUpdatedBlockId: BlockBlocksByAccountHistoryCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAccountHistoryUpdatedBlockIdAndCreatedBlockId: BlockBlocksByAccountHistoryUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAccountUpdatedBlockIdAndCreatedBlockId: BlockBlocksByAccountUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAgentGroupCreatedBlockIdAndUpdatedBlockId: BlockBlocksByAgentGroupCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAgentGroupMembershipCreatedBlockIdAndUpdatedBlockId: BlockBlocksByAgentGroupMembershipCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAgentGroupMembershipUpdatedBlockIdAndCreatedBlockId: BlockBlocksByAgentGroupMembershipUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAgentGroupUpdatedBlockIdAndCreatedBlockId: BlockBlocksByAgentGroupUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetCreatedBlockIdAndUpdatedBlockId: BlockBlocksByAssetCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetDocumentCreatedBlockIdAndUpdatedBlockId: BlockBlocksByAssetDocumentCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetDocumentUpdatedBlockIdAndCreatedBlockId: BlockBlocksByAssetDocumentUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetHolderCreatedBlockIdAndUpdatedBlockId: BlockBlocksByAssetHolderCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetHolderUpdatedBlockIdAndCreatedBlockId: BlockBlocksByAssetHolderUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetPendingOwnershipTransferCreatedBlockIdAndUpdatedBlockId: BlockBlocksByAssetPendingOwnershipTransferCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetPendingOwnershipTransferUpdatedBlockIdAndCreatedBlockId: BlockBlocksByAssetPendingOwnershipTransferUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetTransactionCreatedBlockIdAndUpdatedBlockId: BlockBlocksByAssetTransactionCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetTransactionUpdatedBlockIdAndCreatedBlockId: BlockBlocksByAssetTransactionUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetUpdatedBlockIdAndCreatedBlockId: BlockBlocksByAssetUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAuthorizationCreatedBlockIdAndUpdatedBlockId: BlockBlocksByAuthorizationCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAuthorizationUpdatedBlockIdAndCreatedBlockId: BlockBlocksByAuthorizationUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByBridgeEventCreatedBlockIdAndUpdatedBlockId: BlockBlocksByBridgeEventCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByBridgeEventUpdatedBlockIdAndCreatedBlockId: BlockBlocksByBridgeEventUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByChildIdentityCreatedBlockIdAndUpdatedBlockId: BlockBlocksByChildIdentityCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByChildIdentityUpdatedBlockIdAndCreatedBlockId: BlockBlocksByChildIdentityUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByClaimCreatedBlockIdAndUpdatedBlockId: BlockBlocksByClaimCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByClaimScopeCreatedBlockIdAndUpdatedBlockId: BlockBlocksByClaimScopeCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByClaimScopeUpdatedBlockIdAndCreatedBlockId: BlockBlocksByClaimScopeUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByClaimUpdatedBlockIdAndCreatedBlockId: BlockBlocksByClaimUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByComplianceCreatedBlockIdAndUpdatedBlockId: BlockBlocksByComplianceCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByComplianceUpdatedBlockIdAndCreatedBlockId: BlockBlocksByComplianceUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByDistributionCreatedBlockIdAndUpdatedBlockId: BlockBlocksByDistributionCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByDistributionPaymentCreatedBlockIdAndUpdatedBlockId: BlockBlocksByDistributionPaymentCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByDistributionPaymentUpdatedBlockIdAndCreatedBlockId: BlockBlocksByDistributionPaymentUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByDistributionUpdatedBlockIdAndCreatedBlockId: BlockBlocksByDistributionUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByFundingCreatedBlockIdAndUpdatedBlockId: BlockBlocksByFundingCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByFundingUpdatedBlockIdAndCreatedBlockId: BlockBlocksByFundingUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByIdentityCreatedBlockIdAndUpdatedBlockId: BlockBlocksByIdentityCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByIdentityUpdatedBlockIdAndCreatedBlockId: BlockBlocksByIdentityUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByInstructionCreatedBlockIdAndUpdatedBlockId: BlockBlocksByInstructionCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByInstructionUpdatedBlockIdAndCreatedBlockId: BlockBlocksByInstructionUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByInvestmentCreatedBlockIdAndUpdatedBlockId: BlockBlocksByInvestmentCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByInvestmentUpdatedBlockIdAndCreatedBlockId: BlockBlocksByInvestmentUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByLegCreatedBlockIdAndUpdatedBlockId: BlockBlocksByLegCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByLegUpdatedBlockIdAndCreatedBlockId: BlockBlocksByLegUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByPermissionCreatedBlockIdAndUpdatedBlockId: BlockBlocksByPermissionCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByPermissionUpdatedBlockIdAndCreatedBlockId: BlockBlocksByPermissionUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByPolyxTransactionCreatedBlockIdAndUpdatedBlockId: BlockBlocksByPolyxTransactionCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByPolyxTransactionUpdatedBlockIdAndCreatedBlockId: BlockBlocksByPolyxTransactionUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByPortfolioCreatedBlockIdAndUpdatedBlockId: BlockBlocksByPortfolioCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByPortfolioMovementCreatedBlockIdAndUpdatedBlockId: BlockBlocksByPortfolioMovementCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByPortfolioMovementUpdatedBlockIdAndCreatedBlockId: BlockBlocksByPortfolioMovementUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByPortfolioUpdatedBlockIdAndCreatedBlockId: BlockBlocksByPortfolioUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByProposalCreatedBlockIdAndUpdatedBlockId: BlockBlocksByProposalCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByProposalUpdatedBlockIdAndCreatedBlockId: BlockBlocksByProposalUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByProposalVoteCreatedBlockIdAndUpdatedBlockId: BlockBlocksByProposalVoteCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByProposalVoteUpdatedBlockIdAndCreatedBlockId: BlockBlocksByProposalVoteUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksBySettlementCreatedBlockIdAndUpdatedBlockId: BlockBlocksBySettlementCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksBySettlementUpdatedBlockIdAndCreatedBlockId: BlockBlocksBySettlementUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByStakingEventCreatedBlockIdAndUpdatedBlockId: BlockBlocksByStakingEventCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByStakingEventUpdatedBlockIdAndCreatedBlockId: BlockBlocksByStakingEventUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByStatTypeCreatedBlockIdAndUpdatedBlockId: BlockBlocksByStatTypeCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByStatTypeUpdatedBlockIdAndCreatedBlockId: BlockBlocksByStatTypeUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByStoCreatedBlockIdAndUpdatedBlockId: BlockBlocksByStoCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByStoUpdatedBlockIdAndCreatedBlockId: BlockBlocksByStoUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTickerExternalAgentActionCreatedBlockIdAndUpdatedBlockId: BlockBlocksByTickerExternalAgentActionCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTickerExternalAgentActionUpdatedBlockIdAndCreatedBlockId: BlockBlocksByTickerExternalAgentActionUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTickerExternalAgentCreatedBlockIdAndUpdatedBlockId: BlockBlocksByTickerExternalAgentCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTickerExternalAgentHistoryCreatedBlockIdAndUpdatedBlockId: BlockBlocksByTickerExternalAgentHistoryCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTickerExternalAgentHistoryUpdatedBlockIdAndCreatedBlockId: BlockBlocksByTickerExternalAgentHistoryUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTickerExternalAgentUpdatedBlockIdAndCreatedBlockId: BlockBlocksByTickerExternalAgentUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTransferComplianceCreatedBlockIdAndUpdatedBlockId: BlockBlocksByTransferComplianceCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTransferComplianceExemptionCreatedBlockIdAndUpdatedBlockId: BlockBlocksByTransferComplianceExemptionCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTransferComplianceExemptionUpdatedBlockIdAndCreatedBlockId: BlockBlocksByTransferComplianceExemptionUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTransferComplianceUpdatedBlockIdAndCreatedBlockId: BlockBlocksByTransferComplianceUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTransferManagerCreatedBlockIdAndUpdatedBlockId: BlockBlocksByTransferManagerCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTransferManagerUpdatedBlockIdAndCreatedBlockId: BlockBlocksByTransferManagerUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTrustedClaimIssuerCreatedBlockIdAndUpdatedBlockId: BlockBlocksByTrustedClaimIssuerCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTrustedClaimIssuerUpdatedBlockIdAndCreatedBlockId: BlockBlocksByTrustedClaimIssuerUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByVenueCreatedBlockIdAndUpdatedBlockId: BlockBlocksByVenueCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByVenueUpdatedBlockIdAndCreatedBlockId: BlockBlocksByVenueUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `BridgeEvent`. */
  bridgeEventsByCreatedBlockId: BridgeEventsConnection;
  /** Reads and enables pagination through a set of `BridgeEvent`. */
  bridgeEventsByUpdatedBlockId: BridgeEventsConnection;
  /** Reads and enables pagination through a set of `ChildIdentity`. */
  childIdentitiesByCreatedBlockId: ChildIdentitiesConnection;
  /** Reads and enables pagination through a set of `ChildIdentity`. */
  childIdentitiesByUpdatedBlockId: ChildIdentitiesConnection;
  /** Reads and enables pagination through a set of `ClaimScope`. */
  claimScopesByCreatedBlockId: ClaimScopesConnection;
  /** Reads and enables pagination through a set of `ClaimScope`. */
  claimScopesByUpdatedBlockId: ClaimScopesConnection;
  /** Reads and enables pagination through a set of `Claim`. */
  claimsByCreatedBlockId: ClaimsConnection;
  /** Reads and enables pagination through a set of `Claim`. */
  claimsByUpdatedBlockId: ClaimsConnection;
  /** Reads and enables pagination through a set of `Compliance`. */
  compliancesByCreatedBlockId: CompliancesConnection;
  /** Reads and enables pagination through a set of `Compliance`. */
  compliancesByUpdatedBlockId: CompliancesConnection;
  countEvents: Scalars['Int']['output'];
  countExtrinsics: Scalars['Int']['output'];
  countExtrinsicsError: Scalars['Int']['output'];
  countExtrinsicsSigned: Scalars['Int']['output'];
  countExtrinsicsSuccess: Scalars['Int']['output'];
  countExtrinsicsUnsigned: Scalars['Int']['output'];
  createdAt: Scalars['Datetime']['output'];
  datetime: Scalars['Datetime']['output'];
  /** Reads and enables pagination through a set of `DistributionPayment`. */
  distributionPaymentsByCreatedBlockId: DistributionPaymentsConnection;
  /** Reads and enables pagination through a set of `DistributionPayment`. */
  distributionPaymentsByUpdatedBlockId: DistributionPaymentsConnection;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributionsByCreatedBlockId: DistributionsConnection;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributionsByDistributionPaymentCreatedBlockIdAndDistributionId: BlockDistributionsByDistributionPaymentCreatedBlockIdAndDistributionIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributionsByDistributionPaymentUpdatedBlockIdAndDistributionId: BlockDistributionsByDistributionPaymentUpdatedBlockIdAndDistributionIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributionsByUpdatedBlockId: DistributionsConnection;
  /** Reads and enables pagination through a set of `Event`. */
  events: EventsConnection;
  /** Reads and enables pagination through a set of `Extrinsic`. */
  extrinsics: ExtrinsicsConnection;
  /** Reads and enables pagination through a set of `Extrinsic`. */
  extrinsicsByPolyxTransactionCreatedBlockIdAndExtrinsicId: BlockExtrinsicsByPolyxTransactionCreatedBlockIdAndExtrinsicIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Extrinsic`. */
  extrinsicsByPolyxTransactionUpdatedBlockIdAndExtrinsicId: BlockExtrinsicsByPolyxTransactionUpdatedBlockIdAndExtrinsicIdManyToManyConnection;
  extrinsicsRoot: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `Funding`. */
  fundingsByCreatedBlockId: FundingsConnection;
  /** Reads and enables pagination through a set of `Funding`. */
  fundingsByUpdatedBlockId: FundingsConnection;
  hash: Scalars['String']['output'];
  id: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByAccountCreatedBlockIdAndIdentityId: BlockIdentitiesByAccountCreatedBlockIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByAccountUpdatedBlockIdAndIdentityId: BlockIdentitiesByAccountUpdatedBlockIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByAssetCreatedBlockIdAndOwnerId: BlockIdentitiesByAssetCreatedBlockIdAndOwnerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByAssetHolderCreatedBlockIdAndIdentityId: BlockIdentitiesByAssetHolderCreatedBlockIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByAssetHolderUpdatedBlockIdAndIdentityId: BlockIdentitiesByAssetHolderUpdatedBlockIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByAssetUpdatedBlockIdAndOwnerId: BlockIdentitiesByAssetUpdatedBlockIdAndOwnerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByAuthorizationCreatedBlockIdAndFromId: BlockIdentitiesByAuthorizationCreatedBlockIdAndFromIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByAuthorizationUpdatedBlockIdAndFromId: BlockIdentitiesByAuthorizationUpdatedBlockIdAndFromIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByBridgeEventCreatedBlockIdAndIdentityId: BlockIdentitiesByBridgeEventCreatedBlockIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByBridgeEventUpdatedBlockIdAndIdentityId: BlockIdentitiesByBridgeEventUpdatedBlockIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByChildIdentityCreatedBlockIdAndChildId: BlockIdentitiesByChildIdentityCreatedBlockIdAndChildIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByChildIdentityCreatedBlockIdAndParentId: BlockIdentitiesByChildIdentityCreatedBlockIdAndParentIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByChildIdentityUpdatedBlockIdAndChildId: BlockIdentitiesByChildIdentityUpdatedBlockIdAndChildIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByChildIdentityUpdatedBlockIdAndParentId: BlockIdentitiesByChildIdentityUpdatedBlockIdAndParentIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByClaimCreatedBlockIdAndIssuerId: BlockIdentitiesByClaimCreatedBlockIdAndIssuerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByClaimCreatedBlockIdAndTargetId: BlockIdentitiesByClaimCreatedBlockIdAndTargetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByClaimUpdatedBlockIdAndIssuerId: BlockIdentitiesByClaimUpdatedBlockIdAndIssuerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByClaimUpdatedBlockIdAndTargetId: BlockIdentitiesByClaimUpdatedBlockIdAndTargetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByCreatedBlockId: IdentitiesConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByDistributionCreatedBlockIdAndIdentityId: BlockIdentitiesByDistributionCreatedBlockIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByDistributionPaymentCreatedBlockIdAndTargetId: BlockIdentitiesByDistributionPaymentCreatedBlockIdAndTargetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByDistributionPaymentUpdatedBlockIdAndTargetId: BlockIdentitiesByDistributionPaymentUpdatedBlockIdAndTargetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByDistributionUpdatedBlockIdAndIdentityId: BlockIdentitiesByDistributionUpdatedBlockIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByInvestmentCreatedBlockIdAndInvestorId: BlockIdentitiesByInvestmentCreatedBlockIdAndInvestorIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByInvestmentUpdatedBlockIdAndInvestorId: BlockIdentitiesByInvestmentUpdatedBlockIdAndInvestorIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByPortfolioCreatedBlockIdAndCustodianId: BlockIdentitiesByPortfolioCreatedBlockIdAndCustodianIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByPortfolioCreatedBlockIdAndIdentityId: BlockIdentitiesByPortfolioCreatedBlockIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByPortfolioUpdatedBlockIdAndCustodianId: BlockIdentitiesByPortfolioUpdatedBlockIdAndCustodianIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByPortfolioUpdatedBlockIdAndIdentityId: BlockIdentitiesByPortfolioUpdatedBlockIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByProposalCreatedBlockIdAndOwnerId: BlockIdentitiesByProposalCreatedBlockIdAndOwnerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByProposalUpdatedBlockIdAndOwnerId: BlockIdentitiesByProposalUpdatedBlockIdAndOwnerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByStakingEventCreatedBlockIdAndIdentityId: BlockIdentitiesByStakingEventCreatedBlockIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByStakingEventUpdatedBlockIdAndIdentityId: BlockIdentitiesByStakingEventUpdatedBlockIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByStatTypeCreatedBlockIdAndClaimIssuerId: BlockIdentitiesByStatTypeCreatedBlockIdAndClaimIssuerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByStatTypeUpdatedBlockIdAndClaimIssuerId: BlockIdentitiesByStatTypeUpdatedBlockIdAndClaimIssuerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByStoCreatedBlockIdAndCreatorId: BlockIdentitiesByStoCreatedBlockIdAndCreatorIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByStoUpdatedBlockIdAndCreatorId: BlockIdentitiesByStoUpdatedBlockIdAndCreatorIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByTickerExternalAgentActionCreatedBlockIdAndCallerId: BlockIdentitiesByTickerExternalAgentActionCreatedBlockIdAndCallerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByTickerExternalAgentActionUpdatedBlockIdAndCallerId: BlockIdentitiesByTickerExternalAgentActionUpdatedBlockIdAndCallerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByTickerExternalAgentCreatedBlockIdAndCallerId: BlockIdentitiesByTickerExternalAgentCreatedBlockIdAndCallerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByTickerExternalAgentHistoryCreatedBlockIdAndIdentityId: BlockIdentitiesByTickerExternalAgentHistoryCreatedBlockIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByTickerExternalAgentHistoryUpdatedBlockIdAndIdentityId: BlockIdentitiesByTickerExternalAgentHistoryUpdatedBlockIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByTickerExternalAgentUpdatedBlockIdAndCallerId: BlockIdentitiesByTickerExternalAgentUpdatedBlockIdAndCallerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByTransferComplianceCreatedBlockIdAndClaimIssuerId: BlockIdentitiesByTransferComplianceCreatedBlockIdAndClaimIssuerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByTransferComplianceUpdatedBlockIdAndClaimIssuerId: BlockIdentitiesByTransferComplianceUpdatedBlockIdAndClaimIssuerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByUpdatedBlockId: IdentitiesConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByVenueCreatedBlockIdAndOwnerId: BlockIdentitiesByVenueCreatedBlockIdAndOwnerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByVenueUpdatedBlockIdAndOwnerId: BlockIdentitiesByVenueUpdatedBlockIdAndOwnerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Instruction`. */
  instructionsByCreatedBlockId: InstructionsConnection;
  /** Reads and enables pagination through a set of `Instruction`. */
  instructionsByLegCreatedBlockIdAndInstructionId: BlockInstructionsByLegCreatedBlockIdAndInstructionIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Instruction`. */
  instructionsByLegUpdatedBlockIdAndInstructionId: BlockInstructionsByLegUpdatedBlockIdAndInstructionIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Instruction`. */
  instructionsByUpdatedBlockId: InstructionsConnection;
  /** Reads and enables pagination through a set of `Investment`. */
  investmentsByCreatedBlockId: InvestmentsConnection;
  /** Reads and enables pagination through a set of `Investment`. */
  investmentsByUpdatedBlockId: InvestmentsConnection;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByCreatedBlockId: LegsConnection;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByUpdatedBlockId: LegsConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  parentHash: Scalars['String']['output'];
  parentId: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `Permission`. */
  permissionsByAccountCreatedBlockIdAndPermissionsId: BlockPermissionsByAccountCreatedBlockIdAndPermissionsIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Permission`. */
  permissionsByAccountUpdatedBlockIdAndPermissionsId: BlockPermissionsByAccountUpdatedBlockIdAndPermissionsIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Permission`. */
  permissionsByCreatedBlockId: PermissionsConnection;
  /** Reads and enables pagination through a set of `Permission`. */
  permissionsByUpdatedBlockId: PermissionsConnection;
  /** Reads and enables pagination through a set of `PolyxTransaction`. */
  polyxTransactionsByCreatedBlockId: PolyxTransactionsConnection;
  /** Reads and enables pagination through a set of `PolyxTransaction`. */
  polyxTransactionsByUpdatedBlockId: PolyxTransactionsConnection;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByCreatedBlockId: PortfolioMovementsConnection;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByUpdatedBlockId: PortfolioMovementsConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByAssetTransactionCreatedBlockIdAndFromPortfolioId: BlockPortfoliosByAssetTransactionCreatedBlockIdAndFromPortfolioIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByAssetTransactionCreatedBlockIdAndToPortfolioId: BlockPortfoliosByAssetTransactionCreatedBlockIdAndToPortfolioIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByAssetTransactionUpdatedBlockIdAndFromPortfolioId: BlockPortfoliosByAssetTransactionUpdatedBlockIdAndFromPortfolioIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByAssetTransactionUpdatedBlockIdAndToPortfolioId: BlockPortfoliosByAssetTransactionUpdatedBlockIdAndToPortfolioIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByCreatedBlockId: PortfoliosConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByDistributionCreatedBlockIdAndPortfolioId: BlockPortfoliosByDistributionCreatedBlockIdAndPortfolioIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByDistributionUpdatedBlockIdAndPortfolioId: BlockPortfoliosByDistributionUpdatedBlockIdAndPortfolioIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByLegCreatedBlockIdAndFromId: BlockPortfoliosByLegCreatedBlockIdAndFromIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByLegCreatedBlockIdAndToId: BlockPortfoliosByLegCreatedBlockIdAndToIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByLegUpdatedBlockIdAndFromId: BlockPortfoliosByLegUpdatedBlockIdAndFromIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByLegUpdatedBlockIdAndToId: BlockPortfoliosByLegUpdatedBlockIdAndToIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByPortfolioMovementCreatedBlockIdAndFromId: BlockPortfoliosByPortfolioMovementCreatedBlockIdAndFromIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByPortfolioMovementCreatedBlockIdAndToId: BlockPortfoliosByPortfolioMovementCreatedBlockIdAndToIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByPortfolioMovementUpdatedBlockIdAndFromId: BlockPortfoliosByPortfolioMovementUpdatedBlockIdAndFromIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByPortfolioMovementUpdatedBlockIdAndToId: BlockPortfoliosByPortfolioMovementUpdatedBlockIdAndToIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByStoCreatedBlockIdAndOfferingPortfolioId: BlockPortfoliosByStoCreatedBlockIdAndOfferingPortfolioIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByStoCreatedBlockIdAndRaisingPortfolioId: BlockPortfoliosByStoCreatedBlockIdAndRaisingPortfolioIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByStoUpdatedBlockIdAndOfferingPortfolioId: BlockPortfoliosByStoUpdatedBlockIdAndOfferingPortfolioIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByStoUpdatedBlockIdAndRaisingPortfolioId: BlockPortfoliosByStoUpdatedBlockIdAndRaisingPortfolioIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByUpdatedBlockId: PortfoliosConnection;
  /** Reads and enables pagination through a set of `ProposalVote`. */
  proposalVotesByCreatedBlockId: ProposalVotesConnection;
  /** Reads and enables pagination through a set of `ProposalVote`. */
  proposalVotesByUpdatedBlockId: ProposalVotesConnection;
  /** Reads and enables pagination through a set of `Proposal`. */
  proposalsByCreatedBlockId: ProposalsConnection;
  /** Reads and enables pagination through a set of `Proposal`. */
  proposalsByProposalVoteCreatedBlockIdAndProposalId: BlockProposalsByProposalVoteCreatedBlockIdAndProposalIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Proposal`. */
  proposalsByProposalVoteUpdatedBlockIdAndProposalId: BlockProposalsByProposalVoteUpdatedBlockIdAndProposalIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Proposal`. */
  proposalsByUpdatedBlockId: ProposalsConnection;
  /** Reads and enables pagination through a set of `Settlement`. */
  settlementsByCreatedBlockId: SettlementsConnection;
  /** Reads and enables pagination through a set of `Settlement`. */
  settlementsByLegCreatedBlockIdAndSettlementId: BlockSettlementsByLegCreatedBlockIdAndSettlementIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Settlement`. */
  settlementsByLegUpdatedBlockIdAndSettlementId: BlockSettlementsByLegUpdatedBlockIdAndSettlementIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Settlement`. */
  settlementsByUpdatedBlockId: SettlementsConnection;
  specVersionId: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `StakingEvent`. */
  stakingEventsByCreatedBlockId: StakingEventsConnection;
  /** Reads and enables pagination through a set of `StakingEvent`. */
  stakingEventsByUpdatedBlockId: StakingEventsConnection;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypesByCreatedBlockId: StatTypesConnection;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypesByTransferComplianceCreatedBlockIdAndStatTypeId: BlockStatTypesByTransferComplianceCreatedBlockIdAndStatTypeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypesByTransferComplianceUpdatedBlockIdAndStatTypeId: BlockStatTypesByTransferComplianceUpdatedBlockIdAndStatTypeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypesByUpdatedBlockId: StatTypesConnection;
  stateRoot: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `Sto`. */
  stosByCreatedBlockId: StosConnection;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByUpdatedBlockId: StosConnection;
  /** Reads and enables pagination through a set of `TickerExternalAgentAction`. */
  tickerExternalAgentActionsByCreatedBlockId: TickerExternalAgentActionsConnection;
  /** Reads and enables pagination through a set of `TickerExternalAgentAction`. */
  tickerExternalAgentActionsByUpdatedBlockId: TickerExternalAgentActionsConnection;
  /** Reads and enables pagination through a set of `TickerExternalAgentHistory`. */
  tickerExternalAgentHistoriesByCreatedBlockId: TickerExternalAgentHistoriesConnection;
  /** Reads and enables pagination through a set of `TickerExternalAgentHistory`. */
  tickerExternalAgentHistoriesByUpdatedBlockId: TickerExternalAgentHistoriesConnection;
  /** Reads and enables pagination through a set of `TickerExternalAgent`. */
  tickerExternalAgentsByCreatedBlockId: TickerExternalAgentsConnection;
  /** Reads and enables pagination through a set of `TickerExternalAgent`. */
  tickerExternalAgentsByUpdatedBlockId: TickerExternalAgentsConnection;
  /** Reads and enables pagination through a set of `TransferComplianceExemption`. */
  transferComplianceExemptionsByCreatedBlockId: TransferComplianceExemptionsConnection;
  /** Reads and enables pagination through a set of `TransferComplianceExemption`. */
  transferComplianceExemptionsByUpdatedBlockId: TransferComplianceExemptionsConnection;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliancesByCreatedBlockId: TransferCompliancesConnection;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliancesByUpdatedBlockId: TransferCompliancesConnection;
  /** Reads and enables pagination through a set of `TransferManager`. */
  transferManagersByCreatedBlockId: TransferManagersConnection;
  /** Reads and enables pagination through a set of `TransferManager`. */
  transferManagersByUpdatedBlockId: TransferManagersConnection;
  /** Reads and enables pagination through a set of `TrustedClaimIssuer`. */
  trustedClaimIssuersByCreatedBlockId: TrustedClaimIssuersConnection;
  /** Reads and enables pagination through a set of `TrustedClaimIssuer`. */
  trustedClaimIssuersByUpdatedBlockId: TrustedClaimIssuersConnection;
  updatedAt: Scalars['Datetime']['output'];
  /** Reads and enables pagination through a set of `Venue`. */
  venuesByCreatedBlockId: VenuesConnection;
  /** Reads and enables pagination through a set of `Venue`. */
  venuesByInstructionCreatedBlockIdAndVenueId: BlockVenuesByInstructionCreatedBlockIdAndVenueIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Venue`. */
  venuesByInstructionUpdatedBlockIdAndVenueId: BlockVenuesByInstructionUpdatedBlockIdAndVenueIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Venue`. */
  venuesByStoCreatedBlockIdAndVenueId: BlockVenuesByStoCreatedBlockIdAndVenueIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Venue`. */
  venuesByStoUpdatedBlockIdAndVenueId: BlockVenuesByStoUpdatedBlockIdAndVenueIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Venue`. */
  venuesByUpdatedBlockId: VenuesConnection;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAccountHistoriesByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AccountHistoryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountHistoriesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAccountHistoriesByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AccountHistoryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountHistoriesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAccountsByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AccountFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAccountsByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AccountFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAgentGroupMembershipsByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AgentGroupMembershipFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AgentGroupMembershipsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAgentGroupMembershipsByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AgentGroupMembershipFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AgentGroupMembershipsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAgentGroupsByAgentGroupMembershipCreatedBlockIdAndGroupIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AgentGroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AgentGroupsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAgentGroupsByAgentGroupMembershipUpdatedBlockIdAndGroupIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AgentGroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AgentGroupsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAgentGroupsByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AgentGroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AgentGroupsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAgentGroupsByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AgentGroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AgentGroupsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetDocumentsByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetDocumentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetDocumentsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetDocumentsByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetDocumentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetDocumentsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetHoldersByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetHolderFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetHoldersOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetHoldersByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetHolderFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetHoldersOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetPendingOwnershipTransfersByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetPendingOwnershipTransferFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetPendingOwnershipTransfersOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetPendingOwnershipTransfersByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetPendingOwnershipTransferFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetPendingOwnershipTransfersOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetTransactionsByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetTransactionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetTransactionsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetTransactionsByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetTransactionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetTransactionsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetsByAssetDocumentCreatedBlockIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetsByAssetDocumentUpdatedBlockIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetsByAssetHolderCreatedBlockIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetsByAssetHolderUpdatedBlockIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetsByAssetTransactionCreatedBlockIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetsByAssetTransactionUpdatedBlockIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetsByComplianceCreatedBlockIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetsByComplianceUpdatedBlockIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetsByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetsByDistributionCreatedBlockIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetsByDistributionUpdatedBlockIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetsByFundingCreatedBlockIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetsByFundingUpdatedBlockIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetsByPortfolioMovementCreatedBlockIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetsByPortfolioMovementUpdatedBlockIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetsByStatTypeCreatedBlockIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetsByStatTypeUpdatedBlockIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetsByStoCreatedBlockIdAndOfferingAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetsByStoUpdatedBlockIdAndOfferingAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetsByTickerExternalAgentActionCreatedBlockIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetsByTickerExternalAgentActionUpdatedBlockIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetsByTickerExternalAgentCreatedBlockIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetsByTickerExternalAgentHistoryCreatedBlockIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetsByTickerExternalAgentHistoryUpdatedBlockIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetsByTickerExternalAgentUpdatedBlockIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetsByTransferComplianceCreatedBlockIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetsByTransferComplianceExemptionCreatedBlockIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetsByTransferComplianceExemptionUpdatedBlockIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetsByTransferComplianceUpdatedBlockIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetsByTransferManagerCreatedBlockIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetsByTransferManagerUpdatedBlockIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetsByTrustedClaimIssuerCreatedBlockIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetsByTrustedClaimIssuerUpdatedBlockIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAssetsByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAuthorizationsByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AuthorizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AuthorizationsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockAuthorizationsByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AuthorizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AuthorizationsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByAccountCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByAccountHistoryCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByAccountHistoryUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByAccountUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByAgentGroupCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByAgentGroupMembershipCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByAgentGroupMembershipUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByAgentGroupUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByAssetCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByAssetDocumentCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByAssetDocumentUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByAssetHolderCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByAssetHolderUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByAssetPendingOwnershipTransferCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByAssetPendingOwnershipTransferUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByAssetTransactionCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByAssetTransactionUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByAssetUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByAuthorizationCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByAuthorizationUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByBridgeEventCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByBridgeEventUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByChildIdentityCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByChildIdentityUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByClaimCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByClaimScopeCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByClaimScopeUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByClaimUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByComplianceCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByComplianceUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByDistributionCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByDistributionPaymentCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByDistributionPaymentUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByDistributionUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByFundingCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByFundingUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByIdentityCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByIdentityUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByInstructionCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByInstructionUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByInvestmentCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByInvestmentUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByLegCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByLegUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByPermissionCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByPermissionUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByPolyxTransactionCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByPolyxTransactionUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByPortfolioCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByPortfolioMovementCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByPortfolioMovementUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByPortfolioUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByProposalCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByProposalUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByProposalVoteCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByProposalVoteUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksBySettlementCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksBySettlementUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByStakingEventCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByStakingEventUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByStatTypeCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByStatTypeUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByStoCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByStoUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByTickerExternalAgentActionCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByTickerExternalAgentActionUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByTickerExternalAgentCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByTickerExternalAgentHistoryCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByTickerExternalAgentHistoryUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByTickerExternalAgentUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByTransferComplianceCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByTransferComplianceExemptionCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByTransferComplianceExemptionUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByTransferComplianceUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByTransferManagerCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByTransferManagerUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByTrustedClaimIssuerCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByTrustedClaimIssuerUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByVenueCreatedBlockIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBlocksByVenueUpdatedBlockIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBridgeEventsByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BridgeEventFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BridgeEventsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockBridgeEventsByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BridgeEventFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BridgeEventsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockChildIdentitiesByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ChildIdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ChildIdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockChildIdentitiesByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ChildIdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ChildIdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockClaimScopesByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ClaimScopeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClaimScopesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockClaimScopesByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ClaimScopeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClaimScopesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockClaimsByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ClaimFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClaimsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockClaimsByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ClaimFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClaimsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockCompliancesByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ComplianceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CompliancesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockCompliancesByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ComplianceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CompliancesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockDistributionPaymentsByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<DistributionPaymentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DistributionPaymentsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockDistributionPaymentsByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<DistributionPaymentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DistributionPaymentsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockDistributionsByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<DistributionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DistributionsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockDistributionsByDistributionPaymentCreatedBlockIdAndDistributionIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<DistributionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DistributionsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockDistributionsByDistributionPaymentUpdatedBlockIdAndDistributionIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<DistributionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DistributionsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockDistributionsByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<DistributionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DistributionsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockEventsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<EventFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockExtrinsicsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ExtrinsicFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ExtrinsicsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockExtrinsicsByPolyxTransactionCreatedBlockIdAndExtrinsicIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ExtrinsicFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ExtrinsicsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockExtrinsicsByPolyxTransactionUpdatedBlockIdAndExtrinsicIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ExtrinsicFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ExtrinsicsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockFundingsByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<FundingFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FundingsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockFundingsByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<FundingFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FundingsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByAccountCreatedBlockIdAndIdentityIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByAccountUpdatedBlockIdAndIdentityIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByAssetCreatedBlockIdAndOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByAssetHolderCreatedBlockIdAndIdentityIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByAssetHolderUpdatedBlockIdAndIdentityIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByAssetUpdatedBlockIdAndOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByAuthorizationCreatedBlockIdAndFromIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByAuthorizationUpdatedBlockIdAndFromIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByBridgeEventCreatedBlockIdAndIdentityIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByBridgeEventUpdatedBlockIdAndIdentityIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByChildIdentityCreatedBlockIdAndChildIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByChildIdentityCreatedBlockIdAndParentIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByChildIdentityUpdatedBlockIdAndChildIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByChildIdentityUpdatedBlockIdAndParentIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByClaimCreatedBlockIdAndIssuerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByClaimCreatedBlockIdAndTargetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByClaimUpdatedBlockIdAndIssuerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByClaimUpdatedBlockIdAndTargetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByDistributionCreatedBlockIdAndIdentityIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByDistributionPaymentCreatedBlockIdAndTargetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByDistributionPaymentUpdatedBlockIdAndTargetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByDistributionUpdatedBlockIdAndIdentityIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByInvestmentCreatedBlockIdAndInvestorIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByInvestmentUpdatedBlockIdAndInvestorIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByPortfolioCreatedBlockIdAndCustodianIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByPortfolioCreatedBlockIdAndIdentityIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByPortfolioUpdatedBlockIdAndCustodianIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByPortfolioUpdatedBlockIdAndIdentityIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByProposalCreatedBlockIdAndOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByProposalUpdatedBlockIdAndOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByStakingEventCreatedBlockIdAndIdentityIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByStakingEventUpdatedBlockIdAndIdentityIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByStatTypeCreatedBlockIdAndClaimIssuerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByStatTypeUpdatedBlockIdAndClaimIssuerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByStoCreatedBlockIdAndCreatorIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByStoUpdatedBlockIdAndCreatorIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByTickerExternalAgentActionCreatedBlockIdAndCallerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByTickerExternalAgentActionUpdatedBlockIdAndCallerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByTickerExternalAgentCreatedBlockIdAndCallerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByTickerExternalAgentHistoryCreatedBlockIdAndIdentityIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByTickerExternalAgentHistoryUpdatedBlockIdAndIdentityIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByTickerExternalAgentUpdatedBlockIdAndCallerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByTransferComplianceCreatedBlockIdAndClaimIssuerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByTransferComplianceUpdatedBlockIdAndClaimIssuerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByVenueCreatedBlockIdAndOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockIdentitiesByVenueUpdatedBlockIdAndOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockInstructionsByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<InstructionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InstructionsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockInstructionsByLegCreatedBlockIdAndInstructionIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<InstructionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InstructionsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockInstructionsByLegUpdatedBlockIdAndInstructionIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<InstructionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InstructionsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockInstructionsByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<InstructionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InstructionsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockInvestmentsByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<InvestmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InvestmentsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockInvestmentsByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<InvestmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InvestmentsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockLegsByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<LegFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LegsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockLegsByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<LegFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LegsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockPermissionsByAccountCreatedBlockIdAndPermissionsIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PermissionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockPermissionsByAccountUpdatedBlockIdAndPermissionsIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PermissionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockPermissionsByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PermissionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockPermissionsByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PermissionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockPolyxTransactionsByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PolyxTransactionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PolyxTransactionsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockPolyxTransactionsByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PolyxTransactionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PolyxTransactionsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockPortfolioMovementsByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioMovementFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfolioMovementsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockPortfolioMovementsByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioMovementFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfolioMovementsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockPortfoliosByAssetTransactionCreatedBlockIdAndFromPortfolioIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockPortfoliosByAssetTransactionCreatedBlockIdAndToPortfolioIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockPortfoliosByAssetTransactionUpdatedBlockIdAndFromPortfolioIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockPortfoliosByAssetTransactionUpdatedBlockIdAndToPortfolioIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockPortfoliosByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockPortfoliosByDistributionCreatedBlockIdAndPortfolioIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockPortfoliosByDistributionUpdatedBlockIdAndPortfolioIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockPortfoliosByLegCreatedBlockIdAndFromIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockPortfoliosByLegCreatedBlockIdAndToIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockPortfoliosByLegUpdatedBlockIdAndFromIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockPortfoliosByLegUpdatedBlockIdAndToIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockPortfoliosByPortfolioMovementCreatedBlockIdAndFromIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockPortfoliosByPortfolioMovementCreatedBlockIdAndToIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockPortfoliosByPortfolioMovementUpdatedBlockIdAndFromIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockPortfoliosByPortfolioMovementUpdatedBlockIdAndToIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockPortfoliosByStoCreatedBlockIdAndOfferingPortfolioIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockPortfoliosByStoCreatedBlockIdAndRaisingPortfolioIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockPortfoliosByStoUpdatedBlockIdAndOfferingPortfolioIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockPortfoliosByStoUpdatedBlockIdAndRaisingPortfolioIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockPortfoliosByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockProposalVotesByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ProposalVoteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProposalVotesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockProposalVotesByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ProposalVoteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProposalVotesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockProposalsByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ProposalFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProposalsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockProposalsByProposalVoteCreatedBlockIdAndProposalIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ProposalFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProposalsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockProposalsByProposalVoteUpdatedBlockIdAndProposalIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ProposalFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProposalsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockProposalsByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ProposalFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProposalsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockSettlementsByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<SettlementFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SettlementsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockSettlementsByLegCreatedBlockIdAndSettlementIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<SettlementFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SettlementsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockSettlementsByLegUpdatedBlockIdAndSettlementIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<SettlementFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SettlementsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockSettlementsByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<SettlementFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SettlementsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockStakingEventsByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StakingEventFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StakingEventsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockStakingEventsByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StakingEventFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StakingEventsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockStatTypesByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StatTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StatTypesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockStatTypesByTransferComplianceCreatedBlockIdAndStatTypeIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StatTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StatTypesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockStatTypesByTransferComplianceUpdatedBlockIdAndStatTypeIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StatTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StatTypesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockStatTypesByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StatTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StatTypesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockStosByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StoFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StosOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockStosByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StoFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StosOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockTickerExternalAgentActionsByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<TickerExternalAgentActionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TickerExternalAgentActionsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockTickerExternalAgentActionsByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<TickerExternalAgentActionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TickerExternalAgentActionsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockTickerExternalAgentHistoriesByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<TickerExternalAgentHistoryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TickerExternalAgentHistoriesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockTickerExternalAgentHistoriesByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<TickerExternalAgentHistoryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TickerExternalAgentHistoriesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockTickerExternalAgentsByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<TickerExternalAgentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TickerExternalAgentsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockTickerExternalAgentsByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<TickerExternalAgentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TickerExternalAgentsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockTransferComplianceExemptionsByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<TransferComplianceExemptionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TransferComplianceExemptionsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockTransferComplianceExemptionsByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<TransferComplianceExemptionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TransferComplianceExemptionsOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockTransferCompliancesByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<TransferComplianceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TransferCompliancesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockTransferCompliancesByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<TransferComplianceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TransferCompliancesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockTransferManagersByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<TransferManagerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TransferManagersOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockTransferManagersByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<TransferManagerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TransferManagersOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockTrustedClaimIssuersByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<TrustedClaimIssuerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TrustedClaimIssuersOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockTrustedClaimIssuersByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<TrustedClaimIssuerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TrustedClaimIssuersOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockVenuesByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<VenueFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VenuesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockVenuesByInstructionCreatedBlockIdAndVenueIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<VenueFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VenuesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockVenuesByInstructionUpdatedBlockIdAndVenueIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<VenueFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VenuesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockVenuesByStoCreatedBlockIdAndVenueIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<VenueFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VenuesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockVenuesByStoUpdatedBlockIdAndVenueIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<VenueFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VenuesOrderBy>>;
};

/** A set of transactions that were executed together. Includes a reference to its parent, which reference its parent, this forms a chain to the genesis block */
export type BlockVenuesByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<VenueFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VenuesOrderBy>>;
};

/** A connection to a list of `AgentGroup` values, with data from `AgentGroupMembership`. */
export type BlockAgentGroupsByAgentGroupMembershipCreatedBlockIdAndGroupIdManyToManyConnection = {
  __typename?: 'BlockAgentGroupsByAgentGroupMembershipCreatedBlockIdAndGroupIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AgentGroupAggregates>;
  /** A list of edges which contains the `AgentGroup`, info from the `AgentGroupMembership`, and the cursor to aid in pagination. */
  edges: Array<BlockAgentGroupsByAgentGroupMembershipCreatedBlockIdAndGroupIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AgentGroupAggregates>>;
  /** A list of `AgentGroup` objects. */
  nodes: Array<Maybe<AgentGroup>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AgentGroup` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `AgentGroup` values, with data from `AgentGroupMembership`. */
export type BlockAgentGroupsByAgentGroupMembershipCreatedBlockIdAndGroupIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AgentGroupsGroupBy>;
    having?: InputMaybe<AgentGroupsHavingInput>;
  };

/** A `AgentGroup` edge in the connection, with data from `AgentGroupMembership`. */
export type BlockAgentGroupsByAgentGroupMembershipCreatedBlockIdAndGroupIdManyToManyEdge = {
  __typename?: 'BlockAgentGroupsByAgentGroupMembershipCreatedBlockIdAndGroupIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `AgentGroupMembership`. */
  members: AgentGroupMembershipsConnection;
  /** The `AgentGroup` at the end of the edge. */
  node?: Maybe<AgentGroup>;
};

/** A `AgentGroup` edge in the connection, with data from `AgentGroupMembership`. */
export type BlockAgentGroupsByAgentGroupMembershipCreatedBlockIdAndGroupIdManyToManyEdgeMembersArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AgentGroupMembershipFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AgentGroupMembershipsOrderBy>>;
  };

/** A connection to a list of `AgentGroup` values, with data from `AgentGroupMembership`. */
export type BlockAgentGroupsByAgentGroupMembershipUpdatedBlockIdAndGroupIdManyToManyConnection = {
  __typename?: 'BlockAgentGroupsByAgentGroupMembershipUpdatedBlockIdAndGroupIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AgentGroupAggregates>;
  /** A list of edges which contains the `AgentGroup`, info from the `AgentGroupMembership`, and the cursor to aid in pagination. */
  edges: Array<BlockAgentGroupsByAgentGroupMembershipUpdatedBlockIdAndGroupIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AgentGroupAggregates>>;
  /** A list of `AgentGroup` objects. */
  nodes: Array<Maybe<AgentGroup>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AgentGroup` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `AgentGroup` values, with data from `AgentGroupMembership`. */
export type BlockAgentGroupsByAgentGroupMembershipUpdatedBlockIdAndGroupIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AgentGroupsGroupBy>;
    having?: InputMaybe<AgentGroupsHavingInput>;
  };

/** A `AgentGroup` edge in the connection, with data from `AgentGroupMembership`. */
export type BlockAgentGroupsByAgentGroupMembershipUpdatedBlockIdAndGroupIdManyToManyEdge = {
  __typename?: 'BlockAgentGroupsByAgentGroupMembershipUpdatedBlockIdAndGroupIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `AgentGroupMembership`. */
  members: AgentGroupMembershipsConnection;
  /** The `AgentGroup` at the end of the edge. */
  node?: Maybe<AgentGroup>;
};

/** A `AgentGroup` edge in the connection, with data from `AgentGroupMembership`. */
export type BlockAgentGroupsByAgentGroupMembershipUpdatedBlockIdAndGroupIdManyToManyEdgeMembersArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AgentGroupMembershipFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AgentGroupMembershipsOrderBy>>;
  };

export type BlockAggregates = {
  __typename?: 'BlockAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A connection to a list of `Asset` values, with data from `AssetDocument`. */
export type BlockAssetsByAssetDocumentCreatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByAssetDocumentCreatedBlockIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `AssetDocument`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByAssetDocumentCreatedBlockIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `AssetDocument`. */
export type BlockAssetsByAssetDocumentCreatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `AssetDocument`. */
export type BlockAssetsByAssetDocumentCreatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByAssetDocumentCreatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `AssetDocument`. */
  documents: AssetDocumentsConnection;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
};

/** A `Asset` edge in the connection, with data from `AssetDocument`. */
export type BlockAssetsByAssetDocumentCreatedBlockIdAndAssetIdManyToManyEdgeDocumentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetDocumentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetDocumentsOrderBy>>;
};

/** A connection to a list of `Asset` values, with data from `AssetDocument`. */
export type BlockAssetsByAssetDocumentUpdatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByAssetDocumentUpdatedBlockIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `AssetDocument`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByAssetDocumentUpdatedBlockIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `AssetDocument`. */
export type BlockAssetsByAssetDocumentUpdatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `AssetDocument`. */
export type BlockAssetsByAssetDocumentUpdatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByAssetDocumentUpdatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `AssetDocument`. */
  documents: AssetDocumentsConnection;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
};

/** A `Asset` edge in the connection, with data from `AssetDocument`. */
export type BlockAssetsByAssetDocumentUpdatedBlockIdAndAssetIdManyToManyEdgeDocumentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetDocumentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetDocumentsOrderBy>>;
};

/** A connection to a list of `Asset` values, with data from `AssetHolder`. */
export type BlockAssetsByAssetHolderCreatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByAssetHolderCreatedBlockIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `AssetHolder`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByAssetHolderCreatedBlockIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `AssetHolder`. */
export type BlockAssetsByAssetHolderCreatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `AssetHolder`. */
export type BlockAssetsByAssetHolderCreatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByAssetHolderCreatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `AssetHolder`. */
  holders: AssetHoldersConnection;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
};

/** A `Asset` edge in the connection, with data from `AssetHolder`. */
export type BlockAssetsByAssetHolderCreatedBlockIdAndAssetIdManyToManyEdgeHoldersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetHolderFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetHoldersOrderBy>>;
};

/** A connection to a list of `Asset` values, with data from `AssetHolder`. */
export type BlockAssetsByAssetHolderUpdatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByAssetHolderUpdatedBlockIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `AssetHolder`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByAssetHolderUpdatedBlockIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `AssetHolder`. */
export type BlockAssetsByAssetHolderUpdatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `AssetHolder`. */
export type BlockAssetsByAssetHolderUpdatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByAssetHolderUpdatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `AssetHolder`. */
  holders: AssetHoldersConnection;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
};

/** A `Asset` edge in the connection, with data from `AssetHolder`. */
export type BlockAssetsByAssetHolderUpdatedBlockIdAndAssetIdManyToManyEdgeHoldersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetHolderFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetHoldersOrderBy>>;
};

/** A connection to a list of `Asset` values, with data from `AssetTransaction`. */
export type BlockAssetsByAssetTransactionCreatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByAssetTransactionCreatedBlockIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `AssetTransaction`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByAssetTransactionCreatedBlockIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `AssetTransaction`. */
export type BlockAssetsByAssetTransactionCreatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `AssetTransaction`. */
export type BlockAssetsByAssetTransactionCreatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByAssetTransactionCreatedBlockIdAndAssetIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AssetTransaction`. */
  assetTransactions: AssetTransactionsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
};

/** A `Asset` edge in the connection, with data from `AssetTransaction`. */
export type BlockAssetsByAssetTransactionCreatedBlockIdAndAssetIdManyToManyEdgeAssetTransactionsArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AssetTransactionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AssetTransactionsOrderBy>>;
  };

/** A connection to a list of `Asset` values, with data from `AssetTransaction`. */
export type BlockAssetsByAssetTransactionUpdatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByAssetTransactionUpdatedBlockIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `AssetTransaction`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByAssetTransactionUpdatedBlockIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `AssetTransaction`. */
export type BlockAssetsByAssetTransactionUpdatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `AssetTransaction`. */
export type BlockAssetsByAssetTransactionUpdatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByAssetTransactionUpdatedBlockIdAndAssetIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AssetTransaction`. */
  assetTransactions: AssetTransactionsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
};

/** A `Asset` edge in the connection, with data from `AssetTransaction`. */
export type BlockAssetsByAssetTransactionUpdatedBlockIdAndAssetIdManyToManyEdgeAssetTransactionsArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AssetTransactionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AssetTransactionsOrderBy>>;
  };

/** A connection to a list of `Asset` values, with data from `Compliance`. */
export type BlockAssetsByComplianceCreatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByComplianceCreatedBlockIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `Compliance`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByComplianceCreatedBlockIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `Compliance`. */
export type BlockAssetsByComplianceCreatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `Compliance`. */
export type BlockAssetsByComplianceCreatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByComplianceCreatedBlockIdAndAssetIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Compliance`. */
  compliance: CompliancesConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
};

/** A `Asset` edge in the connection, with data from `Compliance`. */
export type BlockAssetsByComplianceCreatedBlockIdAndAssetIdManyToManyEdgeComplianceArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ComplianceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CompliancesOrderBy>>;
};

/** A connection to a list of `Asset` values, with data from `Compliance`. */
export type BlockAssetsByComplianceUpdatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByComplianceUpdatedBlockIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `Compliance`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByComplianceUpdatedBlockIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `Compliance`. */
export type BlockAssetsByComplianceUpdatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `Compliance`. */
export type BlockAssetsByComplianceUpdatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByComplianceUpdatedBlockIdAndAssetIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Compliance`. */
  compliance: CompliancesConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
};

/** A `Asset` edge in the connection, with data from `Compliance`. */
export type BlockAssetsByComplianceUpdatedBlockIdAndAssetIdManyToManyEdgeComplianceArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ComplianceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CompliancesOrderBy>>;
};

/** A connection to a list of `Asset` values, with data from `Distribution`. */
export type BlockAssetsByDistributionCreatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByDistributionCreatedBlockIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByDistributionCreatedBlockIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `Distribution`. */
export type BlockAssetsByDistributionCreatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `Distribution`. */
export type BlockAssetsByDistributionCreatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByDistributionCreatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributions: DistributionsConnection;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
};

/** A `Asset` edge in the connection, with data from `Distribution`. */
export type BlockAssetsByDistributionCreatedBlockIdAndAssetIdManyToManyEdgeDistributionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<DistributionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DistributionsOrderBy>>;
};

/** A connection to a list of `Asset` values, with data from `Distribution`. */
export type BlockAssetsByDistributionUpdatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByDistributionUpdatedBlockIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByDistributionUpdatedBlockIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `Distribution`. */
export type BlockAssetsByDistributionUpdatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `Distribution`. */
export type BlockAssetsByDistributionUpdatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByDistributionUpdatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributions: DistributionsConnection;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
};

/** A `Asset` edge in the connection, with data from `Distribution`. */
export type BlockAssetsByDistributionUpdatedBlockIdAndAssetIdManyToManyEdgeDistributionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<DistributionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DistributionsOrderBy>>;
};

/** A connection to a list of `Asset` values, with data from `Funding`. */
export type BlockAssetsByFundingCreatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByFundingCreatedBlockIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `Funding`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByFundingCreatedBlockIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `Funding`. */
export type BlockAssetsByFundingCreatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `Funding`. */
export type BlockAssetsByFundingCreatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByFundingCreatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Funding`. */
  fundings: FundingsConnection;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
};

/** A `Asset` edge in the connection, with data from `Funding`. */
export type BlockAssetsByFundingCreatedBlockIdAndAssetIdManyToManyEdgeFundingsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<FundingFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FundingsOrderBy>>;
};

/** A connection to a list of `Asset` values, with data from `Funding`. */
export type BlockAssetsByFundingUpdatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByFundingUpdatedBlockIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `Funding`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByFundingUpdatedBlockIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `Funding`. */
export type BlockAssetsByFundingUpdatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `Funding`. */
export type BlockAssetsByFundingUpdatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByFundingUpdatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Funding`. */
  fundings: FundingsConnection;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
};

/** A `Asset` edge in the connection, with data from `Funding`. */
export type BlockAssetsByFundingUpdatedBlockIdAndAssetIdManyToManyEdgeFundingsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<FundingFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FundingsOrderBy>>;
};

/** A connection to a list of `Asset` values, with data from `PortfolioMovement`. */
export type BlockAssetsByPortfolioMovementCreatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByPortfolioMovementCreatedBlockIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByPortfolioMovementCreatedBlockIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `PortfolioMovement`. */
export type BlockAssetsByPortfolioMovementCreatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `PortfolioMovement`. */
export type BlockAssetsByPortfolioMovementCreatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByPortfolioMovementCreatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovements: PortfolioMovementsConnection;
};

/** A `Asset` edge in the connection, with data from `PortfolioMovement`. */
export type BlockAssetsByPortfolioMovementCreatedBlockIdAndAssetIdManyToManyEdgePortfolioMovementsArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<PortfolioMovementFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<PortfolioMovementsOrderBy>>;
  };

/** A connection to a list of `Asset` values, with data from `PortfolioMovement`. */
export type BlockAssetsByPortfolioMovementUpdatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByPortfolioMovementUpdatedBlockIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByPortfolioMovementUpdatedBlockIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `PortfolioMovement`. */
export type BlockAssetsByPortfolioMovementUpdatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `PortfolioMovement`. */
export type BlockAssetsByPortfolioMovementUpdatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByPortfolioMovementUpdatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovements: PortfolioMovementsConnection;
};

/** A `Asset` edge in the connection, with data from `PortfolioMovement`. */
export type BlockAssetsByPortfolioMovementUpdatedBlockIdAndAssetIdManyToManyEdgePortfolioMovementsArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<PortfolioMovementFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<PortfolioMovementsOrderBy>>;
  };

/** A connection to a list of `Asset` values, with data from `StatType`. */
export type BlockAssetsByStatTypeCreatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByStatTypeCreatedBlockIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `StatType`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByStatTypeCreatedBlockIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `StatType`. */
export type BlockAssetsByStatTypeCreatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `StatType`. */
export type BlockAssetsByStatTypeCreatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByStatTypeCreatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypes: StatTypesConnection;
};

/** A `Asset` edge in the connection, with data from `StatType`. */
export type BlockAssetsByStatTypeCreatedBlockIdAndAssetIdManyToManyEdgeStatTypesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StatTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StatTypesOrderBy>>;
};

/** A connection to a list of `Asset` values, with data from `StatType`. */
export type BlockAssetsByStatTypeUpdatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByStatTypeUpdatedBlockIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `StatType`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByStatTypeUpdatedBlockIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `StatType`. */
export type BlockAssetsByStatTypeUpdatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `StatType`. */
export type BlockAssetsByStatTypeUpdatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByStatTypeUpdatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypes: StatTypesConnection;
};

/** A `Asset` edge in the connection, with data from `StatType`. */
export type BlockAssetsByStatTypeUpdatedBlockIdAndAssetIdManyToManyEdgeStatTypesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StatTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StatTypesOrderBy>>;
};

/** A connection to a list of `Asset` values, with data from `Sto`. */
export type BlockAssetsByStoCreatedBlockIdAndOfferingAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByStoCreatedBlockIdAndOfferingAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByStoCreatedBlockIdAndOfferingAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `Sto`. */
export type BlockAssetsByStoCreatedBlockIdAndOfferingAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `Sto`. */
export type BlockAssetsByStoCreatedBlockIdAndOfferingAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByStoCreatedBlockIdAndOfferingAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByOfferingAssetId: StosConnection;
};

/** A `Asset` edge in the connection, with data from `Sto`. */
export type BlockAssetsByStoCreatedBlockIdAndOfferingAssetIdManyToManyEdgeStosByOfferingAssetIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StoFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StosOrderBy>>;
  };

/** A connection to a list of `Asset` values, with data from `Sto`. */
export type BlockAssetsByStoUpdatedBlockIdAndOfferingAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByStoUpdatedBlockIdAndOfferingAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByStoUpdatedBlockIdAndOfferingAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `Sto`. */
export type BlockAssetsByStoUpdatedBlockIdAndOfferingAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `Sto`. */
export type BlockAssetsByStoUpdatedBlockIdAndOfferingAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByStoUpdatedBlockIdAndOfferingAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByOfferingAssetId: StosConnection;
};

/** A `Asset` edge in the connection, with data from `Sto`. */
export type BlockAssetsByStoUpdatedBlockIdAndOfferingAssetIdManyToManyEdgeStosByOfferingAssetIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StoFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StosOrderBy>>;
  };

/** A connection to a list of `Asset` values, with data from `TickerExternalAgentAction`. */
export type BlockAssetsByTickerExternalAgentActionCreatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByTickerExternalAgentActionCreatedBlockIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `TickerExternalAgentAction`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByTickerExternalAgentActionCreatedBlockIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `TickerExternalAgentAction`. */
export type BlockAssetsByTickerExternalAgentActionCreatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TickerExternalAgentAction`. */
export type BlockAssetsByTickerExternalAgentActionCreatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByTickerExternalAgentActionCreatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TickerExternalAgentAction`. */
  tickerExternalAgentActions: TickerExternalAgentActionsConnection;
};

/** A `Asset` edge in the connection, with data from `TickerExternalAgentAction`. */
export type BlockAssetsByTickerExternalAgentActionCreatedBlockIdAndAssetIdManyToManyEdgeTickerExternalAgentActionsArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TickerExternalAgentActionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TickerExternalAgentActionsOrderBy>>;
  };

/** A connection to a list of `Asset` values, with data from `TickerExternalAgentAction`. */
export type BlockAssetsByTickerExternalAgentActionUpdatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByTickerExternalAgentActionUpdatedBlockIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `TickerExternalAgentAction`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByTickerExternalAgentActionUpdatedBlockIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `TickerExternalAgentAction`. */
export type BlockAssetsByTickerExternalAgentActionUpdatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TickerExternalAgentAction`. */
export type BlockAssetsByTickerExternalAgentActionUpdatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByTickerExternalAgentActionUpdatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TickerExternalAgentAction`. */
  tickerExternalAgentActions: TickerExternalAgentActionsConnection;
};

/** A `Asset` edge in the connection, with data from `TickerExternalAgentAction`. */
export type BlockAssetsByTickerExternalAgentActionUpdatedBlockIdAndAssetIdManyToManyEdgeTickerExternalAgentActionsArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TickerExternalAgentActionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TickerExternalAgentActionsOrderBy>>;
  };

/** A connection to a list of `Asset` values, with data from `TickerExternalAgent`. */
export type BlockAssetsByTickerExternalAgentCreatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByTickerExternalAgentCreatedBlockIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `TickerExternalAgent`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByTickerExternalAgentCreatedBlockIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `TickerExternalAgent`. */
export type BlockAssetsByTickerExternalAgentCreatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TickerExternalAgent`. */
export type BlockAssetsByTickerExternalAgentCreatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByTickerExternalAgentCreatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TickerExternalAgent`. */
  tickerExternalAgents: TickerExternalAgentsConnection;
};

/** A `Asset` edge in the connection, with data from `TickerExternalAgent`. */
export type BlockAssetsByTickerExternalAgentCreatedBlockIdAndAssetIdManyToManyEdgeTickerExternalAgentsArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TickerExternalAgentFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TickerExternalAgentsOrderBy>>;
  };

/** A connection to a list of `Asset` values, with data from `TickerExternalAgentHistory`. */
export type BlockAssetsByTickerExternalAgentHistoryCreatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByTickerExternalAgentHistoryCreatedBlockIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `TickerExternalAgentHistory`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByTickerExternalAgentHistoryCreatedBlockIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `TickerExternalAgentHistory`. */
export type BlockAssetsByTickerExternalAgentHistoryCreatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type BlockAssetsByTickerExternalAgentHistoryCreatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByTickerExternalAgentHistoryCreatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TickerExternalAgentHistory`. */
  tickerExternalAgentHistories: TickerExternalAgentHistoriesConnection;
};

/** A `Asset` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type BlockAssetsByTickerExternalAgentHistoryCreatedBlockIdAndAssetIdManyToManyEdgeTickerExternalAgentHistoriesArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TickerExternalAgentHistoryFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TickerExternalAgentHistoriesOrderBy>>;
  };

/** A connection to a list of `Asset` values, with data from `TickerExternalAgentHistory`. */
export type BlockAssetsByTickerExternalAgentHistoryUpdatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByTickerExternalAgentHistoryUpdatedBlockIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `TickerExternalAgentHistory`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByTickerExternalAgentHistoryUpdatedBlockIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `TickerExternalAgentHistory`. */
export type BlockAssetsByTickerExternalAgentHistoryUpdatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type BlockAssetsByTickerExternalAgentHistoryUpdatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByTickerExternalAgentHistoryUpdatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TickerExternalAgentHistory`. */
  tickerExternalAgentHistories: TickerExternalAgentHistoriesConnection;
};

/** A `Asset` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type BlockAssetsByTickerExternalAgentHistoryUpdatedBlockIdAndAssetIdManyToManyEdgeTickerExternalAgentHistoriesArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TickerExternalAgentHistoryFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TickerExternalAgentHistoriesOrderBy>>;
  };

/** A connection to a list of `Asset` values, with data from `TickerExternalAgent`. */
export type BlockAssetsByTickerExternalAgentUpdatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByTickerExternalAgentUpdatedBlockIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `TickerExternalAgent`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByTickerExternalAgentUpdatedBlockIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `TickerExternalAgent`. */
export type BlockAssetsByTickerExternalAgentUpdatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TickerExternalAgent`. */
export type BlockAssetsByTickerExternalAgentUpdatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByTickerExternalAgentUpdatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TickerExternalAgent`. */
  tickerExternalAgents: TickerExternalAgentsConnection;
};

/** A `Asset` edge in the connection, with data from `TickerExternalAgent`. */
export type BlockAssetsByTickerExternalAgentUpdatedBlockIdAndAssetIdManyToManyEdgeTickerExternalAgentsArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TickerExternalAgentFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TickerExternalAgentsOrderBy>>;
  };

/** A connection to a list of `Asset` values, with data from `TransferCompliance`. */
export type BlockAssetsByTransferComplianceCreatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByTransferComplianceCreatedBlockIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByTransferComplianceCreatedBlockIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `TransferCompliance`. */
export type BlockAssetsByTransferComplianceCreatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TransferCompliance`. */
export type BlockAssetsByTransferComplianceCreatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByTransferComplianceCreatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliances: TransferCompliancesConnection;
};

/** A `Asset` edge in the connection, with data from `TransferCompliance`. */
export type BlockAssetsByTransferComplianceCreatedBlockIdAndAssetIdManyToManyEdgeTransferCompliancesArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TransferComplianceFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TransferCompliancesOrderBy>>;
  };

/** A connection to a list of `Asset` values, with data from `TransferComplianceExemption`. */
export type BlockAssetsByTransferComplianceExemptionCreatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByTransferComplianceExemptionCreatedBlockIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `TransferComplianceExemption`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByTransferComplianceExemptionCreatedBlockIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `TransferComplianceExemption`. */
export type BlockAssetsByTransferComplianceExemptionCreatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TransferComplianceExemption`. */
export type BlockAssetsByTransferComplianceExemptionCreatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByTransferComplianceExemptionCreatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TransferComplianceExemption`. */
  transferComplianceExemptions: TransferComplianceExemptionsConnection;
};

/** A `Asset` edge in the connection, with data from `TransferComplianceExemption`. */
export type BlockAssetsByTransferComplianceExemptionCreatedBlockIdAndAssetIdManyToManyEdgeTransferComplianceExemptionsArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TransferComplianceExemptionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TransferComplianceExemptionsOrderBy>>;
  };

/** A connection to a list of `Asset` values, with data from `TransferComplianceExemption`. */
export type BlockAssetsByTransferComplianceExemptionUpdatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByTransferComplianceExemptionUpdatedBlockIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `TransferComplianceExemption`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByTransferComplianceExemptionUpdatedBlockIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `TransferComplianceExemption`. */
export type BlockAssetsByTransferComplianceExemptionUpdatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TransferComplianceExemption`. */
export type BlockAssetsByTransferComplianceExemptionUpdatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByTransferComplianceExemptionUpdatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TransferComplianceExemption`. */
  transferComplianceExemptions: TransferComplianceExemptionsConnection;
};

/** A `Asset` edge in the connection, with data from `TransferComplianceExemption`. */
export type BlockAssetsByTransferComplianceExemptionUpdatedBlockIdAndAssetIdManyToManyEdgeTransferComplianceExemptionsArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TransferComplianceExemptionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TransferComplianceExemptionsOrderBy>>;
  };

/** A connection to a list of `Asset` values, with data from `TransferCompliance`. */
export type BlockAssetsByTransferComplianceUpdatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByTransferComplianceUpdatedBlockIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByTransferComplianceUpdatedBlockIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `TransferCompliance`. */
export type BlockAssetsByTransferComplianceUpdatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TransferCompliance`. */
export type BlockAssetsByTransferComplianceUpdatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByTransferComplianceUpdatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliances: TransferCompliancesConnection;
};

/** A `Asset` edge in the connection, with data from `TransferCompliance`. */
export type BlockAssetsByTransferComplianceUpdatedBlockIdAndAssetIdManyToManyEdgeTransferCompliancesArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TransferComplianceFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TransferCompliancesOrderBy>>;
  };

/** A connection to a list of `Asset` values, with data from `TransferManager`. */
export type BlockAssetsByTransferManagerCreatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByTransferManagerCreatedBlockIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `TransferManager`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByTransferManagerCreatedBlockIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `TransferManager`. */
export type BlockAssetsByTransferManagerCreatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TransferManager`. */
export type BlockAssetsByTransferManagerCreatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByTransferManagerCreatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TransferManager`. */
  transferManagers: TransferManagersConnection;
};

/** A `Asset` edge in the connection, with data from `TransferManager`. */
export type BlockAssetsByTransferManagerCreatedBlockIdAndAssetIdManyToManyEdgeTransferManagersArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TransferManagerFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TransferManagersOrderBy>>;
  };

/** A connection to a list of `Asset` values, with data from `TransferManager`. */
export type BlockAssetsByTransferManagerUpdatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByTransferManagerUpdatedBlockIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `TransferManager`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByTransferManagerUpdatedBlockIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `TransferManager`. */
export type BlockAssetsByTransferManagerUpdatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TransferManager`. */
export type BlockAssetsByTransferManagerUpdatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByTransferManagerUpdatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TransferManager`. */
  transferManagers: TransferManagersConnection;
};

/** A `Asset` edge in the connection, with data from `TransferManager`. */
export type BlockAssetsByTransferManagerUpdatedBlockIdAndAssetIdManyToManyEdgeTransferManagersArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TransferManagerFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TransferManagersOrderBy>>;
  };

/** A connection to a list of `Asset` values, with data from `TrustedClaimIssuer`. */
export type BlockAssetsByTrustedClaimIssuerCreatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByTrustedClaimIssuerCreatedBlockIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `TrustedClaimIssuer`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByTrustedClaimIssuerCreatedBlockIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `TrustedClaimIssuer`. */
export type BlockAssetsByTrustedClaimIssuerCreatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TrustedClaimIssuer`. */
export type BlockAssetsByTrustedClaimIssuerCreatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByTrustedClaimIssuerCreatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TrustedClaimIssuer`. */
  trustedClaimIssuers: TrustedClaimIssuersConnection;
};

/** A `Asset` edge in the connection, with data from `TrustedClaimIssuer`. */
export type BlockAssetsByTrustedClaimIssuerCreatedBlockIdAndAssetIdManyToManyEdgeTrustedClaimIssuersArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TrustedClaimIssuerFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TrustedClaimIssuersOrderBy>>;
  };

/** A connection to a list of `Asset` values, with data from `TrustedClaimIssuer`. */
export type BlockAssetsByTrustedClaimIssuerUpdatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByTrustedClaimIssuerUpdatedBlockIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `TrustedClaimIssuer`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByTrustedClaimIssuerUpdatedBlockIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `TrustedClaimIssuer`. */
export type BlockAssetsByTrustedClaimIssuerUpdatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TrustedClaimIssuer`. */
export type BlockAssetsByTrustedClaimIssuerUpdatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByTrustedClaimIssuerUpdatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TrustedClaimIssuer`. */
  trustedClaimIssuers: TrustedClaimIssuersConnection;
};

/** A `Asset` edge in the connection, with data from `TrustedClaimIssuer`. */
export type BlockAssetsByTrustedClaimIssuerUpdatedBlockIdAndAssetIdManyToManyEdgeTrustedClaimIssuersArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TrustedClaimIssuerFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TrustedClaimIssuersOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Account`. */
export type BlockBlocksByAccountCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByAccountCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Account`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByAccountCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Account`. */
export type BlockBlocksByAccountCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Account`. */
export type BlockBlocksByAccountCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByAccountCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Account`. */
  accountsByUpdatedBlockId: AccountsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Account`. */
export type BlockBlocksByAccountCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeAccountsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AccountFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AccountsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `AccountHistory`. */
export type BlockBlocksByAccountHistoryCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByAccountHistoryCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `AccountHistory`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByAccountHistoryCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `AccountHistory`. */
export type BlockBlocksByAccountHistoryCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AccountHistory`. */
export type BlockBlocksByAccountHistoryCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByAccountHistoryCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AccountHistory`. */
  accountHistoriesByUpdatedBlockId: AccountHistoriesConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `AccountHistory`. */
export type BlockBlocksByAccountHistoryCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeAccountHistoriesByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AccountHistoryFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AccountHistoriesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `AccountHistory`. */
export type BlockBlocksByAccountHistoryUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByAccountHistoryUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `AccountHistory`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByAccountHistoryUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `AccountHistory`. */
export type BlockBlocksByAccountHistoryUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AccountHistory`. */
export type BlockBlocksByAccountHistoryUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByAccountHistoryUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AccountHistory`. */
  accountHistoriesByCreatedBlockId: AccountHistoriesConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `AccountHistory`. */
export type BlockBlocksByAccountHistoryUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeAccountHistoriesByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AccountHistoryFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AccountHistoriesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Account`. */
export type BlockBlocksByAccountUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByAccountUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Account`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByAccountUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Account`. */
export type BlockBlocksByAccountUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Account`. */
export type BlockBlocksByAccountUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByAccountUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Account`. */
  accountsByCreatedBlockId: AccountsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Account`. */
export type BlockBlocksByAccountUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeAccountsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AccountFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AccountsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `AgentGroup`. */
export type BlockBlocksByAgentGroupCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByAgentGroupCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `AgentGroup`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByAgentGroupCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `AgentGroup`. */
export type BlockBlocksByAgentGroupCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AgentGroup`. */
export type BlockBlocksByAgentGroupCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByAgentGroupCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AgentGroup`. */
  agentGroupsByUpdatedBlockId: AgentGroupsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `AgentGroup`. */
export type BlockBlocksByAgentGroupCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeAgentGroupsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AgentGroupFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AgentGroupsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `AgentGroupMembership`. */
export type BlockBlocksByAgentGroupMembershipCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByAgentGroupMembershipCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `AgentGroupMembership`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByAgentGroupMembershipCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `AgentGroupMembership`. */
export type BlockBlocksByAgentGroupMembershipCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AgentGroupMembership`. */
export type BlockBlocksByAgentGroupMembershipCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByAgentGroupMembershipCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AgentGroupMembership`. */
  agentGroupMembershipsByUpdatedBlockId: AgentGroupMembershipsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `AgentGroupMembership`. */
export type BlockBlocksByAgentGroupMembershipCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeAgentGroupMembershipsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AgentGroupMembershipFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AgentGroupMembershipsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `AgentGroupMembership`. */
export type BlockBlocksByAgentGroupMembershipUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByAgentGroupMembershipUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `AgentGroupMembership`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByAgentGroupMembershipUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `AgentGroupMembership`. */
export type BlockBlocksByAgentGroupMembershipUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AgentGroupMembership`. */
export type BlockBlocksByAgentGroupMembershipUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByAgentGroupMembershipUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AgentGroupMembership`. */
  agentGroupMembershipsByCreatedBlockId: AgentGroupMembershipsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `AgentGroupMembership`. */
export type BlockBlocksByAgentGroupMembershipUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeAgentGroupMembershipsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AgentGroupMembershipFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AgentGroupMembershipsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `AgentGroup`. */
export type BlockBlocksByAgentGroupUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByAgentGroupUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `AgentGroup`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByAgentGroupUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `AgentGroup`. */
export type BlockBlocksByAgentGroupUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AgentGroup`. */
export type BlockBlocksByAgentGroupUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByAgentGroupUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AgentGroup`. */
  agentGroupsByCreatedBlockId: AgentGroupsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `AgentGroup`. */
export type BlockBlocksByAgentGroupUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeAgentGroupsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AgentGroupFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AgentGroupsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Asset`. */
export type BlockBlocksByAssetCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByAssetCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Asset`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByAssetCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Asset`. */
export type BlockBlocksByAssetCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Asset`. */
export type BlockBlocksByAssetCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByAssetCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByUpdatedBlockId: AssetsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Asset`. */
export type BlockBlocksByAssetCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeAssetsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AssetFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AssetsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `AssetDocument`. */
export type BlockBlocksByAssetDocumentCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByAssetDocumentCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `AssetDocument`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByAssetDocumentCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `AssetDocument`. */
export type BlockBlocksByAssetDocumentCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AssetDocument`. */
export type BlockBlocksByAssetDocumentCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByAssetDocumentCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AssetDocument`. */
  assetDocumentsByUpdatedBlockId: AssetDocumentsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `AssetDocument`. */
export type BlockBlocksByAssetDocumentCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeAssetDocumentsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AssetDocumentFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AssetDocumentsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `AssetDocument`. */
export type BlockBlocksByAssetDocumentUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByAssetDocumentUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `AssetDocument`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByAssetDocumentUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `AssetDocument`. */
export type BlockBlocksByAssetDocumentUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AssetDocument`. */
export type BlockBlocksByAssetDocumentUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByAssetDocumentUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AssetDocument`. */
  assetDocumentsByCreatedBlockId: AssetDocumentsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `AssetDocument`. */
export type BlockBlocksByAssetDocumentUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeAssetDocumentsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AssetDocumentFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AssetDocumentsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `AssetHolder`. */
export type BlockBlocksByAssetHolderCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByAssetHolderCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `AssetHolder`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByAssetHolderCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `AssetHolder`. */
export type BlockBlocksByAssetHolderCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AssetHolder`. */
export type BlockBlocksByAssetHolderCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByAssetHolderCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AssetHolder`. */
  assetHoldersByUpdatedBlockId: AssetHoldersConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `AssetHolder`. */
export type BlockBlocksByAssetHolderCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeAssetHoldersByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AssetHolderFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AssetHoldersOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `AssetHolder`. */
export type BlockBlocksByAssetHolderUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByAssetHolderUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `AssetHolder`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByAssetHolderUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `AssetHolder`. */
export type BlockBlocksByAssetHolderUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AssetHolder`. */
export type BlockBlocksByAssetHolderUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByAssetHolderUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AssetHolder`. */
  assetHoldersByCreatedBlockId: AssetHoldersConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `AssetHolder`. */
export type BlockBlocksByAssetHolderUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeAssetHoldersByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AssetHolderFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AssetHoldersOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `AssetPendingOwnershipTransfer`. */
export type BlockBlocksByAssetPendingOwnershipTransferCreatedBlockIdAndUpdatedBlockIdManyToManyConnection =
  {
    __typename?: 'BlockBlocksByAssetPendingOwnershipTransferCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<BlockAggregates>;
    /** A list of edges which contains the `Block`, info from the `AssetPendingOwnershipTransfer`, and the cursor to aid in pagination. */
    edges: Array<BlockBlocksByAssetPendingOwnershipTransferCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<BlockAggregates>>;
    /** A list of `Block` objects. */
    nodes: Array<Maybe<Block>>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Block` you could get from the connection. */
    totalCount: Scalars['Int']['output'];
  };

/** A connection to a list of `Block` values, with data from `AssetPendingOwnershipTransfer`. */
export type BlockBlocksByAssetPendingOwnershipTransferCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AssetPendingOwnershipTransfer`. */
export type BlockBlocksByAssetPendingOwnershipTransferCreatedBlockIdAndUpdatedBlockIdManyToManyEdge =
  {
    __typename?: 'BlockBlocksByAssetPendingOwnershipTransferCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
    /** Reads and enables pagination through a set of `AssetPendingOwnershipTransfer`. */
    assetPendingOwnershipTransfersByUpdatedBlockId: AssetPendingOwnershipTransfersConnection;
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']['output']>;
    /** The `Block` at the end of the edge. */
    node?: Maybe<Block>;
  };

/** A `Block` edge in the connection, with data from `AssetPendingOwnershipTransfer`. */
export type BlockBlocksByAssetPendingOwnershipTransferCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeAssetPendingOwnershipTransfersByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AssetPendingOwnershipTransferFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AssetPendingOwnershipTransfersOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `AssetPendingOwnershipTransfer`. */
export type BlockBlocksByAssetPendingOwnershipTransferUpdatedBlockIdAndCreatedBlockIdManyToManyConnection =
  {
    __typename?: 'BlockBlocksByAssetPendingOwnershipTransferUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<BlockAggregates>;
    /** A list of edges which contains the `Block`, info from the `AssetPendingOwnershipTransfer`, and the cursor to aid in pagination. */
    edges: Array<BlockBlocksByAssetPendingOwnershipTransferUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<BlockAggregates>>;
    /** A list of `Block` objects. */
    nodes: Array<Maybe<Block>>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Block` you could get from the connection. */
    totalCount: Scalars['Int']['output'];
  };

/** A connection to a list of `Block` values, with data from `AssetPendingOwnershipTransfer`. */
export type BlockBlocksByAssetPendingOwnershipTransferUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AssetPendingOwnershipTransfer`. */
export type BlockBlocksByAssetPendingOwnershipTransferUpdatedBlockIdAndCreatedBlockIdManyToManyEdge =
  {
    __typename?: 'BlockBlocksByAssetPendingOwnershipTransferUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
    /** Reads and enables pagination through a set of `AssetPendingOwnershipTransfer`. */
    assetPendingOwnershipTransfersByCreatedBlockId: AssetPendingOwnershipTransfersConnection;
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']['output']>;
    /** The `Block` at the end of the edge. */
    node?: Maybe<Block>;
  };

/** A `Block` edge in the connection, with data from `AssetPendingOwnershipTransfer`. */
export type BlockBlocksByAssetPendingOwnershipTransferUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeAssetPendingOwnershipTransfersByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AssetPendingOwnershipTransferFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AssetPendingOwnershipTransfersOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `AssetTransaction`. */
export type BlockBlocksByAssetTransactionCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByAssetTransactionCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `AssetTransaction`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByAssetTransactionCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `AssetTransaction`. */
export type BlockBlocksByAssetTransactionCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AssetTransaction`. */
export type BlockBlocksByAssetTransactionCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByAssetTransactionCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AssetTransaction`. */
  assetTransactionsByUpdatedBlockId: AssetTransactionsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `AssetTransaction`. */
export type BlockBlocksByAssetTransactionCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeAssetTransactionsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AssetTransactionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AssetTransactionsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `AssetTransaction`. */
export type BlockBlocksByAssetTransactionUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByAssetTransactionUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `AssetTransaction`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByAssetTransactionUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `AssetTransaction`. */
export type BlockBlocksByAssetTransactionUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AssetTransaction`. */
export type BlockBlocksByAssetTransactionUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByAssetTransactionUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AssetTransaction`. */
  assetTransactionsByCreatedBlockId: AssetTransactionsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `AssetTransaction`. */
export type BlockBlocksByAssetTransactionUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeAssetTransactionsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AssetTransactionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AssetTransactionsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Asset`. */
export type BlockBlocksByAssetUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByAssetUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Asset`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByAssetUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Asset`. */
export type BlockBlocksByAssetUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Asset`. */
export type BlockBlocksByAssetUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByAssetUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByCreatedBlockId: AssetsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Asset`. */
export type BlockBlocksByAssetUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeAssetsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AssetFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AssetsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Authorization`. */
export type BlockBlocksByAuthorizationCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByAuthorizationCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Authorization`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByAuthorizationCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Authorization`. */
export type BlockBlocksByAuthorizationCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Authorization`. */
export type BlockBlocksByAuthorizationCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByAuthorizationCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Authorization`. */
  authorizationsByUpdatedBlockId: AuthorizationsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Authorization`. */
export type BlockBlocksByAuthorizationCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeAuthorizationsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AuthorizationFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AuthorizationsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Authorization`. */
export type BlockBlocksByAuthorizationUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByAuthorizationUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Authorization`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByAuthorizationUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Authorization`. */
export type BlockBlocksByAuthorizationUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Authorization`. */
export type BlockBlocksByAuthorizationUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByAuthorizationUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Authorization`. */
  authorizationsByCreatedBlockId: AuthorizationsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Authorization`. */
export type BlockBlocksByAuthorizationUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeAuthorizationsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AuthorizationFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AuthorizationsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `BridgeEvent`. */
export type BlockBlocksByBridgeEventCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByBridgeEventCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `BridgeEvent`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByBridgeEventCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `BridgeEvent`. */
export type BlockBlocksByBridgeEventCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `BridgeEvent`. */
export type BlockBlocksByBridgeEventCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByBridgeEventCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `BridgeEvent`. */
  bridgeEventsByUpdatedBlockId: BridgeEventsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `BridgeEvent`. */
export type BlockBlocksByBridgeEventCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeBridgeEventsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<BridgeEventFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<BridgeEventsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `BridgeEvent`. */
export type BlockBlocksByBridgeEventUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByBridgeEventUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `BridgeEvent`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByBridgeEventUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `BridgeEvent`. */
export type BlockBlocksByBridgeEventUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `BridgeEvent`. */
export type BlockBlocksByBridgeEventUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByBridgeEventUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `BridgeEvent`. */
  bridgeEventsByCreatedBlockId: BridgeEventsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `BridgeEvent`. */
export type BlockBlocksByBridgeEventUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeBridgeEventsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<BridgeEventFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<BridgeEventsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `ChildIdentity`. */
export type BlockBlocksByChildIdentityCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByChildIdentityCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `ChildIdentity`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByChildIdentityCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `ChildIdentity`. */
export type BlockBlocksByChildIdentityCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `ChildIdentity`. */
export type BlockBlocksByChildIdentityCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByChildIdentityCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `ChildIdentity`. */
  childIdentitiesByUpdatedBlockId: ChildIdentitiesConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `ChildIdentity`. */
export type BlockBlocksByChildIdentityCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeChildIdentitiesByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<ChildIdentityFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<ChildIdentitiesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `ChildIdentity`. */
export type BlockBlocksByChildIdentityUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByChildIdentityUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `ChildIdentity`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByChildIdentityUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `ChildIdentity`. */
export type BlockBlocksByChildIdentityUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `ChildIdentity`. */
export type BlockBlocksByChildIdentityUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByChildIdentityUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `ChildIdentity`. */
  childIdentitiesByCreatedBlockId: ChildIdentitiesConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `ChildIdentity`. */
export type BlockBlocksByChildIdentityUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeChildIdentitiesByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<ChildIdentityFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<ChildIdentitiesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Claim`. */
export type BlockBlocksByClaimCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByClaimCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Claim`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByClaimCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Claim`. */
export type BlockBlocksByClaimCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Claim`. */
export type BlockBlocksByClaimCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByClaimCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Claim`. */
  claimsByUpdatedBlockId: ClaimsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Claim`. */
export type BlockBlocksByClaimCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeClaimsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<ClaimFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<ClaimsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `ClaimScope`. */
export type BlockBlocksByClaimScopeCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByClaimScopeCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `ClaimScope`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByClaimScopeCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `ClaimScope`. */
export type BlockBlocksByClaimScopeCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `ClaimScope`. */
export type BlockBlocksByClaimScopeCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByClaimScopeCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `ClaimScope`. */
  claimScopesByUpdatedBlockId: ClaimScopesConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `ClaimScope`. */
export type BlockBlocksByClaimScopeCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeClaimScopesByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<ClaimScopeFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<ClaimScopesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `ClaimScope`. */
export type BlockBlocksByClaimScopeUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByClaimScopeUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `ClaimScope`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByClaimScopeUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `ClaimScope`. */
export type BlockBlocksByClaimScopeUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `ClaimScope`. */
export type BlockBlocksByClaimScopeUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByClaimScopeUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `ClaimScope`. */
  claimScopesByCreatedBlockId: ClaimScopesConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `ClaimScope`. */
export type BlockBlocksByClaimScopeUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeClaimScopesByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<ClaimScopeFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<ClaimScopesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Claim`. */
export type BlockBlocksByClaimUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByClaimUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Claim`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByClaimUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Claim`. */
export type BlockBlocksByClaimUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Claim`. */
export type BlockBlocksByClaimUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByClaimUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Claim`. */
  claimsByCreatedBlockId: ClaimsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Claim`. */
export type BlockBlocksByClaimUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeClaimsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<ClaimFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<ClaimsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Compliance`. */
export type BlockBlocksByComplianceCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByComplianceCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Compliance`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByComplianceCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Compliance`. */
export type BlockBlocksByComplianceCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Compliance`. */
export type BlockBlocksByComplianceCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByComplianceCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Compliance`. */
  compliancesByUpdatedBlockId: CompliancesConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Compliance`. */
export type BlockBlocksByComplianceCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeCompliancesByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<ComplianceFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<CompliancesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Compliance`. */
export type BlockBlocksByComplianceUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByComplianceUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Compliance`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByComplianceUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Compliance`. */
export type BlockBlocksByComplianceUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Compliance`. */
export type BlockBlocksByComplianceUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByComplianceUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Compliance`. */
  compliancesByCreatedBlockId: CompliancesConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Compliance`. */
export type BlockBlocksByComplianceUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeCompliancesByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<ComplianceFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<CompliancesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Distribution`. */
export type BlockBlocksByDistributionCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByDistributionCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByDistributionCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Distribution`. */
export type BlockBlocksByDistributionCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Distribution`. */
export type BlockBlocksByDistributionCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByDistributionCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributionsByUpdatedBlockId: DistributionsConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Distribution`. */
export type BlockBlocksByDistributionCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeDistributionsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<DistributionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<DistributionsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `DistributionPayment`. */
export type BlockBlocksByDistributionPaymentCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByDistributionPaymentCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `DistributionPayment`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByDistributionPaymentCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `DistributionPayment`. */
export type BlockBlocksByDistributionPaymentCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `DistributionPayment`. */
export type BlockBlocksByDistributionPaymentCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByDistributionPaymentCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `DistributionPayment`. */
  distributionPaymentsByUpdatedBlockId: DistributionPaymentsConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `DistributionPayment`. */
export type BlockBlocksByDistributionPaymentCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeDistributionPaymentsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<DistributionPaymentFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<DistributionPaymentsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `DistributionPayment`. */
export type BlockBlocksByDistributionPaymentUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByDistributionPaymentUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `DistributionPayment`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByDistributionPaymentUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `DistributionPayment`. */
export type BlockBlocksByDistributionPaymentUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `DistributionPayment`. */
export type BlockBlocksByDistributionPaymentUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByDistributionPaymentUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `DistributionPayment`. */
  distributionPaymentsByCreatedBlockId: DistributionPaymentsConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `DistributionPayment`. */
export type BlockBlocksByDistributionPaymentUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeDistributionPaymentsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<DistributionPaymentFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<DistributionPaymentsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Distribution`. */
export type BlockBlocksByDistributionUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByDistributionUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByDistributionUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Distribution`. */
export type BlockBlocksByDistributionUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Distribution`. */
export type BlockBlocksByDistributionUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByDistributionUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributionsByCreatedBlockId: DistributionsConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Distribution`. */
export type BlockBlocksByDistributionUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeDistributionsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<DistributionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<DistributionsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Funding`. */
export type BlockBlocksByFundingCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByFundingCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Funding`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByFundingCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Funding`. */
export type BlockBlocksByFundingCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Funding`. */
export type BlockBlocksByFundingCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByFundingCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Funding`. */
  fundingsByUpdatedBlockId: FundingsConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Funding`. */
export type BlockBlocksByFundingCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeFundingsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<FundingFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<FundingsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Funding`. */
export type BlockBlocksByFundingUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByFundingUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Funding`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByFundingUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Funding`. */
export type BlockBlocksByFundingUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Funding`. */
export type BlockBlocksByFundingUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByFundingUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Funding`. */
  fundingsByCreatedBlockId: FundingsConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Funding`. */
export type BlockBlocksByFundingUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeFundingsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<FundingFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<FundingsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Identity`. */
export type BlockBlocksByIdentityCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByIdentityCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Identity`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByIdentityCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Identity`. */
export type BlockBlocksByIdentityCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Identity`. */
export type BlockBlocksByIdentityCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByIdentityCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByUpdatedBlockId: IdentitiesConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Identity`. */
export type BlockBlocksByIdentityCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeIdentitiesByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<IdentityFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Identity`. */
export type BlockBlocksByIdentityUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByIdentityUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Identity`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByIdentityUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Identity`. */
export type BlockBlocksByIdentityUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Identity`. */
export type BlockBlocksByIdentityUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByIdentityUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByCreatedBlockId: IdentitiesConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Identity`. */
export type BlockBlocksByIdentityUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeIdentitiesByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<IdentityFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Instruction`. */
export type BlockBlocksByInstructionCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByInstructionCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Instruction`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByInstructionCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Instruction`. */
export type BlockBlocksByInstructionCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Instruction`. */
export type BlockBlocksByInstructionCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByInstructionCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Instruction`. */
  instructionsByUpdatedBlockId: InstructionsConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Instruction`. */
export type BlockBlocksByInstructionCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeInstructionsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<InstructionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<InstructionsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Instruction`. */
export type BlockBlocksByInstructionUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByInstructionUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Instruction`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByInstructionUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Instruction`. */
export type BlockBlocksByInstructionUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Instruction`. */
export type BlockBlocksByInstructionUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByInstructionUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Instruction`. */
  instructionsByCreatedBlockId: InstructionsConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Instruction`. */
export type BlockBlocksByInstructionUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeInstructionsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<InstructionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<InstructionsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Investment`. */
export type BlockBlocksByInvestmentCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByInvestmentCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Investment`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByInvestmentCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Investment`. */
export type BlockBlocksByInvestmentCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Investment`. */
export type BlockBlocksByInvestmentCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByInvestmentCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Investment`. */
  investmentsByUpdatedBlockId: InvestmentsConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Investment`. */
export type BlockBlocksByInvestmentCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeInvestmentsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<InvestmentFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<InvestmentsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Investment`. */
export type BlockBlocksByInvestmentUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByInvestmentUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Investment`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByInvestmentUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Investment`. */
export type BlockBlocksByInvestmentUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Investment`. */
export type BlockBlocksByInvestmentUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByInvestmentUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Investment`. */
  investmentsByCreatedBlockId: InvestmentsConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Investment`. */
export type BlockBlocksByInvestmentUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeInvestmentsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<InvestmentFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<InvestmentsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Leg`. */
export type BlockBlocksByLegCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByLegCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByLegCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Leg`. */
export type BlockBlocksByLegCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Leg`. */
export type BlockBlocksByLegCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByLegCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByUpdatedBlockId: LegsConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Leg`. */
export type BlockBlocksByLegCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeLegsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<LegFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<LegsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Leg`. */
export type BlockBlocksByLegUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByLegUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByLegUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Leg`. */
export type BlockBlocksByLegUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Leg`. */
export type BlockBlocksByLegUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByLegUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByCreatedBlockId: LegsConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Leg`. */
export type BlockBlocksByLegUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeLegsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<LegFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<LegsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Permission`. */
export type BlockBlocksByPermissionCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByPermissionCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Permission`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByPermissionCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Permission`. */
export type BlockBlocksByPermissionCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Permission`. */
export type BlockBlocksByPermissionCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByPermissionCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Permission`. */
  permissionsByUpdatedBlockId: PermissionsConnection;
};

/** A `Block` edge in the connection, with data from `Permission`. */
export type BlockBlocksByPermissionCreatedBlockIdAndUpdatedBlockIdManyToManyEdgePermissionsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<PermissionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Permission`. */
export type BlockBlocksByPermissionUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByPermissionUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Permission`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByPermissionUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Permission`. */
export type BlockBlocksByPermissionUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Permission`. */
export type BlockBlocksByPermissionUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByPermissionUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Permission`. */
  permissionsByCreatedBlockId: PermissionsConnection;
};

/** A `Block` edge in the connection, with data from `Permission`. */
export type BlockBlocksByPermissionUpdatedBlockIdAndCreatedBlockIdManyToManyEdgePermissionsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<PermissionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `PolyxTransaction`. */
export type BlockBlocksByPolyxTransactionCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByPolyxTransactionCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `PolyxTransaction`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByPolyxTransactionCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `PolyxTransaction`. */
export type BlockBlocksByPolyxTransactionCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `PolyxTransaction`. */
export type BlockBlocksByPolyxTransactionCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByPolyxTransactionCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `PolyxTransaction`. */
  polyxTransactionsByUpdatedBlockId: PolyxTransactionsConnection;
};

/** A `Block` edge in the connection, with data from `PolyxTransaction`. */
export type BlockBlocksByPolyxTransactionCreatedBlockIdAndUpdatedBlockIdManyToManyEdgePolyxTransactionsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<PolyxTransactionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<PolyxTransactionsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `PolyxTransaction`. */
export type BlockBlocksByPolyxTransactionUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByPolyxTransactionUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `PolyxTransaction`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByPolyxTransactionUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `PolyxTransaction`. */
export type BlockBlocksByPolyxTransactionUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `PolyxTransaction`. */
export type BlockBlocksByPolyxTransactionUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByPolyxTransactionUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `PolyxTransaction`. */
  polyxTransactionsByCreatedBlockId: PolyxTransactionsConnection;
};

/** A `Block` edge in the connection, with data from `PolyxTransaction`. */
export type BlockBlocksByPolyxTransactionUpdatedBlockIdAndCreatedBlockIdManyToManyEdgePolyxTransactionsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<PolyxTransactionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<PolyxTransactionsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Portfolio`. */
export type BlockBlocksByPortfolioCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByPortfolioCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Portfolio`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByPortfolioCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Portfolio`. */
export type BlockBlocksByPortfolioCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Portfolio`. */
export type BlockBlocksByPortfolioCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByPortfolioCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByUpdatedBlockId: PortfoliosConnection;
};

/** A `Block` edge in the connection, with data from `Portfolio`. */
export type BlockBlocksByPortfolioCreatedBlockIdAndUpdatedBlockIdManyToManyEdgePortfoliosByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<PortfolioFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `PortfolioMovement`. */
export type BlockBlocksByPortfolioMovementCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByPortfolioMovementCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByPortfolioMovementCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `PortfolioMovement`. */
export type BlockBlocksByPortfolioMovementCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `PortfolioMovement`. */
export type BlockBlocksByPortfolioMovementCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByPortfolioMovementCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByUpdatedBlockId: PortfolioMovementsConnection;
};

/** A `Block` edge in the connection, with data from `PortfolioMovement`. */
export type BlockBlocksByPortfolioMovementCreatedBlockIdAndUpdatedBlockIdManyToManyEdgePortfolioMovementsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<PortfolioMovementFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<PortfolioMovementsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `PortfolioMovement`. */
export type BlockBlocksByPortfolioMovementUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByPortfolioMovementUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByPortfolioMovementUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `PortfolioMovement`. */
export type BlockBlocksByPortfolioMovementUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `PortfolioMovement`. */
export type BlockBlocksByPortfolioMovementUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByPortfolioMovementUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByCreatedBlockId: PortfolioMovementsConnection;
};

/** A `Block` edge in the connection, with data from `PortfolioMovement`. */
export type BlockBlocksByPortfolioMovementUpdatedBlockIdAndCreatedBlockIdManyToManyEdgePortfolioMovementsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<PortfolioMovementFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<PortfolioMovementsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Portfolio`. */
export type BlockBlocksByPortfolioUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByPortfolioUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Portfolio`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByPortfolioUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Portfolio`. */
export type BlockBlocksByPortfolioUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Portfolio`. */
export type BlockBlocksByPortfolioUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByPortfolioUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByCreatedBlockId: PortfoliosConnection;
};

/** A `Block` edge in the connection, with data from `Portfolio`. */
export type BlockBlocksByPortfolioUpdatedBlockIdAndCreatedBlockIdManyToManyEdgePortfoliosByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<PortfolioFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Proposal`. */
export type BlockBlocksByProposalCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByProposalCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Proposal`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByProposalCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Proposal`. */
export type BlockBlocksByProposalCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Proposal`. */
export type BlockBlocksByProposalCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByProposalCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Proposal`. */
  proposalsByUpdatedBlockId: ProposalsConnection;
};

/** A `Block` edge in the connection, with data from `Proposal`. */
export type BlockBlocksByProposalCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeProposalsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<ProposalFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<ProposalsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Proposal`. */
export type BlockBlocksByProposalUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByProposalUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Proposal`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByProposalUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Proposal`. */
export type BlockBlocksByProposalUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Proposal`. */
export type BlockBlocksByProposalUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByProposalUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Proposal`. */
  proposalsByCreatedBlockId: ProposalsConnection;
};

/** A `Block` edge in the connection, with data from `Proposal`. */
export type BlockBlocksByProposalUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeProposalsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<ProposalFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<ProposalsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `ProposalVote`. */
export type BlockBlocksByProposalVoteCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByProposalVoteCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `ProposalVote`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByProposalVoteCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `ProposalVote`. */
export type BlockBlocksByProposalVoteCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `ProposalVote`. */
export type BlockBlocksByProposalVoteCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByProposalVoteCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `ProposalVote`. */
  proposalVotesByUpdatedBlockId: ProposalVotesConnection;
};

/** A `Block` edge in the connection, with data from `ProposalVote`. */
export type BlockBlocksByProposalVoteCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeProposalVotesByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<ProposalVoteFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<ProposalVotesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `ProposalVote`. */
export type BlockBlocksByProposalVoteUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByProposalVoteUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `ProposalVote`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByProposalVoteUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `ProposalVote`. */
export type BlockBlocksByProposalVoteUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `ProposalVote`. */
export type BlockBlocksByProposalVoteUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByProposalVoteUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `ProposalVote`. */
  proposalVotesByCreatedBlockId: ProposalVotesConnection;
};

/** A `Block` edge in the connection, with data from `ProposalVote`. */
export type BlockBlocksByProposalVoteUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeProposalVotesByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<ProposalVoteFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<ProposalVotesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Settlement`. */
export type BlockBlocksBySettlementCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksBySettlementCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Settlement`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksBySettlementCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Settlement`. */
export type BlockBlocksBySettlementCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Settlement`. */
export type BlockBlocksBySettlementCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksBySettlementCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Settlement`. */
  settlementsByUpdatedBlockId: SettlementsConnection;
};

/** A `Block` edge in the connection, with data from `Settlement`. */
export type BlockBlocksBySettlementCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeSettlementsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<SettlementFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<SettlementsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Settlement`. */
export type BlockBlocksBySettlementUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksBySettlementUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Settlement`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksBySettlementUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Settlement`. */
export type BlockBlocksBySettlementUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Settlement`. */
export type BlockBlocksBySettlementUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksBySettlementUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Settlement`. */
  settlementsByCreatedBlockId: SettlementsConnection;
};

/** A `Block` edge in the connection, with data from `Settlement`. */
export type BlockBlocksBySettlementUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeSettlementsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<SettlementFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<SettlementsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `StakingEvent`. */
export type BlockBlocksByStakingEventCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByStakingEventCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `StakingEvent`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByStakingEventCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `StakingEvent`. */
export type BlockBlocksByStakingEventCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `StakingEvent`. */
export type BlockBlocksByStakingEventCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByStakingEventCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `StakingEvent`. */
  stakingEventsByUpdatedBlockId: StakingEventsConnection;
};

/** A `Block` edge in the connection, with data from `StakingEvent`. */
export type BlockBlocksByStakingEventCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeStakingEventsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StakingEventFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StakingEventsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `StakingEvent`. */
export type BlockBlocksByStakingEventUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByStakingEventUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `StakingEvent`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByStakingEventUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `StakingEvent`. */
export type BlockBlocksByStakingEventUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `StakingEvent`. */
export type BlockBlocksByStakingEventUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByStakingEventUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `StakingEvent`. */
  stakingEventsByCreatedBlockId: StakingEventsConnection;
};

/** A `Block` edge in the connection, with data from `StakingEvent`. */
export type BlockBlocksByStakingEventUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeStakingEventsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StakingEventFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StakingEventsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `StatType`. */
export type BlockBlocksByStatTypeCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByStatTypeCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `StatType`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByStatTypeCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `StatType`. */
export type BlockBlocksByStatTypeCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `StatType`. */
export type BlockBlocksByStatTypeCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByStatTypeCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypesByUpdatedBlockId: StatTypesConnection;
};

/** A `Block` edge in the connection, with data from `StatType`. */
export type BlockBlocksByStatTypeCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeStatTypesByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StatTypeFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StatTypesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `StatType`. */
export type BlockBlocksByStatTypeUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByStatTypeUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `StatType`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByStatTypeUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `StatType`. */
export type BlockBlocksByStatTypeUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `StatType`. */
export type BlockBlocksByStatTypeUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByStatTypeUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypesByCreatedBlockId: StatTypesConnection;
};

/** A `Block` edge in the connection, with data from `StatType`. */
export type BlockBlocksByStatTypeUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeStatTypesByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StatTypeFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StatTypesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Sto`. */
export type BlockBlocksByStoCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByStoCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByStoCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Sto`. */
export type BlockBlocksByStoCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Sto`. */
export type BlockBlocksByStoCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByStoCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByUpdatedBlockId: StosConnection;
};

/** A `Block` edge in the connection, with data from `Sto`. */
export type BlockBlocksByStoCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeStosByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StoFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StosOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Sto`. */
export type BlockBlocksByStoUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByStoUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByStoUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Sto`. */
export type BlockBlocksByStoUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Sto`. */
export type BlockBlocksByStoUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByStoUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByCreatedBlockId: StosConnection;
};

/** A `Block` edge in the connection, with data from `Sto`. */
export type BlockBlocksByStoUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeStosByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StoFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StosOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentAction`. */
export type BlockBlocksByTickerExternalAgentActionCreatedBlockIdAndUpdatedBlockIdManyToManyConnection =
  {
    __typename?: 'BlockBlocksByTickerExternalAgentActionCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<BlockAggregates>;
    /** A list of edges which contains the `Block`, info from the `TickerExternalAgentAction`, and the cursor to aid in pagination. */
    edges: Array<BlockBlocksByTickerExternalAgentActionCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<BlockAggregates>>;
    /** A list of `Block` objects. */
    nodes: Array<Maybe<Block>>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Block` you could get from the connection. */
    totalCount: Scalars['Int']['output'];
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentAction`. */
export type BlockBlocksByTickerExternalAgentActionCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TickerExternalAgentAction`. */
export type BlockBlocksByTickerExternalAgentActionCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByTickerExternalAgentActionCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TickerExternalAgentAction`. */
  tickerExternalAgentActionsByUpdatedBlockId: TickerExternalAgentActionsConnection;
};

/** A `Block` edge in the connection, with data from `TickerExternalAgentAction`. */
export type BlockBlocksByTickerExternalAgentActionCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeTickerExternalAgentActionsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TickerExternalAgentActionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TickerExternalAgentActionsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentAction`. */
export type BlockBlocksByTickerExternalAgentActionUpdatedBlockIdAndCreatedBlockIdManyToManyConnection =
  {
    __typename?: 'BlockBlocksByTickerExternalAgentActionUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<BlockAggregates>;
    /** A list of edges which contains the `Block`, info from the `TickerExternalAgentAction`, and the cursor to aid in pagination. */
    edges: Array<BlockBlocksByTickerExternalAgentActionUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<BlockAggregates>>;
    /** A list of `Block` objects. */
    nodes: Array<Maybe<Block>>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Block` you could get from the connection. */
    totalCount: Scalars['Int']['output'];
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentAction`. */
export type BlockBlocksByTickerExternalAgentActionUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TickerExternalAgentAction`. */
export type BlockBlocksByTickerExternalAgentActionUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByTickerExternalAgentActionUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TickerExternalAgentAction`. */
  tickerExternalAgentActionsByCreatedBlockId: TickerExternalAgentActionsConnection;
};

/** A `Block` edge in the connection, with data from `TickerExternalAgentAction`. */
export type BlockBlocksByTickerExternalAgentActionUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeTickerExternalAgentActionsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TickerExternalAgentActionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TickerExternalAgentActionsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgent`. */
export type BlockBlocksByTickerExternalAgentCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByTickerExternalAgentCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `TickerExternalAgent`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByTickerExternalAgentCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `TickerExternalAgent`. */
export type BlockBlocksByTickerExternalAgentCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TickerExternalAgent`. */
export type BlockBlocksByTickerExternalAgentCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByTickerExternalAgentCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TickerExternalAgent`. */
  tickerExternalAgentsByUpdatedBlockId: TickerExternalAgentsConnection;
};

/** A `Block` edge in the connection, with data from `TickerExternalAgent`. */
export type BlockBlocksByTickerExternalAgentCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeTickerExternalAgentsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TickerExternalAgentFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TickerExternalAgentsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentHistory`. */
export type BlockBlocksByTickerExternalAgentHistoryCreatedBlockIdAndUpdatedBlockIdManyToManyConnection =
  {
    __typename?: 'BlockBlocksByTickerExternalAgentHistoryCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<BlockAggregates>;
    /** A list of edges which contains the `Block`, info from the `TickerExternalAgentHistory`, and the cursor to aid in pagination. */
    edges: Array<BlockBlocksByTickerExternalAgentHistoryCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<BlockAggregates>>;
    /** A list of `Block` objects. */
    nodes: Array<Maybe<Block>>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Block` you could get from the connection. */
    totalCount: Scalars['Int']['output'];
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentHistory`. */
export type BlockBlocksByTickerExternalAgentHistoryCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type BlockBlocksByTickerExternalAgentHistoryCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByTickerExternalAgentHistoryCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TickerExternalAgentHistory`. */
  tickerExternalAgentHistoriesByUpdatedBlockId: TickerExternalAgentHistoriesConnection;
};

/** A `Block` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type BlockBlocksByTickerExternalAgentHistoryCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeTickerExternalAgentHistoriesByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TickerExternalAgentHistoryFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TickerExternalAgentHistoriesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentHistory`. */
export type BlockBlocksByTickerExternalAgentHistoryUpdatedBlockIdAndCreatedBlockIdManyToManyConnection =
  {
    __typename?: 'BlockBlocksByTickerExternalAgentHistoryUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<BlockAggregates>;
    /** A list of edges which contains the `Block`, info from the `TickerExternalAgentHistory`, and the cursor to aid in pagination. */
    edges: Array<BlockBlocksByTickerExternalAgentHistoryUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<BlockAggregates>>;
    /** A list of `Block` objects. */
    nodes: Array<Maybe<Block>>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Block` you could get from the connection. */
    totalCount: Scalars['Int']['output'];
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentHistory`. */
export type BlockBlocksByTickerExternalAgentHistoryUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type BlockBlocksByTickerExternalAgentHistoryUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByTickerExternalAgentHistoryUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TickerExternalAgentHistory`. */
  tickerExternalAgentHistoriesByCreatedBlockId: TickerExternalAgentHistoriesConnection;
};

/** A `Block` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type BlockBlocksByTickerExternalAgentHistoryUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeTickerExternalAgentHistoriesByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TickerExternalAgentHistoryFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TickerExternalAgentHistoriesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgent`. */
export type BlockBlocksByTickerExternalAgentUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByTickerExternalAgentUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `TickerExternalAgent`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByTickerExternalAgentUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `TickerExternalAgent`. */
export type BlockBlocksByTickerExternalAgentUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TickerExternalAgent`. */
export type BlockBlocksByTickerExternalAgentUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByTickerExternalAgentUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TickerExternalAgent`. */
  tickerExternalAgentsByCreatedBlockId: TickerExternalAgentsConnection;
};

/** A `Block` edge in the connection, with data from `TickerExternalAgent`. */
export type BlockBlocksByTickerExternalAgentUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeTickerExternalAgentsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TickerExternalAgentFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TickerExternalAgentsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `TransferCompliance`. */
export type BlockBlocksByTransferComplianceCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByTransferComplianceCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByTransferComplianceCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `TransferCompliance`. */
export type BlockBlocksByTransferComplianceCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TransferCompliance`. */
export type BlockBlocksByTransferComplianceCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByTransferComplianceCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliancesByUpdatedBlockId: TransferCompliancesConnection;
};

/** A `Block` edge in the connection, with data from `TransferCompliance`. */
export type BlockBlocksByTransferComplianceCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeTransferCompliancesByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TransferComplianceFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TransferCompliancesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `TransferComplianceExemption`. */
export type BlockBlocksByTransferComplianceExemptionCreatedBlockIdAndUpdatedBlockIdManyToManyConnection =
  {
    __typename?: 'BlockBlocksByTransferComplianceExemptionCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<BlockAggregates>;
    /** A list of edges which contains the `Block`, info from the `TransferComplianceExemption`, and the cursor to aid in pagination. */
    edges: Array<BlockBlocksByTransferComplianceExemptionCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<BlockAggregates>>;
    /** A list of `Block` objects. */
    nodes: Array<Maybe<Block>>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Block` you could get from the connection. */
    totalCount: Scalars['Int']['output'];
  };

/** A connection to a list of `Block` values, with data from `TransferComplianceExemption`. */
export type BlockBlocksByTransferComplianceExemptionCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TransferComplianceExemption`. */
export type BlockBlocksByTransferComplianceExemptionCreatedBlockIdAndUpdatedBlockIdManyToManyEdge =
  {
    __typename?: 'BlockBlocksByTransferComplianceExemptionCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']['output']>;
    /** The `Block` at the end of the edge. */
    node?: Maybe<Block>;
    /** Reads and enables pagination through a set of `TransferComplianceExemption`. */
    transferComplianceExemptionsByUpdatedBlockId: TransferComplianceExemptionsConnection;
  };

/** A `Block` edge in the connection, with data from `TransferComplianceExemption`. */
export type BlockBlocksByTransferComplianceExemptionCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeTransferComplianceExemptionsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TransferComplianceExemptionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TransferComplianceExemptionsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `TransferComplianceExemption`. */
export type BlockBlocksByTransferComplianceExemptionUpdatedBlockIdAndCreatedBlockIdManyToManyConnection =
  {
    __typename?: 'BlockBlocksByTransferComplianceExemptionUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<BlockAggregates>;
    /** A list of edges which contains the `Block`, info from the `TransferComplianceExemption`, and the cursor to aid in pagination. */
    edges: Array<BlockBlocksByTransferComplianceExemptionUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<BlockAggregates>>;
    /** A list of `Block` objects. */
    nodes: Array<Maybe<Block>>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Block` you could get from the connection. */
    totalCount: Scalars['Int']['output'];
  };

/** A connection to a list of `Block` values, with data from `TransferComplianceExemption`. */
export type BlockBlocksByTransferComplianceExemptionUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TransferComplianceExemption`. */
export type BlockBlocksByTransferComplianceExemptionUpdatedBlockIdAndCreatedBlockIdManyToManyEdge =
  {
    __typename?: 'BlockBlocksByTransferComplianceExemptionUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']['output']>;
    /** The `Block` at the end of the edge. */
    node?: Maybe<Block>;
    /** Reads and enables pagination through a set of `TransferComplianceExemption`. */
    transferComplianceExemptionsByCreatedBlockId: TransferComplianceExemptionsConnection;
  };

/** A `Block` edge in the connection, with data from `TransferComplianceExemption`. */
export type BlockBlocksByTransferComplianceExemptionUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeTransferComplianceExemptionsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TransferComplianceExemptionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TransferComplianceExemptionsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `TransferCompliance`. */
export type BlockBlocksByTransferComplianceUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByTransferComplianceUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByTransferComplianceUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `TransferCompliance`. */
export type BlockBlocksByTransferComplianceUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TransferCompliance`. */
export type BlockBlocksByTransferComplianceUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByTransferComplianceUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliancesByCreatedBlockId: TransferCompliancesConnection;
};

/** A `Block` edge in the connection, with data from `TransferCompliance`. */
export type BlockBlocksByTransferComplianceUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeTransferCompliancesByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TransferComplianceFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TransferCompliancesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `TransferManager`. */
export type BlockBlocksByTransferManagerCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByTransferManagerCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `TransferManager`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByTransferManagerCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `TransferManager`. */
export type BlockBlocksByTransferManagerCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TransferManager`. */
export type BlockBlocksByTransferManagerCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByTransferManagerCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TransferManager`. */
  transferManagersByUpdatedBlockId: TransferManagersConnection;
};

/** A `Block` edge in the connection, with data from `TransferManager`. */
export type BlockBlocksByTransferManagerCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeTransferManagersByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TransferManagerFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TransferManagersOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `TransferManager`. */
export type BlockBlocksByTransferManagerUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByTransferManagerUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `TransferManager`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByTransferManagerUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `TransferManager`. */
export type BlockBlocksByTransferManagerUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TransferManager`. */
export type BlockBlocksByTransferManagerUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByTransferManagerUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TransferManager`. */
  transferManagersByCreatedBlockId: TransferManagersConnection;
};

/** A `Block` edge in the connection, with data from `TransferManager`. */
export type BlockBlocksByTransferManagerUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeTransferManagersByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TransferManagerFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TransferManagersOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `TrustedClaimIssuer`. */
export type BlockBlocksByTrustedClaimIssuerCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByTrustedClaimIssuerCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `TrustedClaimIssuer`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByTrustedClaimIssuerCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `TrustedClaimIssuer`. */
export type BlockBlocksByTrustedClaimIssuerCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TrustedClaimIssuer`. */
export type BlockBlocksByTrustedClaimIssuerCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByTrustedClaimIssuerCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TrustedClaimIssuer`. */
  trustedClaimIssuersByUpdatedBlockId: TrustedClaimIssuersConnection;
};

/** A `Block` edge in the connection, with data from `TrustedClaimIssuer`. */
export type BlockBlocksByTrustedClaimIssuerCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeTrustedClaimIssuersByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TrustedClaimIssuerFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TrustedClaimIssuersOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `TrustedClaimIssuer`. */
export type BlockBlocksByTrustedClaimIssuerUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByTrustedClaimIssuerUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `TrustedClaimIssuer`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByTrustedClaimIssuerUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `TrustedClaimIssuer`. */
export type BlockBlocksByTrustedClaimIssuerUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TrustedClaimIssuer`. */
export type BlockBlocksByTrustedClaimIssuerUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByTrustedClaimIssuerUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TrustedClaimIssuer`. */
  trustedClaimIssuersByCreatedBlockId: TrustedClaimIssuersConnection;
};

/** A `Block` edge in the connection, with data from `TrustedClaimIssuer`. */
export type BlockBlocksByTrustedClaimIssuerUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeTrustedClaimIssuersByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TrustedClaimIssuerFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TrustedClaimIssuersOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Venue`. */
export type BlockBlocksByVenueCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByVenueCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Venue`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByVenueCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Venue`. */
export type BlockBlocksByVenueCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Venue`. */
export type BlockBlocksByVenueCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByVenueCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Venue`. */
  venuesByUpdatedBlockId: VenuesConnection;
};

/** A `Block` edge in the connection, with data from `Venue`. */
export type BlockBlocksByVenueCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeVenuesByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<VenueFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<VenuesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Venue`. */
export type BlockBlocksByVenueUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByVenueUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Venue`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByVenueUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Venue`. */
export type BlockBlocksByVenueUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Venue`. */
export type BlockBlocksByVenueUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByVenueUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Venue`. */
  venuesByCreatedBlockId: VenuesConnection;
};

/** A `Block` edge in the connection, with data from `Venue`. */
export type BlockBlocksByVenueUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeVenuesByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<VenueFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<VenuesOrderBy>>;
  };

/** A connection to a list of `Distribution` values, with data from `DistributionPayment`. */
export type BlockDistributionsByDistributionPaymentCreatedBlockIdAndDistributionIdManyToManyConnection =
  {
    __typename?: 'BlockDistributionsByDistributionPaymentCreatedBlockIdAndDistributionIdManyToManyConnection';
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<DistributionAggregates>;
    /** A list of edges which contains the `Distribution`, info from the `DistributionPayment`, and the cursor to aid in pagination. */
    edges: Array<BlockDistributionsByDistributionPaymentCreatedBlockIdAndDistributionIdManyToManyEdge>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<DistributionAggregates>>;
    /** A list of `Distribution` objects. */
    nodes: Array<Maybe<Distribution>>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Distribution` you could get from the connection. */
    totalCount: Scalars['Int']['output'];
  };

/** A connection to a list of `Distribution` values, with data from `DistributionPayment`. */
export type BlockDistributionsByDistributionPaymentCreatedBlockIdAndDistributionIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<DistributionsGroupBy>;
    having?: InputMaybe<DistributionsHavingInput>;
  };

/** A `Distribution` edge in the connection, with data from `DistributionPayment`. */
export type BlockDistributionsByDistributionPaymentCreatedBlockIdAndDistributionIdManyToManyEdge = {
  __typename?: 'BlockDistributionsByDistributionPaymentCreatedBlockIdAndDistributionIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `DistributionPayment`. */
  distributionPayments: DistributionPaymentsConnection;
  /** The `Distribution` at the end of the edge. */
  node?: Maybe<Distribution>;
};

/** A `Distribution` edge in the connection, with data from `DistributionPayment`. */
export type BlockDistributionsByDistributionPaymentCreatedBlockIdAndDistributionIdManyToManyEdgeDistributionPaymentsArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<DistributionPaymentFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<DistributionPaymentsOrderBy>>;
  };

/** A connection to a list of `Distribution` values, with data from `DistributionPayment`. */
export type BlockDistributionsByDistributionPaymentUpdatedBlockIdAndDistributionIdManyToManyConnection =
  {
    __typename?: 'BlockDistributionsByDistributionPaymentUpdatedBlockIdAndDistributionIdManyToManyConnection';
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<DistributionAggregates>;
    /** A list of edges which contains the `Distribution`, info from the `DistributionPayment`, and the cursor to aid in pagination. */
    edges: Array<BlockDistributionsByDistributionPaymentUpdatedBlockIdAndDistributionIdManyToManyEdge>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<DistributionAggregates>>;
    /** A list of `Distribution` objects. */
    nodes: Array<Maybe<Distribution>>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Distribution` you could get from the connection. */
    totalCount: Scalars['Int']['output'];
  };

/** A connection to a list of `Distribution` values, with data from `DistributionPayment`. */
export type BlockDistributionsByDistributionPaymentUpdatedBlockIdAndDistributionIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<DistributionsGroupBy>;
    having?: InputMaybe<DistributionsHavingInput>;
  };

/** A `Distribution` edge in the connection, with data from `DistributionPayment`. */
export type BlockDistributionsByDistributionPaymentUpdatedBlockIdAndDistributionIdManyToManyEdge = {
  __typename?: 'BlockDistributionsByDistributionPaymentUpdatedBlockIdAndDistributionIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `DistributionPayment`. */
  distributionPayments: DistributionPaymentsConnection;
  /** The `Distribution` at the end of the edge. */
  node?: Maybe<Distribution>;
};

/** A `Distribution` edge in the connection, with data from `DistributionPayment`. */
export type BlockDistributionsByDistributionPaymentUpdatedBlockIdAndDistributionIdManyToManyEdgeDistributionPaymentsArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<DistributionPaymentFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<DistributionPaymentsOrderBy>>;
  };

/** A connection to a list of `Extrinsic` values, with data from `PolyxTransaction`. */
export type BlockExtrinsicsByPolyxTransactionCreatedBlockIdAndExtrinsicIdManyToManyConnection = {
  __typename?: 'BlockExtrinsicsByPolyxTransactionCreatedBlockIdAndExtrinsicIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<ExtrinsicAggregates>;
  /** A list of edges which contains the `Extrinsic`, info from the `PolyxTransaction`, and the cursor to aid in pagination. */
  edges: Array<BlockExtrinsicsByPolyxTransactionCreatedBlockIdAndExtrinsicIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<ExtrinsicAggregates>>;
  /** A list of `Extrinsic` objects. */
  nodes: Array<Maybe<Extrinsic>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Extrinsic` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Extrinsic` values, with data from `PolyxTransaction`. */
export type BlockExtrinsicsByPolyxTransactionCreatedBlockIdAndExtrinsicIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<ExtrinsicsGroupBy>;
    having?: InputMaybe<ExtrinsicsHavingInput>;
  };

/** A `Extrinsic` edge in the connection, with data from `PolyxTransaction`. */
export type BlockExtrinsicsByPolyxTransactionCreatedBlockIdAndExtrinsicIdManyToManyEdge = {
  __typename?: 'BlockExtrinsicsByPolyxTransactionCreatedBlockIdAndExtrinsicIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Extrinsic` at the end of the edge. */
  node?: Maybe<Extrinsic>;
  /** Reads and enables pagination through a set of `PolyxTransaction`. */
  polyxTransactions: PolyxTransactionsConnection;
};

/** A `Extrinsic` edge in the connection, with data from `PolyxTransaction`. */
export type BlockExtrinsicsByPolyxTransactionCreatedBlockIdAndExtrinsicIdManyToManyEdgePolyxTransactionsArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<PolyxTransactionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<PolyxTransactionsOrderBy>>;
  };

/** A connection to a list of `Extrinsic` values, with data from `PolyxTransaction`. */
export type BlockExtrinsicsByPolyxTransactionUpdatedBlockIdAndExtrinsicIdManyToManyConnection = {
  __typename?: 'BlockExtrinsicsByPolyxTransactionUpdatedBlockIdAndExtrinsicIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<ExtrinsicAggregates>;
  /** A list of edges which contains the `Extrinsic`, info from the `PolyxTransaction`, and the cursor to aid in pagination. */
  edges: Array<BlockExtrinsicsByPolyxTransactionUpdatedBlockIdAndExtrinsicIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<ExtrinsicAggregates>>;
  /** A list of `Extrinsic` objects. */
  nodes: Array<Maybe<Extrinsic>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Extrinsic` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Extrinsic` values, with data from `PolyxTransaction`. */
export type BlockExtrinsicsByPolyxTransactionUpdatedBlockIdAndExtrinsicIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<ExtrinsicsGroupBy>;
    having?: InputMaybe<ExtrinsicsHavingInput>;
  };

/** A `Extrinsic` edge in the connection, with data from `PolyxTransaction`. */
export type BlockExtrinsicsByPolyxTransactionUpdatedBlockIdAndExtrinsicIdManyToManyEdge = {
  __typename?: 'BlockExtrinsicsByPolyxTransactionUpdatedBlockIdAndExtrinsicIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Extrinsic` at the end of the edge. */
  node?: Maybe<Extrinsic>;
  /** Reads and enables pagination through a set of `PolyxTransaction`. */
  polyxTransactions: PolyxTransactionsConnection;
};

/** A `Extrinsic` edge in the connection, with data from `PolyxTransaction`. */
export type BlockExtrinsicsByPolyxTransactionUpdatedBlockIdAndExtrinsicIdManyToManyEdgePolyxTransactionsArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<PolyxTransactionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<PolyxTransactionsOrderBy>>;
  };

/** A filter to be used against `Block` object types. All fields are combined with a logical ‘and.’ */
export type BlockFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<BlockFilter>>;
  /** Filter by the object’s `blockId` field. */
  blockId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `countEvents` field. */
  countEvents?: InputMaybe<IntFilter>;
  /** Filter by the object’s `countExtrinsics` field. */
  countExtrinsics?: InputMaybe<IntFilter>;
  /** Filter by the object’s `countExtrinsicsError` field. */
  countExtrinsicsError?: InputMaybe<IntFilter>;
  /** Filter by the object’s `countExtrinsicsSigned` field. */
  countExtrinsicsSigned?: InputMaybe<IntFilter>;
  /** Filter by the object’s `countExtrinsicsSuccess` field. */
  countExtrinsicsSuccess?: InputMaybe<IntFilter>;
  /** Filter by the object’s `countExtrinsicsUnsigned` field. */
  countExtrinsicsUnsigned?: InputMaybe<IntFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `datetime` field. */
  datetime?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `extrinsicsRoot` field. */
  extrinsicsRoot?: InputMaybe<StringFilter>;
  /** Filter by the object’s `hash` field. */
  hash?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<BlockFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<BlockFilter>>;
  /** Filter by the object’s `parentHash` field. */
  parentHash?: InputMaybe<StringFilter>;
  /** Filter by the object’s `parentId` field. */
  parentId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `specVersionId` field. */
  specVersionId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `stateRoot` field. */
  stateRoot?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** A connection to a list of `Identity` values, with data from `Account`. */
export type BlockIdentitiesByAccountCreatedBlockIdAndIdentityIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByAccountCreatedBlockIdAndIdentityIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `Account`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByAccountCreatedBlockIdAndIdentityIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `Account`. */
export type BlockIdentitiesByAccountCreatedBlockIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Account`. */
export type BlockIdentitiesByAccountCreatedBlockIdAndIdentityIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByAccountCreatedBlockIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Account`. */
  secondaryAccounts: AccountsConnection;
};

/** A `Identity` edge in the connection, with data from `Account`. */
export type BlockIdentitiesByAccountCreatedBlockIdAndIdentityIdManyToManyEdgeSecondaryAccountsArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AccountFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AccountsOrderBy>>;
  };

/** A connection to a list of `Identity` values, with data from `Account`. */
export type BlockIdentitiesByAccountUpdatedBlockIdAndIdentityIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByAccountUpdatedBlockIdAndIdentityIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `Account`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByAccountUpdatedBlockIdAndIdentityIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `Account`. */
export type BlockIdentitiesByAccountUpdatedBlockIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Account`. */
export type BlockIdentitiesByAccountUpdatedBlockIdAndIdentityIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByAccountUpdatedBlockIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Account`. */
  secondaryAccounts: AccountsConnection;
};

/** A `Identity` edge in the connection, with data from `Account`. */
export type BlockIdentitiesByAccountUpdatedBlockIdAndIdentityIdManyToManyEdgeSecondaryAccountsArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AccountFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AccountsOrderBy>>;
  };

/** A connection to a list of `Identity` values, with data from `Asset`. */
export type BlockIdentitiesByAssetCreatedBlockIdAndOwnerIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByAssetCreatedBlockIdAndOwnerIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `Asset`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByAssetCreatedBlockIdAndOwnerIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `Asset`. */
export type BlockIdentitiesByAssetCreatedBlockIdAndOwnerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Asset`. */
export type BlockIdentitiesByAssetCreatedBlockIdAndOwnerIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByAssetCreatedBlockIdAndOwnerIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByOwnerId: AssetsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
};

/** A `Identity` edge in the connection, with data from `Asset`. */
export type BlockIdentitiesByAssetCreatedBlockIdAndOwnerIdManyToManyEdgeAssetsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/** A connection to a list of `Identity` values, with data from `AssetHolder`. */
export type BlockIdentitiesByAssetHolderCreatedBlockIdAndIdentityIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByAssetHolderCreatedBlockIdAndIdentityIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `AssetHolder`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByAssetHolderCreatedBlockIdAndIdentityIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `AssetHolder`. */
export type BlockIdentitiesByAssetHolderCreatedBlockIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `AssetHolder`. */
export type BlockIdentitiesByAssetHolderCreatedBlockIdAndIdentityIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByAssetHolderCreatedBlockIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `AssetHolder`. */
  heldAssets: AssetHoldersConnection;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
};

/** A `Identity` edge in the connection, with data from `AssetHolder`. */
export type BlockIdentitiesByAssetHolderCreatedBlockIdAndIdentityIdManyToManyEdgeHeldAssetsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetHolderFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetHoldersOrderBy>>;
};

/** A connection to a list of `Identity` values, with data from `AssetHolder`. */
export type BlockIdentitiesByAssetHolderUpdatedBlockIdAndIdentityIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByAssetHolderUpdatedBlockIdAndIdentityIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `AssetHolder`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByAssetHolderUpdatedBlockIdAndIdentityIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `AssetHolder`. */
export type BlockIdentitiesByAssetHolderUpdatedBlockIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `AssetHolder`. */
export type BlockIdentitiesByAssetHolderUpdatedBlockIdAndIdentityIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByAssetHolderUpdatedBlockIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `AssetHolder`. */
  heldAssets: AssetHoldersConnection;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
};

/** A `Identity` edge in the connection, with data from `AssetHolder`. */
export type BlockIdentitiesByAssetHolderUpdatedBlockIdAndIdentityIdManyToManyEdgeHeldAssetsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetHolderFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetHoldersOrderBy>>;
};

/** A connection to a list of `Identity` values, with data from `Asset`. */
export type BlockIdentitiesByAssetUpdatedBlockIdAndOwnerIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByAssetUpdatedBlockIdAndOwnerIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `Asset`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByAssetUpdatedBlockIdAndOwnerIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `Asset`. */
export type BlockIdentitiesByAssetUpdatedBlockIdAndOwnerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Asset`. */
export type BlockIdentitiesByAssetUpdatedBlockIdAndOwnerIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByAssetUpdatedBlockIdAndOwnerIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByOwnerId: AssetsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
};

/** A `Identity` edge in the connection, with data from `Asset`. */
export type BlockIdentitiesByAssetUpdatedBlockIdAndOwnerIdManyToManyEdgeAssetsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/** A connection to a list of `Identity` values, with data from `Authorization`. */
export type BlockIdentitiesByAuthorizationCreatedBlockIdAndFromIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByAuthorizationCreatedBlockIdAndFromIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `Authorization`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByAuthorizationCreatedBlockIdAndFromIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `Authorization`. */
export type BlockIdentitiesByAuthorizationCreatedBlockIdAndFromIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Authorization`. */
export type BlockIdentitiesByAuthorizationCreatedBlockIdAndFromIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByAuthorizationCreatedBlockIdAndFromIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Authorization`. */
  authorizationsByFromId: AuthorizationsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
};

/** A `Identity` edge in the connection, with data from `Authorization`. */
export type BlockIdentitiesByAuthorizationCreatedBlockIdAndFromIdManyToManyEdgeAuthorizationsByFromIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AuthorizationFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AuthorizationsOrderBy>>;
  };

/** A connection to a list of `Identity` values, with data from `Authorization`. */
export type BlockIdentitiesByAuthorizationUpdatedBlockIdAndFromIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByAuthorizationUpdatedBlockIdAndFromIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `Authorization`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByAuthorizationUpdatedBlockIdAndFromIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `Authorization`. */
export type BlockIdentitiesByAuthorizationUpdatedBlockIdAndFromIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Authorization`. */
export type BlockIdentitiesByAuthorizationUpdatedBlockIdAndFromIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByAuthorizationUpdatedBlockIdAndFromIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Authorization`. */
  authorizationsByFromId: AuthorizationsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
};

/** A `Identity` edge in the connection, with data from `Authorization`. */
export type BlockIdentitiesByAuthorizationUpdatedBlockIdAndFromIdManyToManyEdgeAuthorizationsByFromIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AuthorizationFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AuthorizationsOrderBy>>;
  };

/** A connection to a list of `Identity` values, with data from `BridgeEvent`. */
export type BlockIdentitiesByBridgeEventCreatedBlockIdAndIdentityIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByBridgeEventCreatedBlockIdAndIdentityIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `BridgeEvent`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByBridgeEventCreatedBlockIdAndIdentityIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `BridgeEvent`. */
export type BlockIdentitiesByBridgeEventCreatedBlockIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `BridgeEvent`. */
export type BlockIdentitiesByBridgeEventCreatedBlockIdAndIdentityIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByBridgeEventCreatedBlockIdAndIdentityIdManyToManyEdge';
  /** Reads and enables pagination through a set of `BridgeEvent`. */
  bridgeEvents: BridgeEventsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
};

/** A `Identity` edge in the connection, with data from `BridgeEvent`. */
export type BlockIdentitiesByBridgeEventCreatedBlockIdAndIdentityIdManyToManyEdgeBridgeEventsArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<BridgeEventFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<BridgeEventsOrderBy>>;
  };

/** A connection to a list of `Identity` values, with data from `BridgeEvent`. */
export type BlockIdentitiesByBridgeEventUpdatedBlockIdAndIdentityIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByBridgeEventUpdatedBlockIdAndIdentityIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `BridgeEvent`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByBridgeEventUpdatedBlockIdAndIdentityIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `BridgeEvent`. */
export type BlockIdentitiesByBridgeEventUpdatedBlockIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `BridgeEvent`. */
export type BlockIdentitiesByBridgeEventUpdatedBlockIdAndIdentityIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByBridgeEventUpdatedBlockIdAndIdentityIdManyToManyEdge';
  /** Reads and enables pagination through a set of `BridgeEvent`. */
  bridgeEvents: BridgeEventsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
};

/** A `Identity` edge in the connection, with data from `BridgeEvent`. */
export type BlockIdentitiesByBridgeEventUpdatedBlockIdAndIdentityIdManyToManyEdgeBridgeEventsArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<BridgeEventFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<BridgeEventsOrderBy>>;
  };

/** A connection to a list of `Identity` values, with data from `ChildIdentity`. */
export type BlockIdentitiesByChildIdentityCreatedBlockIdAndChildIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByChildIdentityCreatedBlockIdAndChildIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `ChildIdentity`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByChildIdentityCreatedBlockIdAndChildIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `ChildIdentity`. */
export type BlockIdentitiesByChildIdentityCreatedBlockIdAndChildIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `ChildIdentity`. */
export type BlockIdentitiesByChildIdentityCreatedBlockIdAndChildIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByChildIdentityCreatedBlockIdAndChildIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `ChildIdentity`. */
  parentChildIdentities: ChildIdentitiesConnection;
};

/** A `Identity` edge in the connection, with data from `ChildIdentity`. */
export type BlockIdentitiesByChildIdentityCreatedBlockIdAndChildIdManyToManyEdgeParentChildIdentitiesArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<ChildIdentityFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<ChildIdentitiesOrderBy>>;
  };

/** A connection to a list of `Identity` values, with data from `ChildIdentity`. */
export type BlockIdentitiesByChildIdentityCreatedBlockIdAndParentIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByChildIdentityCreatedBlockIdAndParentIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `ChildIdentity`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByChildIdentityCreatedBlockIdAndParentIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `ChildIdentity`. */
export type BlockIdentitiesByChildIdentityCreatedBlockIdAndParentIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `ChildIdentity`. */
export type BlockIdentitiesByChildIdentityCreatedBlockIdAndParentIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByChildIdentityCreatedBlockIdAndParentIdManyToManyEdge';
  /** Reads and enables pagination through a set of `ChildIdentity`. */
  children: ChildIdentitiesConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
};

/** A `Identity` edge in the connection, with data from `ChildIdentity`. */
export type BlockIdentitiesByChildIdentityCreatedBlockIdAndParentIdManyToManyEdgeChildrenArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ChildIdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ChildIdentitiesOrderBy>>;
};

/** A connection to a list of `Identity` values, with data from `ChildIdentity`. */
export type BlockIdentitiesByChildIdentityUpdatedBlockIdAndChildIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByChildIdentityUpdatedBlockIdAndChildIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `ChildIdentity`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByChildIdentityUpdatedBlockIdAndChildIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `ChildIdentity`. */
export type BlockIdentitiesByChildIdentityUpdatedBlockIdAndChildIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `ChildIdentity`. */
export type BlockIdentitiesByChildIdentityUpdatedBlockIdAndChildIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByChildIdentityUpdatedBlockIdAndChildIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `ChildIdentity`. */
  parentChildIdentities: ChildIdentitiesConnection;
};

/** A `Identity` edge in the connection, with data from `ChildIdentity`. */
export type BlockIdentitiesByChildIdentityUpdatedBlockIdAndChildIdManyToManyEdgeParentChildIdentitiesArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<ChildIdentityFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<ChildIdentitiesOrderBy>>;
  };

/** A connection to a list of `Identity` values, with data from `ChildIdentity`. */
export type BlockIdentitiesByChildIdentityUpdatedBlockIdAndParentIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByChildIdentityUpdatedBlockIdAndParentIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `ChildIdentity`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByChildIdentityUpdatedBlockIdAndParentIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `ChildIdentity`. */
export type BlockIdentitiesByChildIdentityUpdatedBlockIdAndParentIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `ChildIdentity`. */
export type BlockIdentitiesByChildIdentityUpdatedBlockIdAndParentIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByChildIdentityUpdatedBlockIdAndParentIdManyToManyEdge';
  /** Reads and enables pagination through a set of `ChildIdentity`. */
  children: ChildIdentitiesConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
};

/** A `Identity` edge in the connection, with data from `ChildIdentity`. */
export type BlockIdentitiesByChildIdentityUpdatedBlockIdAndParentIdManyToManyEdgeChildrenArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ChildIdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ChildIdentitiesOrderBy>>;
};

/** A connection to a list of `Identity` values, with data from `Claim`. */
export type BlockIdentitiesByClaimCreatedBlockIdAndIssuerIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByClaimCreatedBlockIdAndIssuerIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `Claim`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByClaimCreatedBlockIdAndIssuerIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `Claim`. */
export type BlockIdentitiesByClaimCreatedBlockIdAndIssuerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Claim`. */
export type BlockIdentitiesByClaimCreatedBlockIdAndIssuerIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByClaimCreatedBlockIdAndIssuerIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Claim`. */
  claimsByIssuerId: ClaimsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
};

/** A `Identity` edge in the connection, with data from `Claim`. */
export type BlockIdentitiesByClaimCreatedBlockIdAndIssuerIdManyToManyEdgeClaimsByIssuerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ClaimFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClaimsOrderBy>>;
};

/** A connection to a list of `Identity` values, with data from `Claim`. */
export type BlockIdentitiesByClaimCreatedBlockIdAndTargetIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByClaimCreatedBlockIdAndTargetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `Claim`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByClaimCreatedBlockIdAndTargetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `Claim`. */
export type BlockIdentitiesByClaimCreatedBlockIdAndTargetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Claim`. */
export type BlockIdentitiesByClaimCreatedBlockIdAndTargetIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByClaimCreatedBlockIdAndTargetIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Claim`. */
  claimsByTargetId: ClaimsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
};

/** A `Identity` edge in the connection, with data from `Claim`. */
export type BlockIdentitiesByClaimCreatedBlockIdAndTargetIdManyToManyEdgeClaimsByTargetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ClaimFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClaimsOrderBy>>;
};

/** A connection to a list of `Identity` values, with data from `Claim`. */
export type BlockIdentitiesByClaimUpdatedBlockIdAndIssuerIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByClaimUpdatedBlockIdAndIssuerIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `Claim`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByClaimUpdatedBlockIdAndIssuerIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `Claim`. */
export type BlockIdentitiesByClaimUpdatedBlockIdAndIssuerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Claim`. */
export type BlockIdentitiesByClaimUpdatedBlockIdAndIssuerIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByClaimUpdatedBlockIdAndIssuerIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Claim`. */
  claimsByIssuerId: ClaimsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
};

/** A `Identity` edge in the connection, with data from `Claim`. */
export type BlockIdentitiesByClaimUpdatedBlockIdAndIssuerIdManyToManyEdgeClaimsByIssuerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ClaimFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClaimsOrderBy>>;
};

/** A connection to a list of `Identity` values, with data from `Claim`. */
export type BlockIdentitiesByClaimUpdatedBlockIdAndTargetIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByClaimUpdatedBlockIdAndTargetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `Claim`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByClaimUpdatedBlockIdAndTargetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `Claim`. */
export type BlockIdentitiesByClaimUpdatedBlockIdAndTargetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Claim`. */
export type BlockIdentitiesByClaimUpdatedBlockIdAndTargetIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByClaimUpdatedBlockIdAndTargetIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Claim`. */
  claimsByTargetId: ClaimsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
};

/** A `Identity` edge in the connection, with data from `Claim`. */
export type BlockIdentitiesByClaimUpdatedBlockIdAndTargetIdManyToManyEdgeClaimsByTargetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ClaimFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClaimsOrderBy>>;
};

/** A connection to a list of `Identity` values, with data from `Distribution`. */
export type BlockIdentitiesByDistributionCreatedBlockIdAndIdentityIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByDistributionCreatedBlockIdAndIdentityIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByDistributionCreatedBlockIdAndIdentityIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `Distribution`. */
export type BlockIdentitiesByDistributionCreatedBlockIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Distribution`. */
export type BlockIdentitiesByDistributionCreatedBlockIdAndIdentityIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByDistributionCreatedBlockIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributions: DistributionsConnection;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
};

/** A `Identity` edge in the connection, with data from `Distribution`. */
export type BlockIdentitiesByDistributionCreatedBlockIdAndIdentityIdManyToManyEdgeDistributionsArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<DistributionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<DistributionsOrderBy>>;
  };

/** A connection to a list of `Identity` values, with data from `DistributionPayment`. */
export type BlockIdentitiesByDistributionPaymentCreatedBlockIdAndTargetIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByDistributionPaymentCreatedBlockIdAndTargetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `DistributionPayment`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByDistributionPaymentCreatedBlockIdAndTargetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `DistributionPayment`. */
export type BlockIdentitiesByDistributionPaymentCreatedBlockIdAndTargetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `DistributionPayment`. */
export type BlockIdentitiesByDistributionPaymentCreatedBlockIdAndTargetIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByDistributionPaymentCreatedBlockIdAndTargetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `DistributionPayment`. */
  distributionPaymentsByTargetId: DistributionPaymentsConnection;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
};

/** A `Identity` edge in the connection, with data from `DistributionPayment`. */
export type BlockIdentitiesByDistributionPaymentCreatedBlockIdAndTargetIdManyToManyEdgeDistributionPaymentsByTargetIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<DistributionPaymentFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<DistributionPaymentsOrderBy>>;
  };

/** A connection to a list of `Identity` values, with data from `DistributionPayment`. */
export type BlockIdentitiesByDistributionPaymentUpdatedBlockIdAndTargetIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByDistributionPaymentUpdatedBlockIdAndTargetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `DistributionPayment`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByDistributionPaymentUpdatedBlockIdAndTargetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `DistributionPayment`. */
export type BlockIdentitiesByDistributionPaymentUpdatedBlockIdAndTargetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `DistributionPayment`. */
export type BlockIdentitiesByDistributionPaymentUpdatedBlockIdAndTargetIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByDistributionPaymentUpdatedBlockIdAndTargetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `DistributionPayment`. */
  distributionPaymentsByTargetId: DistributionPaymentsConnection;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
};

/** A `Identity` edge in the connection, with data from `DistributionPayment`. */
export type BlockIdentitiesByDistributionPaymentUpdatedBlockIdAndTargetIdManyToManyEdgeDistributionPaymentsByTargetIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<DistributionPaymentFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<DistributionPaymentsOrderBy>>;
  };

/** A connection to a list of `Identity` values, with data from `Distribution`. */
export type BlockIdentitiesByDistributionUpdatedBlockIdAndIdentityIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByDistributionUpdatedBlockIdAndIdentityIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByDistributionUpdatedBlockIdAndIdentityIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `Distribution`. */
export type BlockIdentitiesByDistributionUpdatedBlockIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Distribution`. */
export type BlockIdentitiesByDistributionUpdatedBlockIdAndIdentityIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByDistributionUpdatedBlockIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributions: DistributionsConnection;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
};

/** A `Identity` edge in the connection, with data from `Distribution`. */
export type BlockIdentitiesByDistributionUpdatedBlockIdAndIdentityIdManyToManyEdgeDistributionsArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<DistributionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<DistributionsOrderBy>>;
  };

/** A connection to a list of `Identity` values, with data from `Investment`. */
export type BlockIdentitiesByInvestmentCreatedBlockIdAndInvestorIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByInvestmentCreatedBlockIdAndInvestorIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `Investment`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByInvestmentCreatedBlockIdAndInvestorIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `Investment`. */
export type BlockIdentitiesByInvestmentCreatedBlockIdAndInvestorIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Investment`. */
export type BlockIdentitiesByInvestmentCreatedBlockIdAndInvestorIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByInvestmentCreatedBlockIdAndInvestorIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Investment`. */
  investmentsByInvestorId: InvestmentsConnection;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
};

/** A `Identity` edge in the connection, with data from `Investment`. */
export type BlockIdentitiesByInvestmentCreatedBlockIdAndInvestorIdManyToManyEdgeInvestmentsByInvestorIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<InvestmentFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<InvestmentsOrderBy>>;
  };

/** A connection to a list of `Identity` values, with data from `Investment`. */
export type BlockIdentitiesByInvestmentUpdatedBlockIdAndInvestorIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByInvestmentUpdatedBlockIdAndInvestorIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `Investment`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByInvestmentUpdatedBlockIdAndInvestorIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `Investment`. */
export type BlockIdentitiesByInvestmentUpdatedBlockIdAndInvestorIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Investment`. */
export type BlockIdentitiesByInvestmentUpdatedBlockIdAndInvestorIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByInvestmentUpdatedBlockIdAndInvestorIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Investment`. */
  investmentsByInvestorId: InvestmentsConnection;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
};

/** A `Identity` edge in the connection, with data from `Investment`. */
export type BlockIdentitiesByInvestmentUpdatedBlockIdAndInvestorIdManyToManyEdgeInvestmentsByInvestorIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<InvestmentFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<InvestmentsOrderBy>>;
  };

/** A connection to a list of `Identity` values, with data from `Portfolio`. */
export type BlockIdentitiesByPortfolioCreatedBlockIdAndCustodianIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByPortfolioCreatedBlockIdAndCustodianIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `Portfolio`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByPortfolioCreatedBlockIdAndCustodianIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `Portfolio`. */
export type BlockIdentitiesByPortfolioCreatedBlockIdAndCustodianIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Portfolio`. */
export type BlockIdentitiesByPortfolioCreatedBlockIdAndCustodianIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByPortfolioCreatedBlockIdAndCustodianIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByCustodianId: PortfoliosConnection;
};

/** A `Identity` edge in the connection, with data from `Portfolio`. */
export type BlockIdentitiesByPortfolioCreatedBlockIdAndCustodianIdManyToManyEdgePortfoliosByCustodianIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<PortfolioFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
  };

/** A connection to a list of `Identity` values, with data from `Portfolio`. */
export type BlockIdentitiesByPortfolioCreatedBlockIdAndIdentityIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByPortfolioCreatedBlockIdAndIdentityIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `Portfolio`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByPortfolioCreatedBlockIdAndIdentityIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `Portfolio`. */
export type BlockIdentitiesByPortfolioCreatedBlockIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Portfolio`. */
export type BlockIdentitiesByPortfolioCreatedBlockIdAndIdentityIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByPortfolioCreatedBlockIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfolios: PortfoliosConnection;
};

/** A `Identity` edge in the connection, with data from `Portfolio`. */
export type BlockIdentitiesByPortfolioCreatedBlockIdAndIdentityIdManyToManyEdgePortfoliosArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/** A connection to a list of `Identity` values, with data from `Portfolio`. */
export type BlockIdentitiesByPortfolioUpdatedBlockIdAndCustodianIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByPortfolioUpdatedBlockIdAndCustodianIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `Portfolio`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByPortfolioUpdatedBlockIdAndCustodianIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `Portfolio`. */
export type BlockIdentitiesByPortfolioUpdatedBlockIdAndCustodianIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Portfolio`. */
export type BlockIdentitiesByPortfolioUpdatedBlockIdAndCustodianIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByPortfolioUpdatedBlockIdAndCustodianIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByCustodianId: PortfoliosConnection;
};

/** A `Identity` edge in the connection, with data from `Portfolio`. */
export type BlockIdentitiesByPortfolioUpdatedBlockIdAndCustodianIdManyToManyEdgePortfoliosByCustodianIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<PortfolioFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
  };

/** A connection to a list of `Identity` values, with data from `Portfolio`. */
export type BlockIdentitiesByPortfolioUpdatedBlockIdAndIdentityIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByPortfolioUpdatedBlockIdAndIdentityIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `Portfolio`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByPortfolioUpdatedBlockIdAndIdentityIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `Portfolio`. */
export type BlockIdentitiesByPortfolioUpdatedBlockIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Portfolio`. */
export type BlockIdentitiesByPortfolioUpdatedBlockIdAndIdentityIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByPortfolioUpdatedBlockIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfolios: PortfoliosConnection;
};

/** A `Identity` edge in the connection, with data from `Portfolio`. */
export type BlockIdentitiesByPortfolioUpdatedBlockIdAndIdentityIdManyToManyEdgePortfoliosArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/** A connection to a list of `Identity` values, with data from `Proposal`. */
export type BlockIdentitiesByProposalCreatedBlockIdAndOwnerIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByProposalCreatedBlockIdAndOwnerIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `Proposal`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByProposalCreatedBlockIdAndOwnerIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `Proposal`. */
export type BlockIdentitiesByProposalCreatedBlockIdAndOwnerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Proposal`. */
export type BlockIdentitiesByProposalCreatedBlockIdAndOwnerIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByProposalCreatedBlockIdAndOwnerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Proposal`. */
  proposalsByOwnerId: ProposalsConnection;
};

/** A `Identity` edge in the connection, with data from `Proposal`. */
export type BlockIdentitiesByProposalCreatedBlockIdAndOwnerIdManyToManyEdgeProposalsByOwnerIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<ProposalFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<ProposalsOrderBy>>;
  };

/** A connection to a list of `Identity` values, with data from `Proposal`. */
export type BlockIdentitiesByProposalUpdatedBlockIdAndOwnerIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByProposalUpdatedBlockIdAndOwnerIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `Proposal`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByProposalUpdatedBlockIdAndOwnerIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `Proposal`. */
export type BlockIdentitiesByProposalUpdatedBlockIdAndOwnerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Proposal`. */
export type BlockIdentitiesByProposalUpdatedBlockIdAndOwnerIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByProposalUpdatedBlockIdAndOwnerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Proposal`. */
  proposalsByOwnerId: ProposalsConnection;
};

/** A `Identity` edge in the connection, with data from `Proposal`. */
export type BlockIdentitiesByProposalUpdatedBlockIdAndOwnerIdManyToManyEdgeProposalsByOwnerIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<ProposalFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<ProposalsOrderBy>>;
  };

/** A connection to a list of `Identity` values, with data from `StakingEvent`. */
export type BlockIdentitiesByStakingEventCreatedBlockIdAndIdentityIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByStakingEventCreatedBlockIdAndIdentityIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `StakingEvent`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByStakingEventCreatedBlockIdAndIdentityIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `StakingEvent`. */
export type BlockIdentitiesByStakingEventCreatedBlockIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `StakingEvent`. */
export type BlockIdentitiesByStakingEventCreatedBlockIdAndIdentityIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByStakingEventCreatedBlockIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `StakingEvent`. */
  stakingEvents: StakingEventsConnection;
};

/** A `Identity` edge in the connection, with data from `StakingEvent`. */
export type BlockIdentitiesByStakingEventCreatedBlockIdAndIdentityIdManyToManyEdgeStakingEventsArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StakingEventFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StakingEventsOrderBy>>;
  };

/** A connection to a list of `Identity` values, with data from `StakingEvent`. */
export type BlockIdentitiesByStakingEventUpdatedBlockIdAndIdentityIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByStakingEventUpdatedBlockIdAndIdentityIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `StakingEvent`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByStakingEventUpdatedBlockIdAndIdentityIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `StakingEvent`. */
export type BlockIdentitiesByStakingEventUpdatedBlockIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `StakingEvent`. */
export type BlockIdentitiesByStakingEventUpdatedBlockIdAndIdentityIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByStakingEventUpdatedBlockIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `StakingEvent`. */
  stakingEvents: StakingEventsConnection;
};

/** A `Identity` edge in the connection, with data from `StakingEvent`. */
export type BlockIdentitiesByStakingEventUpdatedBlockIdAndIdentityIdManyToManyEdgeStakingEventsArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StakingEventFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StakingEventsOrderBy>>;
  };

/** A connection to a list of `Identity` values, with data from `StatType`. */
export type BlockIdentitiesByStatTypeCreatedBlockIdAndClaimIssuerIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByStatTypeCreatedBlockIdAndClaimIssuerIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `StatType`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByStatTypeCreatedBlockIdAndClaimIssuerIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `StatType`. */
export type BlockIdentitiesByStatTypeCreatedBlockIdAndClaimIssuerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `StatType`. */
export type BlockIdentitiesByStatTypeCreatedBlockIdAndClaimIssuerIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByStatTypeCreatedBlockIdAndClaimIssuerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypesByClaimIssuerId: StatTypesConnection;
};

/** A `Identity` edge in the connection, with data from `StatType`. */
export type BlockIdentitiesByStatTypeCreatedBlockIdAndClaimIssuerIdManyToManyEdgeStatTypesByClaimIssuerIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StatTypeFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StatTypesOrderBy>>;
  };

/** A connection to a list of `Identity` values, with data from `StatType`. */
export type BlockIdentitiesByStatTypeUpdatedBlockIdAndClaimIssuerIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByStatTypeUpdatedBlockIdAndClaimIssuerIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `StatType`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByStatTypeUpdatedBlockIdAndClaimIssuerIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `StatType`. */
export type BlockIdentitiesByStatTypeUpdatedBlockIdAndClaimIssuerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `StatType`. */
export type BlockIdentitiesByStatTypeUpdatedBlockIdAndClaimIssuerIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByStatTypeUpdatedBlockIdAndClaimIssuerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypesByClaimIssuerId: StatTypesConnection;
};

/** A `Identity` edge in the connection, with data from `StatType`. */
export type BlockIdentitiesByStatTypeUpdatedBlockIdAndClaimIssuerIdManyToManyEdgeStatTypesByClaimIssuerIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StatTypeFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StatTypesOrderBy>>;
  };

/** A connection to a list of `Identity` values, with data from `Sto`. */
export type BlockIdentitiesByStoCreatedBlockIdAndCreatorIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByStoCreatedBlockIdAndCreatorIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByStoCreatedBlockIdAndCreatorIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `Sto`. */
export type BlockIdentitiesByStoCreatedBlockIdAndCreatorIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Sto`. */
export type BlockIdentitiesByStoCreatedBlockIdAndCreatorIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByStoCreatedBlockIdAndCreatorIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByCreatorId: StosConnection;
};

/** A `Identity` edge in the connection, with data from `Sto`. */
export type BlockIdentitiesByStoCreatedBlockIdAndCreatorIdManyToManyEdgeStosByCreatorIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StoFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StosOrderBy>>;
};

/** A connection to a list of `Identity` values, with data from `Sto`. */
export type BlockIdentitiesByStoUpdatedBlockIdAndCreatorIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByStoUpdatedBlockIdAndCreatorIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByStoUpdatedBlockIdAndCreatorIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `Sto`. */
export type BlockIdentitiesByStoUpdatedBlockIdAndCreatorIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Sto`. */
export type BlockIdentitiesByStoUpdatedBlockIdAndCreatorIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByStoUpdatedBlockIdAndCreatorIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByCreatorId: StosConnection;
};

/** A `Identity` edge in the connection, with data from `Sto`. */
export type BlockIdentitiesByStoUpdatedBlockIdAndCreatorIdManyToManyEdgeStosByCreatorIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StoFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StosOrderBy>>;
};

/** A connection to a list of `Identity` values, with data from `TickerExternalAgentAction`. */
export type BlockIdentitiesByTickerExternalAgentActionCreatedBlockIdAndCallerIdManyToManyConnection =
  {
    __typename?: 'BlockIdentitiesByTickerExternalAgentActionCreatedBlockIdAndCallerIdManyToManyConnection';
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<IdentityAggregates>;
    /** A list of edges which contains the `Identity`, info from the `TickerExternalAgentAction`, and the cursor to aid in pagination. */
    edges: Array<BlockIdentitiesByTickerExternalAgentActionCreatedBlockIdAndCallerIdManyToManyEdge>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<IdentityAggregates>>;
    /** A list of `Identity` objects. */
    nodes: Array<Maybe<Identity>>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Identity` you could get from the connection. */
    totalCount: Scalars['Int']['output'];
  };

/** A connection to a list of `Identity` values, with data from `TickerExternalAgentAction`. */
export type BlockIdentitiesByTickerExternalAgentActionCreatedBlockIdAndCallerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `TickerExternalAgentAction`. */
export type BlockIdentitiesByTickerExternalAgentActionCreatedBlockIdAndCallerIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByTickerExternalAgentActionCreatedBlockIdAndCallerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `TickerExternalAgentAction`. */
  tickerExternalAgentActionsByCallerId: TickerExternalAgentActionsConnection;
};

/** A `Identity` edge in the connection, with data from `TickerExternalAgentAction`. */
export type BlockIdentitiesByTickerExternalAgentActionCreatedBlockIdAndCallerIdManyToManyEdgeTickerExternalAgentActionsByCallerIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TickerExternalAgentActionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TickerExternalAgentActionsOrderBy>>;
  };

/** A connection to a list of `Identity` values, with data from `TickerExternalAgentAction`. */
export type BlockIdentitiesByTickerExternalAgentActionUpdatedBlockIdAndCallerIdManyToManyConnection =
  {
    __typename?: 'BlockIdentitiesByTickerExternalAgentActionUpdatedBlockIdAndCallerIdManyToManyConnection';
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<IdentityAggregates>;
    /** A list of edges which contains the `Identity`, info from the `TickerExternalAgentAction`, and the cursor to aid in pagination. */
    edges: Array<BlockIdentitiesByTickerExternalAgentActionUpdatedBlockIdAndCallerIdManyToManyEdge>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<IdentityAggregates>>;
    /** A list of `Identity` objects. */
    nodes: Array<Maybe<Identity>>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Identity` you could get from the connection. */
    totalCount: Scalars['Int']['output'];
  };

/** A connection to a list of `Identity` values, with data from `TickerExternalAgentAction`. */
export type BlockIdentitiesByTickerExternalAgentActionUpdatedBlockIdAndCallerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `TickerExternalAgentAction`. */
export type BlockIdentitiesByTickerExternalAgentActionUpdatedBlockIdAndCallerIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByTickerExternalAgentActionUpdatedBlockIdAndCallerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `TickerExternalAgentAction`. */
  tickerExternalAgentActionsByCallerId: TickerExternalAgentActionsConnection;
};

/** A `Identity` edge in the connection, with data from `TickerExternalAgentAction`. */
export type BlockIdentitiesByTickerExternalAgentActionUpdatedBlockIdAndCallerIdManyToManyEdgeTickerExternalAgentActionsByCallerIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TickerExternalAgentActionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TickerExternalAgentActionsOrderBy>>;
  };

/** A connection to a list of `Identity` values, with data from `TickerExternalAgent`. */
export type BlockIdentitiesByTickerExternalAgentCreatedBlockIdAndCallerIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByTickerExternalAgentCreatedBlockIdAndCallerIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `TickerExternalAgent`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByTickerExternalAgentCreatedBlockIdAndCallerIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `TickerExternalAgent`. */
export type BlockIdentitiesByTickerExternalAgentCreatedBlockIdAndCallerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `TickerExternalAgent`. */
export type BlockIdentitiesByTickerExternalAgentCreatedBlockIdAndCallerIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByTickerExternalAgentCreatedBlockIdAndCallerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `TickerExternalAgent`. */
  tickerExternalAgentsByCallerId: TickerExternalAgentsConnection;
};

/** A `Identity` edge in the connection, with data from `TickerExternalAgent`. */
export type BlockIdentitiesByTickerExternalAgentCreatedBlockIdAndCallerIdManyToManyEdgeTickerExternalAgentsByCallerIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TickerExternalAgentFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TickerExternalAgentsOrderBy>>;
  };

/** A connection to a list of `Identity` values, with data from `TickerExternalAgentHistory`. */
export type BlockIdentitiesByTickerExternalAgentHistoryCreatedBlockIdAndIdentityIdManyToManyConnection =
  {
    __typename?: 'BlockIdentitiesByTickerExternalAgentHistoryCreatedBlockIdAndIdentityIdManyToManyConnection';
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<IdentityAggregates>;
    /** A list of edges which contains the `Identity`, info from the `TickerExternalAgentHistory`, and the cursor to aid in pagination. */
    edges: Array<BlockIdentitiesByTickerExternalAgentHistoryCreatedBlockIdAndIdentityIdManyToManyEdge>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<IdentityAggregates>>;
    /** A list of `Identity` objects. */
    nodes: Array<Maybe<Identity>>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Identity` you could get from the connection. */
    totalCount: Scalars['Int']['output'];
  };

/** A connection to a list of `Identity` values, with data from `TickerExternalAgentHistory`. */
export type BlockIdentitiesByTickerExternalAgentHistoryCreatedBlockIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type BlockIdentitiesByTickerExternalAgentHistoryCreatedBlockIdAndIdentityIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByTickerExternalAgentHistoryCreatedBlockIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `TickerExternalAgentHistory`. */
  tickerExternalAgentHistories: TickerExternalAgentHistoriesConnection;
};

/** A `Identity` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type BlockIdentitiesByTickerExternalAgentHistoryCreatedBlockIdAndIdentityIdManyToManyEdgeTickerExternalAgentHistoriesArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TickerExternalAgentHistoryFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TickerExternalAgentHistoriesOrderBy>>;
  };

/** A connection to a list of `Identity` values, with data from `TickerExternalAgentHistory`. */
export type BlockIdentitiesByTickerExternalAgentHistoryUpdatedBlockIdAndIdentityIdManyToManyConnection =
  {
    __typename?: 'BlockIdentitiesByTickerExternalAgentHistoryUpdatedBlockIdAndIdentityIdManyToManyConnection';
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<IdentityAggregates>;
    /** A list of edges which contains the `Identity`, info from the `TickerExternalAgentHistory`, and the cursor to aid in pagination. */
    edges: Array<BlockIdentitiesByTickerExternalAgentHistoryUpdatedBlockIdAndIdentityIdManyToManyEdge>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<IdentityAggregates>>;
    /** A list of `Identity` objects. */
    nodes: Array<Maybe<Identity>>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Identity` you could get from the connection. */
    totalCount: Scalars['Int']['output'];
  };

/** A connection to a list of `Identity` values, with data from `TickerExternalAgentHistory`. */
export type BlockIdentitiesByTickerExternalAgentHistoryUpdatedBlockIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type BlockIdentitiesByTickerExternalAgentHistoryUpdatedBlockIdAndIdentityIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByTickerExternalAgentHistoryUpdatedBlockIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `TickerExternalAgentHistory`. */
  tickerExternalAgentHistories: TickerExternalAgentHistoriesConnection;
};

/** A `Identity` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type BlockIdentitiesByTickerExternalAgentHistoryUpdatedBlockIdAndIdentityIdManyToManyEdgeTickerExternalAgentHistoriesArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TickerExternalAgentHistoryFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TickerExternalAgentHistoriesOrderBy>>;
  };

/** A connection to a list of `Identity` values, with data from `TickerExternalAgent`. */
export type BlockIdentitiesByTickerExternalAgentUpdatedBlockIdAndCallerIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByTickerExternalAgentUpdatedBlockIdAndCallerIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `TickerExternalAgent`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByTickerExternalAgentUpdatedBlockIdAndCallerIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `TickerExternalAgent`. */
export type BlockIdentitiesByTickerExternalAgentUpdatedBlockIdAndCallerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `TickerExternalAgent`. */
export type BlockIdentitiesByTickerExternalAgentUpdatedBlockIdAndCallerIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByTickerExternalAgentUpdatedBlockIdAndCallerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `TickerExternalAgent`. */
  tickerExternalAgentsByCallerId: TickerExternalAgentsConnection;
};

/** A `Identity` edge in the connection, with data from `TickerExternalAgent`. */
export type BlockIdentitiesByTickerExternalAgentUpdatedBlockIdAndCallerIdManyToManyEdgeTickerExternalAgentsByCallerIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TickerExternalAgentFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TickerExternalAgentsOrderBy>>;
  };

/** A connection to a list of `Identity` values, with data from `TransferCompliance`. */
export type BlockIdentitiesByTransferComplianceCreatedBlockIdAndClaimIssuerIdManyToManyConnection =
  {
    __typename?: 'BlockIdentitiesByTransferComplianceCreatedBlockIdAndClaimIssuerIdManyToManyConnection';
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<IdentityAggregates>;
    /** A list of edges which contains the `Identity`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
    edges: Array<BlockIdentitiesByTransferComplianceCreatedBlockIdAndClaimIssuerIdManyToManyEdge>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<IdentityAggregates>>;
    /** A list of `Identity` objects. */
    nodes: Array<Maybe<Identity>>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Identity` you could get from the connection. */
    totalCount: Scalars['Int']['output'];
  };

/** A connection to a list of `Identity` values, with data from `TransferCompliance`. */
export type BlockIdentitiesByTransferComplianceCreatedBlockIdAndClaimIssuerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `TransferCompliance`. */
export type BlockIdentitiesByTransferComplianceCreatedBlockIdAndClaimIssuerIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByTransferComplianceCreatedBlockIdAndClaimIssuerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliancesByClaimIssuerId: TransferCompliancesConnection;
};

/** A `Identity` edge in the connection, with data from `TransferCompliance`. */
export type BlockIdentitiesByTransferComplianceCreatedBlockIdAndClaimIssuerIdManyToManyEdgeTransferCompliancesByClaimIssuerIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TransferComplianceFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TransferCompliancesOrderBy>>;
  };

/** A connection to a list of `Identity` values, with data from `TransferCompliance`. */
export type BlockIdentitiesByTransferComplianceUpdatedBlockIdAndClaimIssuerIdManyToManyConnection =
  {
    __typename?: 'BlockIdentitiesByTransferComplianceUpdatedBlockIdAndClaimIssuerIdManyToManyConnection';
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<IdentityAggregates>;
    /** A list of edges which contains the `Identity`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
    edges: Array<BlockIdentitiesByTransferComplianceUpdatedBlockIdAndClaimIssuerIdManyToManyEdge>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<IdentityAggregates>>;
    /** A list of `Identity` objects. */
    nodes: Array<Maybe<Identity>>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Identity` you could get from the connection. */
    totalCount: Scalars['Int']['output'];
  };

/** A connection to a list of `Identity` values, with data from `TransferCompliance`. */
export type BlockIdentitiesByTransferComplianceUpdatedBlockIdAndClaimIssuerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `TransferCompliance`. */
export type BlockIdentitiesByTransferComplianceUpdatedBlockIdAndClaimIssuerIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByTransferComplianceUpdatedBlockIdAndClaimIssuerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliancesByClaimIssuerId: TransferCompliancesConnection;
};

/** A `Identity` edge in the connection, with data from `TransferCompliance`. */
export type BlockIdentitiesByTransferComplianceUpdatedBlockIdAndClaimIssuerIdManyToManyEdgeTransferCompliancesByClaimIssuerIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TransferComplianceFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TransferCompliancesOrderBy>>;
  };

/** A connection to a list of `Identity` values, with data from `Venue`. */
export type BlockIdentitiesByVenueCreatedBlockIdAndOwnerIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByVenueCreatedBlockIdAndOwnerIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `Venue`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByVenueCreatedBlockIdAndOwnerIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `Venue`. */
export type BlockIdentitiesByVenueCreatedBlockIdAndOwnerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Venue`. */
export type BlockIdentitiesByVenueCreatedBlockIdAndOwnerIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByVenueCreatedBlockIdAndOwnerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Venue`. */
  venuesByOwnerId: VenuesConnection;
};

/** A `Identity` edge in the connection, with data from `Venue`. */
export type BlockIdentitiesByVenueCreatedBlockIdAndOwnerIdManyToManyEdgeVenuesByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<VenueFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VenuesOrderBy>>;
};

/** A connection to a list of `Identity` values, with data from `Venue`. */
export type BlockIdentitiesByVenueUpdatedBlockIdAndOwnerIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByVenueUpdatedBlockIdAndOwnerIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `Venue`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByVenueUpdatedBlockIdAndOwnerIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `Venue`. */
export type BlockIdentitiesByVenueUpdatedBlockIdAndOwnerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Venue`. */
export type BlockIdentitiesByVenueUpdatedBlockIdAndOwnerIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByVenueUpdatedBlockIdAndOwnerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Venue`. */
  venuesByOwnerId: VenuesConnection;
};

/** A `Identity` edge in the connection, with data from `Venue`. */
export type BlockIdentitiesByVenueUpdatedBlockIdAndOwnerIdManyToManyEdgeVenuesByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<VenueFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VenuesOrderBy>>;
};

/** A connection to a list of `Instruction` values, with data from `Leg`. */
export type BlockInstructionsByLegCreatedBlockIdAndInstructionIdManyToManyConnection = {
  __typename?: 'BlockInstructionsByLegCreatedBlockIdAndInstructionIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<InstructionAggregates>;
  /** A list of edges which contains the `Instruction`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<BlockInstructionsByLegCreatedBlockIdAndInstructionIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<InstructionAggregates>>;
  /** A list of `Instruction` objects. */
  nodes: Array<Maybe<Instruction>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Instruction` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Instruction` values, with data from `Leg`. */
export type BlockInstructionsByLegCreatedBlockIdAndInstructionIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<InstructionsGroupBy>;
    having?: InputMaybe<InstructionsHavingInput>;
  };

/** A `Instruction` edge in the connection, with data from `Leg`. */
export type BlockInstructionsByLegCreatedBlockIdAndInstructionIdManyToManyEdge = {
  __typename?: 'BlockInstructionsByLegCreatedBlockIdAndInstructionIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Leg`. */
  legs: LegsConnection;
  /** The `Instruction` at the end of the edge. */
  node?: Maybe<Instruction>;
};

/** A `Instruction` edge in the connection, with data from `Leg`. */
export type BlockInstructionsByLegCreatedBlockIdAndInstructionIdManyToManyEdgeLegsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<LegFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LegsOrderBy>>;
};

/** A connection to a list of `Instruction` values, with data from `Leg`. */
export type BlockInstructionsByLegUpdatedBlockIdAndInstructionIdManyToManyConnection = {
  __typename?: 'BlockInstructionsByLegUpdatedBlockIdAndInstructionIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<InstructionAggregates>;
  /** A list of edges which contains the `Instruction`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<BlockInstructionsByLegUpdatedBlockIdAndInstructionIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<InstructionAggregates>>;
  /** A list of `Instruction` objects. */
  nodes: Array<Maybe<Instruction>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Instruction` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Instruction` values, with data from `Leg`. */
export type BlockInstructionsByLegUpdatedBlockIdAndInstructionIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<InstructionsGroupBy>;
    having?: InputMaybe<InstructionsHavingInput>;
  };

/** A `Instruction` edge in the connection, with data from `Leg`. */
export type BlockInstructionsByLegUpdatedBlockIdAndInstructionIdManyToManyEdge = {
  __typename?: 'BlockInstructionsByLegUpdatedBlockIdAndInstructionIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Leg`. */
  legs: LegsConnection;
  /** The `Instruction` at the end of the edge. */
  node?: Maybe<Instruction>;
};

/** A `Instruction` edge in the connection, with data from `Leg`. */
export type BlockInstructionsByLegUpdatedBlockIdAndInstructionIdManyToManyEdgeLegsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<LegFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LegsOrderBy>>;
};

/** A connection to a list of `Permission` values, with data from `Account`. */
export type BlockPermissionsByAccountCreatedBlockIdAndPermissionsIdManyToManyConnection = {
  __typename?: 'BlockPermissionsByAccountCreatedBlockIdAndPermissionsIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PermissionAggregates>;
  /** A list of edges which contains the `Permission`, info from the `Account`, and the cursor to aid in pagination. */
  edges: Array<BlockPermissionsByAccountCreatedBlockIdAndPermissionsIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PermissionAggregates>>;
  /** A list of `Permission` objects. */
  nodes: Array<Maybe<Permission>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Permission` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Permission` values, with data from `Account`. */
export type BlockPermissionsByAccountCreatedBlockIdAndPermissionsIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PermissionsGroupBy>;
    having?: InputMaybe<PermissionsHavingInput>;
  };

/** A `Permission` edge in the connection, with data from `Account`. */
export type BlockPermissionsByAccountCreatedBlockIdAndPermissionsIdManyToManyEdge = {
  __typename?: 'BlockPermissionsByAccountCreatedBlockIdAndPermissionsIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Account`. */
  accountsByPermissionsId: AccountsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Permission` at the end of the edge. */
  node?: Maybe<Permission>;
};

/** A `Permission` edge in the connection, with data from `Account`. */
export type BlockPermissionsByAccountCreatedBlockIdAndPermissionsIdManyToManyEdgeAccountsByPermissionsIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AccountFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AccountsOrderBy>>;
  };

/** A connection to a list of `Permission` values, with data from `Account`. */
export type BlockPermissionsByAccountUpdatedBlockIdAndPermissionsIdManyToManyConnection = {
  __typename?: 'BlockPermissionsByAccountUpdatedBlockIdAndPermissionsIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PermissionAggregates>;
  /** A list of edges which contains the `Permission`, info from the `Account`, and the cursor to aid in pagination. */
  edges: Array<BlockPermissionsByAccountUpdatedBlockIdAndPermissionsIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PermissionAggregates>>;
  /** A list of `Permission` objects. */
  nodes: Array<Maybe<Permission>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Permission` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Permission` values, with data from `Account`. */
export type BlockPermissionsByAccountUpdatedBlockIdAndPermissionsIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PermissionsGroupBy>;
    having?: InputMaybe<PermissionsHavingInput>;
  };

/** A `Permission` edge in the connection, with data from `Account`. */
export type BlockPermissionsByAccountUpdatedBlockIdAndPermissionsIdManyToManyEdge = {
  __typename?: 'BlockPermissionsByAccountUpdatedBlockIdAndPermissionsIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Account`. */
  accountsByPermissionsId: AccountsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Permission` at the end of the edge. */
  node?: Maybe<Permission>;
};

/** A `Permission` edge in the connection, with data from `Account`. */
export type BlockPermissionsByAccountUpdatedBlockIdAndPermissionsIdManyToManyEdgeAccountsByPermissionsIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AccountFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AccountsOrderBy>>;
  };

/** A connection to a list of `Portfolio` values, with data from `AssetTransaction`. */
export type BlockPortfoliosByAssetTransactionCreatedBlockIdAndFromPortfolioIdManyToManyConnection =
  {
    __typename?: 'BlockPortfoliosByAssetTransactionCreatedBlockIdAndFromPortfolioIdManyToManyConnection';
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<PortfolioAggregates>;
    /** A list of edges which contains the `Portfolio`, info from the `AssetTransaction`, and the cursor to aid in pagination. */
    edges: Array<BlockPortfoliosByAssetTransactionCreatedBlockIdAndFromPortfolioIdManyToManyEdge>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
    /** A list of `Portfolio` objects. */
    nodes: Array<Maybe<Portfolio>>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Portfolio` you could get from the connection. */
    totalCount: Scalars['Int']['output'];
  };

/** A connection to a list of `Portfolio` values, with data from `AssetTransaction`. */
export type BlockPortfoliosByAssetTransactionCreatedBlockIdAndFromPortfolioIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: InputMaybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `AssetTransaction`. */
export type BlockPortfoliosByAssetTransactionCreatedBlockIdAndFromPortfolioIdManyToManyEdge = {
  __typename?: 'BlockPortfoliosByAssetTransactionCreatedBlockIdAndFromPortfolioIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AssetTransaction`. */
  assetTransactionsByFromPortfolioId: AssetTransactionsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
};

/** A `Portfolio` edge in the connection, with data from `AssetTransaction`. */
export type BlockPortfoliosByAssetTransactionCreatedBlockIdAndFromPortfolioIdManyToManyEdgeAssetTransactionsByFromPortfolioIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AssetTransactionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AssetTransactionsOrderBy>>;
  };

/** A connection to a list of `Portfolio` values, with data from `AssetTransaction`. */
export type BlockPortfoliosByAssetTransactionCreatedBlockIdAndToPortfolioIdManyToManyConnection = {
  __typename?: 'BlockPortfoliosByAssetTransactionCreatedBlockIdAndToPortfolioIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `AssetTransaction`, and the cursor to aid in pagination. */
  edges: Array<BlockPortfoliosByAssetTransactionCreatedBlockIdAndToPortfolioIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `AssetTransaction`. */
export type BlockPortfoliosByAssetTransactionCreatedBlockIdAndToPortfolioIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: InputMaybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `AssetTransaction`. */
export type BlockPortfoliosByAssetTransactionCreatedBlockIdAndToPortfolioIdManyToManyEdge = {
  __typename?: 'BlockPortfoliosByAssetTransactionCreatedBlockIdAndToPortfolioIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AssetTransaction`. */
  assetTransactionsByToPortfolioId: AssetTransactionsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
};

/** A `Portfolio` edge in the connection, with data from `AssetTransaction`. */
export type BlockPortfoliosByAssetTransactionCreatedBlockIdAndToPortfolioIdManyToManyEdgeAssetTransactionsByToPortfolioIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AssetTransactionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AssetTransactionsOrderBy>>;
  };

/** A connection to a list of `Portfolio` values, with data from `AssetTransaction`. */
export type BlockPortfoliosByAssetTransactionUpdatedBlockIdAndFromPortfolioIdManyToManyConnection =
  {
    __typename?: 'BlockPortfoliosByAssetTransactionUpdatedBlockIdAndFromPortfolioIdManyToManyConnection';
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<PortfolioAggregates>;
    /** A list of edges which contains the `Portfolio`, info from the `AssetTransaction`, and the cursor to aid in pagination. */
    edges: Array<BlockPortfoliosByAssetTransactionUpdatedBlockIdAndFromPortfolioIdManyToManyEdge>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
    /** A list of `Portfolio` objects. */
    nodes: Array<Maybe<Portfolio>>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Portfolio` you could get from the connection. */
    totalCount: Scalars['Int']['output'];
  };

/** A connection to a list of `Portfolio` values, with data from `AssetTransaction`. */
export type BlockPortfoliosByAssetTransactionUpdatedBlockIdAndFromPortfolioIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: InputMaybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `AssetTransaction`. */
export type BlockPortfoliosByAssetTransactionUpdatedBlockIdAndFromPortfolioIdManyToManyEdge = {
  __typename?: 'BlockPortfoliosByAssetTransactionUpdatedBlockIdAndFromPortfolioIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AssetTransaction`. */
  assetTransactionsByFromPortfolioId: AssetTransactionsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
};

/** A `Portfolio` edge in the connection, with data from `AssetTransaction`. */
export type BlockPortfoliosByAssetTransactionUpdatedBlockIdAndFromPortfolioIdManyToManyEdgeAssetTransactionsByFromPortfolioIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AssetTransactionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AssetTransactionsOrderBy>>;
  };

/** A connection to a list of `Portfolio` values, with data from `AssetTransaction`. */
export type BlockPortfoliosByAssetTransactionUpdatedBlockIdAndToPortfolioIdManyToManyConnection = {
  __typename?: 'BlockPortfoliosByAssetTransactionUpdatedBlockIdAndToPortfolioIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `AssetTransaction`, and the cursor to aid in pagination. */
  edges: Array<BlockPortfoliosByAssetTransactionUpdatedBlockIdAndToPortfolioIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `AssetTransaction`. */
export type BlockPortfoliosByAssetTransactionUpdatedBlockIdAndToPortfolioIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: InputMaybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `AssetTransaction`. */
export type BlockPortfoliosByAssetTransactionUpdatedBlockIdAndToPortfolioIdManyToManyEdge = {
  __typename?: 'BlockPortfoliosByAssetTransactionUpdatedBlockIdAndToPortfolioIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AssetTransaction`. */
  assetTransactionsByToPortfolioId: AssetTransactionsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
};

/** A `Portfolio` edge in the connection, with data from `AssetTransaction`. */
export type BlockPortfoliosByAssetTransactionUpdatedBlockIdAndToPortfolioIdManyToManyEdgeAssetTransactionsByToPortfolioIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AssetTransactionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AssetTransactionsOrderBy>>;
  };

/** A connection to a list of `Portfolio` values, with data from `Distribution`. */
export type BlockPortfoliosByDistributionCreatedBlockIdAndPortfolioIdManyToManyConnection = {
  __typename?: 'BlockPortfoliosByDistributionCreatedBlockIdAndPortfolioIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<BlockPortfoliosByDistributionCreatedBlockIdAndPortfolioIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `Distribution`. */
export type BlockPortfoliosByDistributionCreatedBlockIdAndPortfolioIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: InputMaybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `Distribution`. */
export type BlockPortfoliosByDistributionCreatedBlockIdAndPortfolioIdManyToManyEdge = {
  __typename?: 'BlockPortfoliosByDistributionCreatedBlockIdAndPortfolioIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributions: DistributionsConnection;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
};

/** A `Portfolio` edge in the connection, with data from `Distribution`. */
export type BlockPortfoliosByDistributionCreatedBlockIdAndPortfolioIdManyToManyEdgeDistributionsArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<DistributionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<DistributionsOrderBy>>;
  };

/** A connection to a list of `Portfolio` values, with data from `Distribution`. */
export type BlockPortfoliosByDistributionUpdatedBlockIdAndPortfolioIdManyToManyConnection = {
  __typename?: 'BlockPortfoliosByDistributionUpdatedBlockIdAndPortfolioIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<BlockPortfoliosByDistributionUpdatedBlockIdAndPortfolioIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `Distribution`. */
export type BlockPortfoliosByDistributionUpdatedBlockIdAndPortfolioIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: InputMaybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `Distribution`. */
export type BlockPortfoliosByDistributionUpdatedBlockIdAndPortfolioIdManyToManyEdge = {
  __typename?: 'BlockPortfoliosByDistributionUpdatedBlockIdAndPortfolioIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributions: DistributionsConnection;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
};

/** A `Portfolio` edge in the connection, with data from `Distribution`. */
export type BlockPortfoliosByDistributionUpdatedBlockIdAndPortfolioIdManyToManyEdgeDistributionsArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<DistributionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<DistributionsOrderBy>>;
  };

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type BlockPortfoliosByLegCreatedBlockIdAndFromIdManyToManyConnection = {
  __typename?: 'BlockPortfoliosByLegCreatedBlockIdAndFromIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<BlockPortfoliosByLegCreatedBlockIdAndFromIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type BlockPortfoliosByLegCreatedBlockIdAndFromIdManyToManyConnectionGroupedAggregatesArgs = {
  groupBy: Array<PortfoliosGroupBy>;
  having?: InputMaybe<PortfoliosHavingInput>;
};

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type BlockPortfoliosByLegCreatedBlockIdAndFromIdManyToManyEdge = {
  __typename?: 'BlockPortfoliosByLegCreatedBlockIdAndFromIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByFromId: LegsConnection;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
};

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type BlockPortfoliosByLegCreatedBlockIdAndFromIdManyToManyEdgeLegsByFromIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<LegFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LegsOrderBy>>;
};

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type BlockPortfoliosByLegCreatedBlockIdAndToIdManyToManyConnection = {
  __typename?: 'BlockPortfoliosByLegCreatedBlockIdAndToIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<BlockPortfoliosByLegCreatedBlockIdAndToIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type BlockPortfoliosByLegCreatedBlockIdAndToIdManyToManyConnectionGroupedAggregatesArgs = {
  groupBy: Array<PortfoliosGroupBy>;
  having?: InputMaybe<PortfoliosHavingInput>;
};

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type BlockPortfoliosByLegCreatedBlockIdAndToIdManyToManyEdge = {
  __typename?: 'BlockPortfoliosByLegCreatedBlockIdAndToIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByToId: LegsConnection;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
};

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type BlockPortfoliosByLegCreatedBlockIdAndToIdManyToManyEdgeLegsByToIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<LegFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LegsOrderBy>>;
};

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type BlockPortfoliosByLegUpdatedBlockIdAndFromIdManyToManyConnection = {
  __typename?: 'BlockPortfoliosByLegUpdatedBlockIdAndFromIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<BlockPortfoliosByLegUpdatedBlockIdAndFromIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type BlockPortfoliosByLegUpdatedBlockIdAndFromIdManyToManyConnectionGroupedAggregatesArgs = {
  groupBy: Array<PortfoliosGroupBy>;
  having?: InputMaybe<PortfoliosHavingInput>;
};

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type BlockPortfoliosByLegUpdatedBlockIdAndFromIdManyToManyEdge = {
  __typename?: 'BlockPortfoliosByLegUpdatedBlockIdAndFromIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByFromId: LegsConnection;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
};

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type BlockPortfoliosByLegUpdatedBlockIdAndFromIdManyToManyEdgeLegsByFromIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<LegFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LegsOrderBy>>;
};

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type BlockPortfoliosByLegUpdatedBlockIdAndToIdManyToManyConnection = {
  __typename?: 'BlockPortfoliosByLegUpdatedBlockIdAndToIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<BlockPortfoliosByLegUpdatedBlockIdAndToIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type BlockPortfoliosByLegUpdatedBlockIdAndToIdManyToManyConnectionGroupedAggregatesArgs = {
  groupBy: Array<PortfoliosGroupBy>;
  having?: InputMaybe<PortfoliosHavingInput>;
};

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type BlockPortfoliosByLegUpdatedBlockIdAndToIdManyToManyEdge = {
  __typename?: 'BlockPortfoliosByLegUpdatedBlockIdAndToIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByToId: LegsConnection;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
};

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type BlockPortfoliosByLegUpdatedBlockIdAndToIdManyToManyEdgeLegsByToIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<LegFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LegsOrderBy>>;
};

/** A connection to a list of `Portfolio` values, with data from `PortfolioMovement`. */
export type BlockPortfoliosByPortfolioMovementCreatedBlockIdAndFromIdManyToManyConnection = {
  __typename?: 'BlockPortfoliosByPortfolioMovementCreatedBlockIdAndFromIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<BlockPortfoliosByPortfolioMovementCreatedBlockIdAndFromIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `PortfolioMovement`. */
export type BlockPortfoliosByPortfolioMovementCreatedBlockIdAndFromIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: InputMaybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `PortfolioMovement`. */
export type BlockPortfoliosByPortfolioMovementCreatedBlockIdAndFromIdManyToManyEdge = {
  __typename?: 'BlockPortfoliosByPortfolioMovementCreatedBlockIdAndFromIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByFromId: PortfolioMovementsConnection;
};

/** A `Portfolio` edge in the connection, with data from `PortfolioMovement`. */
export type BlockPortfoliosByPortfolioMovementCreatedBlockIdAndFromIdManyToManyEdgePortfolioMovementsByFromIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<PortfolioMovementFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<PortfolioMovementsOrderBy>>;
  };

/** A connection to a list of `Portfolio` values, with data from `PortfolioMovement`. */
export type BlockPortfoliosByPortfolioMovementCreatedBlockIdAndToIdManyToManyConnection = {
  __typename?: 'BlockPortfoliosByPortfolioMovementCreatedBlockIdAndToIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<BlockPortfoliosByPortfolioMovementCreatedBlockIdAndToIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `PortfolioMovement`. */
export type BlockPortfoliosByPortfolioMovementCreatedBlockIdAndToIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: InputMaybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `PortfolioMovement`. */
export type BlockPortfoliosByPortfolioMovementCreatedBlockIdAndToIdManyToManyEdge = {
  __typename?: 'BlockPortfoliosByPortfolioMovementCreatedBlockIdAndToIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByToId: PortfolioMovementsConnection;
};

/** A `Portfolio` edge in the connection, with data from `PortfolioMovement`. */
export type BlockPortfoliosByPortfolioMovementCreatedBlockIdAndToIdManyToManyEdgePortfolioMovementsByToIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<PortfolioMovementFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<PortfolioMovementsOrderBy>>;
  };

/** A connection to a list of `Portfolio` values, with data from `PortfolioMovement`. */
export type BlockPortfoliosByPortfolioMovementUpdatedBlockIdAndFromIdManyToManyConnection = {
  __typename?: 'BlockPortfoliosByPortfolioMovementUpdatedBlockIdAndFromIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<BlockPortfoliosByPortfolioMovementUpdatedBlockIdAndFromIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `PortfolioMovement`. */
export type BlockPortfoliosByPortfolioMovementUpdatedBlockIdAndFromIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: InputMaybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `PortfolioMovement`. */
export type BlockPortfoliosByPortfolioMovementUpdatedBlockIdAndFromIdManyToManyEdge = {
  __typename?: 'BlockPortfoliosByPortfolioMovementUpdatedBlockIdAndFromIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByFromId: PortfolioMovementsConnection;
};

/** A `Portfolio` edge in the connection, with data from `PortfolioMovement`. */
export type BlockPortfoliosByPortfolioMovementUpdatedBlockIdAndFromIdManyToManyEdgePortfolioMovementsByFromIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<PortfolioMovementFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<PortfolioMovementsOrderBy>>;
  };

/** A connection to a list of `Portfolio` values, with data from `PortfolioMovement`. */
export type BlockPortfoliosByPortfolioMovementUpdatedBlockIdAndToIdManyToManyConnection = {
  __typename?: 'BlockPortfoliosByPortfolioMovementUpdatedBlockIdAndToIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<BlockPortfoliosByPortfolioMovementUpdatedBlockIdAndToIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `PortfolioMovement`. */
export type BlockPortfoliosByPortfolioMovementUpdatedBlockIdAndToIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: InputMaybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `PortfolioMovement`. */
export type BlockPortfoliosByPortfolioMovementUpdatedBlockIdAndToIdManyToManyEdge = {
  __typename?: 'BlockPortfoliosByPortfolioMovementUpdatedBlockIdAndToIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByToId: PortfolioMovementsConnection;
};

/** A `Portfolio` edge in the connection, with data from `PortfolioMovement`. */
export type BlockPortfoliosByPortfolioMovementUpdatedBlockIdAndToIdManyToManyEdgePortfolioMovementsByToIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<PortfolioMovementFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<PortfolioMovementsOrderBy>>;
  };

/** A connection to a list of `Portfolio` values, with data from `Sto`. */
export type BlockPortfoliosByStoCreatedBlockIdAndOfferingPortfolioIdManyToManyConnection = {
  __typename?: 'BlockPortfoliosByStoCreatedBlockIdAndOfferingPortfolioIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<BlockPortfoliosByStoCreatedBlockIdAndOfferingPortfolioIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `Sto`. */
export type BlockPortfoliosByStoCreatedBlockIdAndOfferingPortfolioIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: InputMaybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `Sto`. */
export type BlockPortfoliosByStoCreatedBlockIdAndOfferingPortfolioIdManyToManyEdge = {
  __typename?: 'BlockPortfoliosByStoCreatedBlockIdAndOfferingPortfolioIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByOfferingPortfolioId: StosConnection;
};

/** A `Portfolio` edge in the connection, with data from `Sto`. */
export type BlockPortfoliosByStoCreatedBlockIdAndOfferingPortfolioIdManyToManyEdgeStosByOfferingPortfolioIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StoFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StosOrderBy>>;
  };

/** A connection to a list of `Portfolio` values, with data from `Sto`. */
export type BlockPortfoliosByStoCreatedBlockIdAndRaisingPortfolioIdManyToManyConnection = {
  __typename?: 'BlockPortfoliosByStoCreatedBlockIdAndRaisingPortfolioIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<BlockPortfoliosByStoCreatedBlockIdAndRaisingPortfolioIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `Sto`. */
export type BlockPortfoliosByStoCreatedBlockIdAndRaisingPortfolioIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: InputMaybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `Sto`. */
export type BlockPortfoliosByStoCreatedBlockIdAndRaisingPortfolioIdManyToManyEdge = {
  __typename?: 'BlockPortfoliosByStoCreatedBlockIdAndRaisingPortfolioIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByRaisingPortfolioId: StosConnection;
};

/** A `Portfolio` edge in the connection, with data from `Sto`. */
export type BlockPortfoliosByStoCreatedBlockIdAndRaisingPortfolioIdManyToManyEdgeStosByRaisingPortfolioIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StoFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StosOrderBy>>;
  };

/** A connection to a list of `Portfolio` values, with data from `Sto`. */
export type BlockPortfoliosByStoUpdatedBlockIdAndOfferingPortfolioIdManyToManyConnection = {
  __typename?: 'BlockPortfoliosByStoUpdatedBlockIdAndOfferingPortfolioIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<BlockPortfoliosByStoUpdatedBlockIdAndOfferingPortfolioIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `Sto`. */
export type BlockPortfoliosByStoUpdatedBlockIdAndOfferingPortfolioIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: InputMaybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `Sto`. */
export type BlockPortfoliosByStoUpdatedBlockIdAndOfferingPortfolioIdManyToManyEdge = {
  __typename?: 'BlockPortfoliosByStoUpdatedBlockIdAndOfferingPortfolioIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByOfferingPortfolioId: StosConnection;
};

/** A `Portfolio` edge in the connection, with data from `Sto`. */
export type BlockPortfoliosByStoUpdatedBlockIdAndOfferingPortfolioIdManyToManyEdgeStosByOfferingPortfolioIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StoFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StosOrderBy>>;
  };

/** A connection to a list of `Portfolio` values, with data from `Sto`. */
export type BlockPortfoliosByStoUpdatedBlockIdAndRaisingPortfolioIdManyToManyConnection = {
  __typename?: 'BlockPortfoliosByStoUpdatedBlockIdAndRaisingPortfolioIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<BlockPortfoliosByStoUpdatedBlockIdAndRaisingPortfolioIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `Sto`. */
export type BlockPortfoliosByStoUpdatedBlockIdAndRaisingPortfolioIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: InputMaybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `Sto`. */
export type BlockPortfoliosByStoUpdatedBlockIdAndRaisingPortfolioIdManyToManyEdge = {
  __typename?: 'BlockPortfoliosByStoUpdatedBlockIdAndRaisingPortfolioIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByRaisingPortfolioId: StosConnection;
};

/** A `Portfolio` edge in the connection, with data from `Sto`. */
export type BlockPortfoliosByStoUpdatedBlockIdAndRaisingPortfolioIdManyToManyEdgeStosByRaisingPortfolioIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StoFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StosOrderBy>>;
  };

/** A connection to a list of `Proposal` values, with data from `ProposalVote`. */
export type BlockProposalsByProposalVoteCreatedBlockIdAndProposalIdManyToManyConnection = {
  __typename?: 'BlockProposalsByProposalVoteCreatedBlockIdAndProposalIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<ProposalAggregates>;
  /** A list of edges which contains the `Proposal`, info from the `ProposalVote`, and the cursor to aid in pagination. */
  edges: Array<BlockProposalsByProposalVoteCreatedBlockIdAndProposalIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<ProposalAggregates>>;
  /** A list of `Proposal` objects. */
  nodes: Array<Maybe<Proposal>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Proposal` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Proposal` values, with data from `ProposalVote`. */
export type BlockProposalsByProposalVoteCreatedBlockIdAndProposalIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<ProposalsGroupBy>;
    having?: InputMaybe<ProposalsHavingInput>;
  };

/** A `Proposal` edge in the connection, with data from `ProposalVote`. */
export type BlockProposalsByProposalVoteCreatedBlockIdAndProposalIdManyToManyEdge = {
  __typename?: 'BlockProposalsByProposalVoteCreatedBlockIdAndProposalIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Proposal` at the end of the edge. */
  node?: Maybe<Proposal>;
  /** Reads and enables pagination through a set of `ProposalVote`. */
  votes: ProposalVotesConnection;
};

/** A `Proposal` edge in the connection, with data from `ProposalVote`. */
export type BlockProposalsByProposalVoteCreatedBlockIdAndProposalIdManyToManyEdgeVotesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ProposalVoteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProposalVotesOrderBy>>;
};

/** A connection to a list of `Proposal` values, with data from `ProposalVote`. */
export type BlockProposalsByProposalVoteUpdatedBlockIdAndProposalIdManyToManyConnection = {
  __typename?: 'BlockProposalsByProposalVoteUpdatedBlockIdAndProposalIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<ProposalAggregates>;
  /** A list of edges which contains the `Proposal`, info from the `ProposalVote`, and the cursor to aid in pagination. */
  edges: Array<BlockProposalsByProposalVoteUpdatedBlockIdAndProposalIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<ProposalAggregates>>;
  /** A list of `Proposal` objects. */
  nodes: Array<Maybe<Proposal>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Proposal` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Proposal` values, with data from `ProposalVote`. */
export type BlockProposalsByProposalVoteUpdatedBlockIdAndProposalIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<ProposalsGroupBy>;
    having?: InputMaybe<ProposalsHavingInput>;
  };

/** A `Proposal` edge in the connection, with data from `ProposalVote`. */
export type BlockProposalsByProposalVoteUpdatedBlockIdAndProposalIdManyToManyEdge = {
  __typename?: 'BlockProposalsByProposalVoteUpdatedBlockIdAndProposalIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Proposal` at the end of the edge. */
  node?: Maybe<Proposal>;
  /** Reads and enables pagination through a set of `ProposalVote`. */
  votes: ProposalVotesConnection;
};

/** A `Proposal` edge in the connection, with data from `ProposalVote`. */
export type BlockProposalsByProposalVoteUpdatedBlockIdAndProposalIdManyToManyEdgeVotesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ProposalVoteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProposalVotesOrderBy>>;
};

/** A connection to a list of `Settlement` values, with data from `Leg`. */
export type BlockSettlementsByLegCreatedBlockIdAndSettlementIdManyToManyConnection = {
  __typename?: 'BlockSettlementsByLegCreatedBlockIdAndSettlementIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<SettlementAggregates>;
  /** A list of edges which contains the `Settlement`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<BlockSettlementsByLegCreatedBlockIdAndSettlementIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<SettlementAggregates>>;
  /** A list of `Settlement` objects. */
  nodes: Array<Maybe<Settlement>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Settlement` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Settlement` values, with data from `Leg`. */
export type BlockSettlementsByLegCreatedBlockIdAndSettlementIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<SettlementsGroupBy>;
    having?: InputMaybe<SettlementsHavingInput>;
  };

/** A `Settlement` edge in the connection, with data from `Leg`. */
export type BlockSettlementsByLegCreatedBlockIdAndSettlementIdManyToManyEdge = {
  __typename?: 'BlockSettlementsByLegCreatedBlockIdAndSettlementIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Leg`. */
  legs: LegsConnection;
  /** The `Settlement` at the end of the edge. */
  node?: Maybe<Settlement>;
};

/** A `Settlement` edge in the connection, with data from `Leg`. */
export type BlockSettlementsByLegCreatedBlockIdAndSettlementIdManyToManyEdgeLegsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<LegFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LegsOrderBy>>;
};

/** A connection to a list of `Settlement` values, with data from `Leg`. */
export type BlockSettlementsByLegUpdatedBlockIdAndSettlementIdManyToManyConnection = {
  __typename?: 'BlockSettlementsByLegUpdatedBlockIdAndSettlementIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<SettlementAggregates>;
  /** A list of edges which contains the `Settlement`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<BlockSettlementsByLegUpdatedBlockIdAndSettlementIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<SettlementAggregates>>;
  /** A list of `Settlement` objects. */
  nodes: Array<Maybe<Settlement>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Settlement` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Settlement` values, with data from `Leg`. */
export type BlockSettlementsByLegUpdatedBlockIdAndSettlementIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<SettlementsGroupBy>;
    having?: InputMaybe<SettlementsHavingInput>;
  };

/** A `Settlement` edge in the connection, with data from `Leg`. */
export type BlockSettlementsByLegUpdatedBlockIdAndSettlementIdManyToManyEdge = {
  __typename?: 'BlockSettlementsByLegUpdatedBlockIdAndSettlementIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Leg`. */
  legs: LegsConnection;
  /** The `Settlement` at the end of the edge. */
  node?: Maybe<Settlement>;
};

/** A `Settlement` edge in the connection, with data from `Leg`. */
export type BlockSettlementsByLegUpdatedBlockIdAndSettlementIdManyToManyEdgeLegsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<LegFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LegsOrderBy>>;
};

/** A connection to a list of `StatType` values, with data from `TransferCompliance`. */
export type BlockStatTypesByTransferComplianceCreatedBlockIdAndStatTypeIdManyToManyConnection = {
  __typename?: 'BlockStatTypesByTransferComplianceCreatedBlockIdAndStatTypeIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<StatTypeAggregates>;
  /** A list of edges which contains the `StatType`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
  edges: Array<BlockStatTypesByTransferComplianceCreatedBlockIdAndStatTypeIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<StatTypeAggregates>>;
  /** A list of `StatType` objects. */
  nodes: Array<Maybe<StatType>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `StatType` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `StatType` values, with data from `TransferCompliance`. */
export type BlockStatTypesByTransferComplianceCreatedBlockIdAndStatTypeIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<StatTypesGroupBy>;
    having?: InputMaybe<StatTypesHavingInput>;
  };

/** A `StatType` edge in the connection, with data from `TransferCompliance`. */
export type BlockStatTypesByTransferComplianceCreatedBlockIdAndStatTypeIdManyToManyEdge = {
  __typename?: 'BlockStatTypesByTransferComplianceCreatedBlockIdAndStatTypeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `StatType` at the end of the edge. */
  node?: Maybe<StatType>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliances: TransferCompliancesConnection;
};

/** A `StatType` edge in the connection, with data from `TransferCompliance`. */
export type BlockStatTypesByTransferComplianceCreatedBlockIdAndStatTypeIdManyToManyEdgeTransferCompliancesArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TransferComplianceFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TransferCompliancesOrderBy>>;
  };

/** A connection to a list of `StatType` values, with data from `TransferCompliance`. */
export type BlockStatTypesByTransferComplianceUpdatedBlockIdAndStatTypeIdManyToManyConnection = {
  __typename?: 'BlockStatTypesByTransferComplianceUpdatedBlockIdAndStatTypeIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<StatTypeAggregates>;
  /** A list of edges which contains the `StatType`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
  edges: Array<BlockStatTypesByTransferComplianceUpdatedBlockIdAndStatTypeIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<StatTypeAggregates>>;
  /** A list of `StatType` objects. */
  nodes: Array<Maybe<StatType>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `StatType` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `StatType` values, with data from `TransferCompliance`. */
export type BlockStatTypesByTransferComplianceUpdatedBlockIdAndStatTypeIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<StatTypesGroupBy>;
    having?: InputMaybe<StatTypesHavingInput>;
  };

/** A `StatType` edge in the connection, with data from `TransferCompliance`. */
export type BlockStatTypesByTransferComplianceUpdatedBlockIdAndStatTypeIdManyToManyEdge = {
  __typename?: 'BlockStatTypesByTransferComplianceUpdatedBlockIdAndStatTypeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `StatType` at the end of the edge. */
  node?: Maybe<StatType>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliances: TransferCompliancesConnection;
};

/** A `StatType` edge in the connection, with data from `TransferCompliance`. */
export type BlockStatTypesByTransferComplianceUpdatedBlockIdAndStatTypeIdManyToManyEdgeTransferCompliancesArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TransferComplianceFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TransferCompliancesOrderBy>>;
  };

/** A connection to a list of `Venue` values, with data from `Instruction`. */
export type BlockVenuesByInstructionCreatedBlockIdAndVenueIdManyToManyConnection = {
  __typename?: 'BlockVenuesByInstructionCreatedBlockIdAndVenueIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<VenueAggregates>;
  /** A list of edges which contains the `Venue`, info from the `Instruction`, and the cursor to aid in pagination. */
  edges: Array<BlockVenuesByInstructionCreatedBlockIdAndVenueIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<VenueAggregates>>;
  /** A list of `Venue` objects. */
  nodes: Array<Maybe<Venue>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Venue` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Venue` values, with data from `Instruction`. */
export type BlockVenuesByInstructionCreatedBlockIdAndVenueIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<VenuesGroupBy>;
    having?: InputMaybe<VenuesHavingInput>;
  };

/** A `Venue` edge in the connection, with data from `Instruction`. */
export type BlockVenuesByInstructionCreatedBlockIdAndVenueIdManyToManyEdge = {
  __typename?: 'BlockVenuesByInstructionCreatedBlockIdAndVenueIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Instruction`. */
  instructions: InstructionsConnection;
  /** The `Venue` at the end of the edge. */
  node?: Maybe<Venue>;
};

/** A `Venue` edge in the connection, with data from `Instruction`. */
export type BlockVenuesByInstructionCreatedBlockIdAndVenueIdManyToManyEdgeInstructionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<InstructionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InstructionsOrderBy>>;
};

/** A connection to a list of `Venue` values, with data from `Instruction`. */
export type BlockVenuesByInstructionUpdatedBlockIdAndVenueIdManyToManyConnection = {
  __typename?: 'BlockVenuesByInstructionUpdatedBlockIdAndVenueIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<VenueAggregates>;
  /** A list of edges which contains the `Venue`, info from the `Instruction`, and the cursor to aid in pagination. */
  edges: Array<BlockVenuesByInstructionUpdatedBlockIdAndVenueIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<VenueAggregates>>;
  /** A list of `Venue` objects. */
  nodes: Array<Maybe<Venue>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Venue` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Venue` values, with data from `Instruction`. */
export type BlockVenuesByInstructionUpdatedBlockIdAndVenueIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<VenuesGroupBy>;
    having?: InputMaybe<VenuesHavingInput>;
  };

/** A `Venue` edge in the connection, with data from `Instruction`. */
export type BlockVenuesByInstructionUpdatedBlockIdAndVenueIdManyToManyEdge = {
  __typename?: 'BlockVenuesByInstructionUpdatedBlockIdAndVenueIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Instruction`. */
  instructions: InstructionsConnection;
  /** The `Venue` at the end of the edge. */
  node?: Maybe<Venue>;
};

/** A `Venue` edge in the connection, with data from `Instruction`. */
export type BlockVenuesByInstructionUpdatedBlockIdAndVenueIdManyToManyEdgeInstructionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<InstructionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InstructionsOrderBy>>;
};

/** A connection to a list of `Venue` values, with data from `Sto`. */
export type BlockVenuesByStoCreatedBlockIdAndVenueIdManyToManyConnection = {
  __typename?: 'BlockVenuesByStoCreatedBlockIdAndVenueIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<VenueAggregates>;
  /** A list of edges which contains the `Venue`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<BlockVenuesByStoCreatedBlockIdAndVenueIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<VenueAggregates>>;
  /** A list of `Venue` objects. */
  nodes: Array<Maybe<Venue>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Venue` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Venue` values, with data from `Sto`. */
export type BlockVenuesByStoCreatedBlockIdAndVenueIdManyToManyConnectionGroupedAggregatesArgs = {
  groupBy: Array<VenuesGroupBy>;
  having?: InputMaybe<VenuesHavingInput>;
};

/** A `Venue` edge in the connection, with data from `Sto`. */
export type BlockVenuesByStoCreatedBlockIdAndVenueIdManyToManyEdge = {
  __typename?: 'BlockVenuesByStoCreatedBlockIdAndVenueIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Venue` at the end of the edge. */
  node?: Maybe<Venue>;
  /** Reads and enables pagination through a set of `Sto`. */
  stos: StosConnection;
};

/** A `Venue` edge in the connection, with data from `Sto`. */
export type BlockVenuesByStoCreatedBlockIdAndVenueIdManyToManyEdgeStosArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StoFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StosOrderBy>>;
};

/** A connection to a list of `Venue` values, with data from `Sto`. */
export type BlockVenuesByStoUpdatedBlockIdAndVenueIdManyToManyConnection = {
  __typename?: 'BlockVenuesByStoUpdatedBlockIdAndVenueIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<VenueAggregates>;
  /** A list of edges which contains the `Venue`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<BlockVenuesByStoUpdatedBlockIdAndVenueIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<VenueAggregates>>;
  /** A list of `Venue` objects. */
  nodes: Array<Maybe<Venue>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Venue` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Venue` values, with data from `Sto`. */
export type BlockVenuesByStoUpdatedBlockIdAndVenueIdManyToManyConnectionGroupedAggregatesArgs = {
  groupBy: Array<VenuesGroupBy>;
  having?: InputMaybe<VenuesHavingInput>;
};

/** A `Venue` edge in the connection, with data from `Sto`. */
export type BlockVenuesByStoUpdatedBlockIdAndVenueIdManyToManyEdge = {
  __typename?: 'BlockVenuesByStoUpdatedBlockIdAndVenueIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Venue` at the end of the edge. */
  node?: Maybe<Venue>;
  /** Reads and enables pagination through a set of `Sto`. */
  stos: StosConnection;
};

/** A `Venue` edge in the connection, with data from `Sto`. */
export type BlockVenuesByStoUpdatedBlockIdAndVenueIdManyToManyEdgeStosArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StoFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StosOrderBy>>;
};

/** A connection to a list of `Block` values. */
export type BlocksConnection = {
  __typename?: 'BlocksConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block` and cursor to aid in pagination. */
  edges: Array<BlocksEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values. */
export type BlocksConnectionGroupedAggregatesArgs = {
  groupBy: Array<BlocksGroupBy>;
  having?: InputMaybe<BlocksHavingInput>;
};

/** A `Block` edge in the connection. */
export type BlocksEdge = {
  __typename?: 'BlocksEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** Grouping methods for `Block` for usage during aggregation. */
export enum BlocksGroupBy {
  CountEvents = 'COUNT_EVENTS',
  CountExtrinsics = 'COUNT_EXTRINSICS',
  CountExtrinsicsError = 'COUNT_EXTRINSICS_ERROR',
  CountExtrinsicsSigned = 'COUNT_EXTRINSICS_SIGNED',
  CountExtrinsicsSuccess = 'COUNT_EXTRINSICS_SUCCESS',
  CountExtrinsicsUnsigned = 'COUNT_EXTRINSICS_UNSIGNED',
  CreatedAt = 'CREATED_AT',
  Datetime = 'DATETIME',
  ExtrinsicsRoot = 'EXTRINSICS_ROOT',
  ParentHash = 'PARENT_HASH',
  ParentId = 'PARENT_ID',
  SpecVersionId = 'SPEC_VERSION_ID',
  StateRoot = 'STATE_ROOT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `Block` aggregates. */
export type BlocksHavingInput = {
  AND?: InputMaybe<Array<BlocksHavingInput>>;
  OR?: InputMaybe<Array<BlocksHavingInput>>;
};

/** Methods to use when ordering `Block`. */
export enum BlocksOrderBy {
  AccountsByCreatedBlockIdCountAsc = 'ACCOUNTS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  AccountsByCreatedBlockIdCountDesc = 'ACCOUNTS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  AccountsByUpdatedBlockIdCountAsc = 'ACCOUNTS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  AccountsByUpdatedBlockIdCountDesc = 'ACCOUNTS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  AccountHistoriesByCreatedBlockIdCountAsc = 'ACCOUNT_HISTORIES_BY_CREATED_BLOCK_ID_COUNT_ASC',
  AccountHistoriesByCreatedBlockIdCountDesc = 'ACCOUNT_HISTORIES_BY_CREATED_BLOCK_ID_COUNT_DESC',
  AccountHistoriesByUpdatedBlockIdCountAsc = 'ACCOUNT_HISTORIES_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  AccountHistoriesByUpdatedBlockIdCountDesc = 'ACCOUNT_HISTORIES_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  AgentGroupsByCreatedBlockIdCountAsc = 'AGENT_GROUPS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  AgentGroupsByCreatedBlockIdCountDesc = 'AGENT_GROUPS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  AgentGroupsByUpdatedBlockIdCountAsc = 'AGENT_GROUPS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  AgentGroupsByUpdatedBlockIdCountDesc = 'AGENT_GROUPS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  AgentGroupMembershipsByCreatedBlockIdCountAsc = 'AGENT_GROUP_MEMBERSHIPS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  AgentGroupMembershipsByCreatedBlockIdCountDesc = 'AGENT_GROUP_MEMBERSHIPS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  AgentGroupMembershipsByUpdatedBlockIdCountAsc = 'AGENT_GROUP_MEMBERSHIPS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  AgentGroupMembershipsByUpdatedBlockIdCountDesc = 'AGENT_GROUP_MEMBERSHIPS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  AssetsByCreatedBlockIdCountAsc = 'ASSETS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  AssetsByCreatedBlockIdCountDesc = 'ASSETS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  AssetsByUpdatedBlockIdCountAsc = 'ASSETS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  AssetsByUpdatedBlockIdCountDesc = 'ASSETS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  AssetDocumentsByCreatedBlockIdCountAsc = 'ASSET_DOCUMENTS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  AssetDocumentsByCreatedBlockIdCountDesc = 'ASSET_DOCUMENTS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  AssetDocumentsByUpdatedBlockIdCountAsc = 'ASSET_DOCUMENTS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  AssetDocumentsByUpdatedBlockIdCountDesc = 'ASSET_DOCUMENTS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  AssetHoldersByCreatedBlockIdCountAsc = 'ASSET_HOLDERS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  AssetHoldersByCreatedBlockIdCountDesc = 'ASSET_HOLDERS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  AssetHoldersByUpdatedBlockIdCountAsc = 'ASSET_HOLDERS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  AssetHoldersByUpdatedBlockIdCountDesc = 'ASSET_HOLDERS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  AssetPendingOwnershipTransfersByCreatedBlockIdCountAsc = 'ASSET_PENDING_OWNERSHIP_TRANSFERS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  AssetPendingOwnershipTransfersByCreatedBlockIdCountDesc = 'ASSET_PENDING_OWNERSHIP_TRANSFERS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  AssetPendingOwnershipTransfersByUpdatedBlockIdCountAsc = 'ASSET_PENDING_OWNERSHIP_TRANSFERS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  AssetPendingOwnershipTransfersByUpdatedBlockIdCountDesc = 'ASSET_PENDING_OWNERSHIP_TRANSFERS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  AssetTransactionsByCreatedBlockIdCountAsc = 'ASSET_TRANSACTIONS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  AssetTransactionsByCreatedBlockIdCountDesc = 'ASSET_TRANSACTIONS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  AssetTransactionsByUpdatedBlockIdCountAsc = 'ASSET_TRANSACTIONS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  AssetTransactionsByUpdatedBlockIdCountDesc = 'ASSET_TRANSACTIONS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  AuthorizationsByCreatedBlockIdCountAsc = 'AUTHORIZATIONS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  AuthorizationsByCreatedBlockIdCountDesc = 'AUTHORIZATIONS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  AuthorizationsByUpdatedBlockIdCountAsc = 'AUTHORIZATIONS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  AuthorizationsByUpdatedBlockIdCountDesc = 'AUTHORIZATIONS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  BlockIdAsc = 'BLOCK_ID_ASC',
  BlockIdDesc = 'BLOCK_ID_DESC',
  BridgeEventsByCreatedBlockIdCountAsc = 'BRIDGE_EVENTS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  BridgeEventsByCreatedBlockIdCountDesc = 'BRIDGE_EVENTS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  BridgeEventsByUpdatedBlockIdCountAsc = 'BRIDGE_EVENTS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  BridgeEventsByUpdatedBlockIdCountDesc = 'BRIDGE_EVENTS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  ChildIdentitiesByCreatedBlockIdCountAsc = 'CHILD_IDENTITIES_BY_CREATED_BLOCK_ID_COUNT_ASC',
  ChildIdentitiesByCreatedBlockIdCountDesc = 'CHILD_IDENTITIES_BY_CREATED_BLOCK_ID_COUNT_DESC',
  ChildIdentitiesByUpdatedBlockIdCountAsc = 'CHILD_IDENTITIES_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  ChildIdentitiesByUpdatedBlockIdCountDesc = 'CHILD_IDENTITIES_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  ClaimsByCreatedBlockIdCountAsc = 'CLAIMS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  ClaimsByCreatedBlockIdCountDesc = 'CLAIMS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  ClaimsByUpdatedBlockIdCountAsc = 'CLAIMS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  ClaimsByUpdatedBlockIdCountDesc = 'CLAIMS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  ClaimScopesByCreatedBlockIdCountAsc = 'CLAIM_SCOPES_BY_CREATED_BLOCK_ID_COUNT_ASC',
  ClaimScopesByCreatedBlockIdCountDesc = 'CLAIM_SCOPES_BY_CREATED_BLOCK_ID_COUNT_DESC',
  ClaimScopesByUpdatedBlockIdCountAsc = 'CLAIM_SCOPES_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  ClaimScopesByUpdatedBlockIdCountDesc = 'CLAIM_SCOPES_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  CompliancesByCreatedBlockIdCountAsc = 'COMPLIANCES_BY_CREATED_BLOCK_ID_COUNT_ASC',
  CompliancesByCreatedBlockIdCountDesc = 'COMPLIANCES_BY_CREATED_BLOCK_ID_COUNT_DESC',
  CompliancesByUpdatedBlockIdCountAsc = 'COMPLIANCES_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  CompliancesByUpdatedBlockIdCountDesc = 'COMPLIANCES_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  CountEventsAsc = 'COUNT_EVENTS_ASC',
  CountEventsDesc = 'COUNT_EVENTS_DESC',
  CountExtrinsicsAsc = 'COUNT_EXTRINSICS_ASC',
  CountExtrinsicsDesc = 'COUNT_EXTRINSICS_DESC',
  CountExtrinsicsErrorAsc = 'COUNT_EXTRINSICS_ERROR_ASC',
  CountExtrinsicsErrorDesc = 'COUNT_EXTRINSICS_ERROR_DESC',
  CountExtrinsicsSignedAsc = 'COUNT_EXTRINSICS_SIGNED_ASC',
  CountExtrinsicsSignedDesc = 'COUNT_EXTRINSICS_SIGNED_DESC',
  CountExtrinsicsSuccessAsc = 'COUNT_EXTRINSICS_SUCCESS_ASC',
  CountExtrinsicsSuccessDesc = 'COUNT_EXTRINSICS_SUCCESS_DESC',
  CountExtrinsicsUnsignedAsc = 'COUNT_EXTRINSICS_UNSIGNED_ASC',
  CountExtrinsicsUnsignedDesc = 'COUNT_EXTRINSICS_UNSIGNED_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DatetimeAsc = 'DATETIME_ASC',
  DatetimeDesc = 'DATETIME_DESC',
  DistributionsByCreatedBlockIdCountAsc = 'DISTRIBUTIONS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  DistributionsByCreatedBlockIdCountDesc = 'DISTRIBUTIONS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  DistributionsByUpdatedBlockIdCountAsc = 'DISTRIBUTIONS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  DistributionsByUpdatedBlockIdCountDesc = 'DISTRIBUTIONS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  DistributionPaymentsByCreatedBlockIdCountAsc = 'DISTRIBUTION_PAYMENTS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  DistributionPaymentsByCreatedBlockIdCountDesc = 'DISTRIBUTION_PAYMENTS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  DistributionPaymentsByUpdatedBlockIdCountAsc = 'DISTRIBUTION_PAYMENTS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  DistributionPaymentsByUpdatedBlockIdCountDesc = 'DISTRIBUTION_PAYMENTS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  EventsCountAsc = 'EVENTS_COUNT_ASC',
  EventsCountDesc = 'EVENTS_COUNT_DESC',
  ExtrinsicsCountAsc = 'EXTRINSICS_COUNT_ASC',
  ExtrinsicsCountDesc = 'EXTRINSICS_COUNT_DESC',
  ExtrinsicsRootAsc = 'EXTRINSICS_ROOT_ASC',
  ExtrinsicsRootDesc = 'EXTRINSICS_ROOT_DESC',
  FundingsByCreatedBlockIdCountAsc = 'FUNDINGS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  FundingsByCreatedBlockIdCountDesc = 'FUNDINGS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  FundingsByUpdatedBlockIdCountAsc = 'FUNDINGS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  FundingsByUpdatedBlockIdCountDesc = 'FUNDINGS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  HashAsc = 'HASH_ASC',
  HashDesc = 'HASH_DESC',
  IdentitiesByCreatedBlockIdCountAsc = 'IDENTITIES_BY_CREATED_BLOCK_ID_COUNT_ASC',
  IdentitiesByCreatedBlockIdCountDesc = 'IDENTITIES_BY_CREATED_BLOCK_ID_COUNT_DESC',
  IdentitiesByUpdatedBlockIdCountAsc = 'IDENTITIES_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  IdentitiesByUpdatedBlockIdCountDesc = 'IDENTITIES_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InstructionsByCreatedBlockIdCountAsc = 'INSTRUCTIONS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  InstructionsByCreatedBlockIdCountDesc = 'INSTRUCTIONS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  InstructionsByUpdatedBlockIdCountAsc = 'INSTRUCTIONS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  InstructionsByUpdatedBlockIdCountDesc = 'INSTRUCTIONS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  InvestmentsByCreatedBlockIdCountAsc = 'INVESTMENTS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  InvestmentsByCreatedBlockIdCountDesc = 'INVESTMENTS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  InvestmentsByUpdatedBlockIdCountAsc = 'INVESTMENTS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  InvestmentsByUpdatedBlockIdCountDesc = 'INVESTMENTS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  LegsByCreatedBlockIdCountAsc = 'LEGS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  LegsByCreatedBlockIdCountDesc = 'LEGS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  LegsByUpdatedBlockIdCountAsc = 'LEGS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  LegsByUpdatedBlockIdCountDesc = 'LEGS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  Natural = 'NATURAL',
  ParentHashAsc = 'PARENT_HASH_ASC',
  ParentHashDesc = 'PARENT_HASH_DESC',
  ParentIdAsc = 'PARENT_ID_ASC',
  ParentIdDesc = 'PARENT_ID_DESC',
  PermissionsByCreatedBlockIdCountAsc = 'PERMISSIONS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  PermissionsByCreatedBlockIdCountDesc = 'PERMISSIONS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  PermissionsByUpdatedBlockIdCountAsc = 'PERMISSIONS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  PermissionsByUpdatedBlockIdCountDesc = 'PERMISSIONS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  PolyxTransactionsByCreatedBlockIdCountAsc = 'POLYX_TRANSACTIONS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  PolyxTransactionsByCreatedBlockIdCountDesc = 'POLYX_TRANSACTIONS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  PolyxTransactionsByUpdatedBlockIdCountAsc = 'POLYX_TRANSACTIONS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  PolyxTransactionsByUpdatedBlockIdCountDesc = 'POLYX_TRANSACTIONS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  PortfoliosByCreatedBlockIdCountAsc = 'PORTFOLIOS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  PortfoliosByCreatedBlockIdCountDesc = 'PORTFOLIOS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  PortfoliosByUpdatedBlockIdCountAsc = 'PORTFOLIOS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  PortfoliosByUpdatedBlockIdCountDesc = 'PORTFOLIOS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  PortfolioMovementsByCreatedBlockIdCountAsc = 'PORTFOLIO_MOVEMENTS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  PortfolioMovementsByCreatedBlockIdCountDesc = 'PORTFOLIO_MOVEMENTS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  PortfolioMovementsByUpdatedBlockIdCountAsc = 'PORTFOLIO_MOVEMENTS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  PortfolioMovementsByUpdatedBlockIdCountDesc = 'PORTFOLIO_MOVEMENTS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ProposalsByCreatedBlockIdCountAsc = 'PROPOSALS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  ProposalsByCreatedBlockIdCountDesc = 'PROPOSALS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  ProposalsByUpdatedBlockIdCountAsc = 'PROPOSALS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  ProposalsByUpdatedBlockIdCountDesc = 'PROPOSALS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  ProposalVotesByCreatedBlockIdCountAsc = 'PROPOSAL_VOTES_BY_CREATED_BLOCK_ID_COUNT_ASC',
  ProposalVotesByCreatedBlockIdCountDesc = 'PROPOSAL_VOTES_BY_CREATED_BLOCK_ID_COUNT_DESC',
  ProposalVotesByUpdatedBlockIdCountAsc = 'PROPOSAL_VOTES_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  ProposalVotesByUpdatedBlockIdCountDesc = 'PROPOSAL_VOTES_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  SettlementsByCreatedBlockIdCountAsc = 'SETTLEMENTS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  SettlementsByCreatedBlockIdCountDesc = 'SETTLEMENTS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  SettlementsByUpdatedBlockIdCountAsc = 'SETTLEMENTS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  SettlementsByUpdatedBlockIdCountDesc = 'SETTLEMENTS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  SpecVersionIdAsc = 'SPEC_VERSION_ID_ASC',
  SpecVersionIdDesc = 'SPEC_VERSION_ID_DESC',
  StakingEventsByCreatedBlockIdCountAsc = 'STAKING_EVENTS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  StakingEventsByCreatedBlockIdCountDesc = 'STAKING_EVENTS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  StakingEventsByUpdatedBlockIdCountAsc = 'STAKING_EVENTS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  StakingEventsByUpdatedBlockIdCountDesc = 'STAKING_EVENTS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  StateRootAsc = 'STATE_ROOT_ASC',
  StateRootDesc = 'STATE_ROOT_DESC',
  StatTypesByCreatedBlockIdCountAsc = 'STAT_TYPES_BY_CREATED_BLOCK_ID_COUNT_ASC',
  StatTypesByCreatedBlockIdCountDesc = 'STAT_TYPES_BY_CREATED_BLOCK_ID_COUNT_DESC',
  StatTypesByUpdatedBlockIdCountAsc = 'STAT_TYPES_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  StatTypesByUpdatedBlockIdCountDesc = 'STAT_TYPES_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  StosByCreatedBlockIdCountAsc = 'STOS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  StosByCreatedBlockIdCountDesc = 'STOS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  StosByUpdatedBlockIdCountAsc = 'STOS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  StosByUpdatedBlockIdCountDesc = 'STOS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  TickerExternalAgentsByCreatedBlockIdCountAsc = 'TICKER_EXTERNAL_AGENTS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  TickerExternalAgentsByCreatedBlockIdCountDesc = 'TICKER_EXTERNAL_AGENTS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  TickerExternalAgentsByUpdatedBlockIdCountAsc = 'TICKER_EXTERNAL_AGENTS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  TickerExternalAgentsByUpdatedBlockIdCountDesc = 'TICKER_EXTERNAL_AGENTS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  TickerExternalAgentActionsByCreatedBlockIdCountAsc = 'TICKER_EXTERNAL_AGENT_ACTIONS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  TickerExternalAgentActionsByCreatedBlockIdCountDesc = 'TICKER_EXTERNAL_AGENT_ACTIONS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  TickerExternalAgentActionsByUpdatedBlockIdCountAsc = 'TICKER_EXTERNAL_AGENT_ACTIONS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  TickerExternalAgentActionsByUpdatedBlockIdCountDesc = 'TICKER_EXTERNAL_AGENT_ACTIONS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  TickerExternalAgentHistoriesByCreatedBlockIdCountAsc = 'TICKER_EXTERNAL_AGENT_HISTORIES_BY_CREATED_BLOCK_ID_COUNT_ASC',
  TickerExternalAgentHistoriesByCreatedBlockIdCountDesc = 'TICKER_EXTERNAL_AGENT_HISTORIES_BY_CREATED_BLOCK_ID_COUNT_DESC',
  TickerExternalAgentHistoriesByUpdatedBlockIdCountAsc = 'TICKER_EXTERNAL_AGENT_HISTORIES_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  TickerExternalAgentHistoriesByUpdatedBlockIdCountDesc = 'TICKER_EXTERNAL_AGENT_HISTORIES_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  TransferCompliancesByCreatedBlockIdCountAsc = 'TRANSFER_COMPLIANCES_BY_CREATED_BLOCK_ID_COUNT_ASC',
  TransferCompliancesByCreatedBlockIdCountDesc = 'TRANSFER_COMPLIANCES_BY_CREATED_BLOCK_ID_COUNT_DESC',
  TransferCompliancesByUpdatedBlockIdCountAsc = 'TRANSFER_COMPLIANCES_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  TransferCompliancesByUpdatedBlockIdCountDesc = 'TRANSFER_COMPLIANCES_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  TransferComplianceExemptionsByCreatedBlockIdCountAsc = 'TRANSFER_COMPLIANCE_EXEMPTIONS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  TransferComplianceExemptionsByCreatedBlockIdCountDesc = 'TRANSFER_COMPLIANCE_EXEMPTIONS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  TransferComplianceExemptionsByUpdatedBlockIdCountAsc = 'TRANSFER_COMPLIANCE_EXEMPTIONS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  TransferComplianceExemptionsByUpdatedBlockIdCountDesc = 'TRANSFER_COMPLIANCE_EXEMPTIONS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  TransferManagersByCreatedBlockIdCountAsc = 'TRANSFER_MANAGERS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  TransferManagersByCreatedBlockIdCountDesc = 'TRANSFER_MANAGERS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  TransferManagersByUpdatedBlockIdCountAsc = 'TRANSFER_MANAGERS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  TransferManagersByUpdatedBlockIdCountDesc = 'TRANSFER_MANAGERS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  TrustedClaimIssuersByCreatedBlockIdCountAsc = 'TRUSTED_CLAIM_ISSUERS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  TrustedClaimIssuersByCreatedBlockIdCountDesc = 'TRUSTED_CLAIM_ISSUERS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  TrustedClaimIssuersByUpdatedBlockIdCountAsc = 'TRUSTED_CLAIM_ISSUERS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  TrustedClaimIssuersByUpdatedBlockIdCountDesc = 'TRUSTED_CLAIM_ISSUERS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  VenuesByCreatedBlockIdCountAsc = 'VENUES_BY_CREATED_BLOCK_ID_COUNT_ASC',
  VenuesByCreatedBlockIdCountDesc = 'VENUES_BY_CREATED_BLOCK_ID_COUNT_DESC',
  VenuesByUpdatedBlockIdCountAsc = 'VENUES_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  VenuesByUpdatedBlockIdCountDesc = 'VENUES_BY_UPDATED_BLOCK_ID_COUNT_DESC',
}

/** A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’ */
export type BooleanFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Boolean']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Boolean']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Boolean']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};

/** Represents `POLY`, the Ethereum based ERC-20 token, being converted to POLYX, the native Polymesh token */
export type BridgeEvent = Node & {
  __typename?: 'BridgeEvent';
  amount: Scalars['BigFloat']['output'];
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `BridgeEvent`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  datetime: Scalars['Datetime']['output'];
  eventIdx: Scalars['Int']['output'];
  id: Scalars['String']['output'];
  /** Reads a single `Identity` that is related to this `BridgeEvent`. */
  identity?: Maybe<Identity>;
  identityId: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  recipient: Scalars['String']['output'];
  txHash: Scalars['String']['output'];
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `BridgeEvent`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
};

export type BridgeEventAggregates = {
  __typename?: 'BridgeEventAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A filter to be used against `BridgeEvent` object types. All fields are combined with a logical ‘and.’ */
export type BridgeEventFilter = {
  /** Filter by the object’s `amount` field. */
  amount?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<BridgeEventFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `datetime` field. */
  datetime?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `eventIdx` field. */
  eventIdx?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `identityId` field. */
  identityId?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<BridgeEventFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<BridgeEventFilter>>;
  /** Filter by the object’s `recipient` field. */
  recipient?: InputMaybe<StringFilter>;
  /** Filter by the object’s `txHash` field. */
  txHash?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
};

/** A connection to a list of `BridgeEvent` values. */
export type BridgeEventsConnection = {
  __typename?: 'BridgeEventsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BridgeEventAggregates>;
  /** A list of edges which contains the `BridgeEvent` and cursor to aid in pagination. */
  edges: Array<BridgeEventsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BridgeEventAggregates>>;
  /** A list of `BridgeEvent` objects. */
  nodes: Array<Maybe<BridgeEvent>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `BridgeEvent` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `BridgeEvent` values. */
export type BridgeEventsConnectionGroupedAggregatesArgs = {
  groupBy: Array<BridgeEventsGroupBy>;
  having?: InputMaybe<BridgeEventsHavingInput>;
};

/** A `BridgeEvent` edge in the connection. */
export type BridgeEventsEdge = {
  __typename?: 'BridgeEventsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `BridgeEvent` at the end of the edge. */
  node?: Maybe<BridgeEvent>;
};

/** Grouping methods for `BridgeEvent` for usage during aggregation. */
export enum BridgeEventsGroupBy {
  Amount = 'AMOUNT',
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  Datetime = 'DATETIME',
  EventIdx = 'EVENT_IDX',
  IdentityId = 'IDENTITY_ID',
  Recipient = 'RECIPIENT',
  TxHash = 'TX_HASH',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
}

/** Conditions for `BridgeEvent` aggregates. */
export type BridgeEventsHavingInput = {
  AND?: InputMaybe<Array<BridgeEventsHavingInput>>;
  OR?: InputMaybe<Array<BridgeEventsHavingInput>>;
};

/** Methods to use when ordering `BridgeEvent`. */
export enum BridgeEventsOrderBy {
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  DatetimeAsc = 'DATETIME_ASC',
  DatetimeDesc = 'DATETIME_DESC',
  EventIdxAsc = 'EVENT_IDX_ASC',
  EventIdxDesc = 'EVENT_IDX_DESC',
  IdentityIdAsc = 'IDENTITY_ID_ASC',
  IdentityIdDesc = 'IDENTITY_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RecipientAsc = 'RECIPIENT_ASC',
  RecipientDesc = 'RECIPIENT_DESC',
  TxHashAsc = 'TX_HASH_ASC',
  TxHashDesc = 'TX_HASH_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
}

/**  Represents all known chain extrinsics */
export enum CallIdEnum {
  Abdicate = 'abdicate',
  AbdicateMembership = 'abdicate_membership',
  AcceptAssetOwnershipTransfer = 'accept_asset_ownership_transfer',
  AcceptAuthorization = 'accept_authorization',
  AcceptBecomeAgent = 'accept_become_agent',
  AcceptMasterKey = 'accept_master_key',
  AcceptMultisigSignerAsIdentity = 'accept_multisig_signer_as_identity',
  AcceptMultisigSignerAsKey = 'accept_multisig_signer_as_key',
  AcceptPayingKey = 'accept_paying_key',
  AcceptPortfolioCustody = 'accept_portfolio_custody',
  AcceptPrimaryIssuanceAgentTransfer = 'accept_primary_issuance_agent_transfer',
  AcceptPrimaryKey = 'accept_primary_key',
  AcceptTickerTransfer = 'accept_ticker_transfer',
  AddActiveRule = 'add_active_rule',
  AddAndAffirmInstruction = 'add_and_affirm_instruction',
  AddAndAffirmInstructionWithMemo = 'add_and_affirm_instruction_with_memo',
  AddAndAffirmInstructionWithMemoV2 = 'add_and_affirm_instruction_with_memo_v2',
  AddAndAuthorizeInstruction = 'add_and_authorize_instruction',
  AddAuthorization = 'add_authorization',
  AddBallot = 'add_ballot',
  AddClaim = 'add_claim',
  AddComplianceRequirement = 'add_compliance_requirement',
  AddDefaultTrustedClaimIssuer = 'add_default_trusted_claim_issuer',
  AddDocuments = 'add_documents',
  AddExemptedEntities = 'add_exempted_entities',
  AddExtension = 'add_extension',
  AddFreezeAdmin = 'add_freeze_admin',
  AddInstruction = 'add_instruction',
  AddInstructionWithMemo = 'add_instruction_with_memo',
  AddInstructionWithMemoV2 = 'add_instruction_with_memo_v2',
  AddInvestorUniquenessClaim = 'add_investor_uniqueness_claim',
  AddInvestorUniquenessClaimV2 = 'add_investor_uniqueness_claim_v2',
  AddMember = 'add_member',
  AddMultisigSigner = 'add_multisig_signer',
  AddMultisigSignersViaCreator = 'add_multisig_signers_via_creator',
  AddPermissionedValidator = 'add_permissioned_validator',
  AddRangeProof = 'add_range_proof',
  AddSecondaryKeysWithAuthorization = 'add_secondary_keys_with_authorization',
  AddSecondaryKeysWithAuthorizationOld = 'add_secondary_keys_with_authorization_old',
  AddTransferManager = 'add_transfer_manager',
  AddVerifyRangeProof = 'add_verify_range_proof',
  AffirmInstruction = 'affirm_instruction',
  AffirmInstructionV2 = 'affirm_instruction_v2',
  AffirmWithReceipts = 'affirm_with_receipts',
  AllowVenues = 'allow_venues',
  AmendProposal = 'amend_proposal',
  Approve = 'approve',
  ApproveAsIdentity = 'approve_as_identity',
  ApproveAsKey = 'approve_as_key',
  ApproveCommitteeProposal = 'approve_committee_proposal',
  ArchiveExtension = 'archive_extension',
  AttachBallot = 'attach_ballot',
  AuthorizeInstruction = 'authorize_instruction',
  AuthorizeWithReceipts = 'authorize_with_receipts',
  Batch = 'batch',
  BatchAcceptAuthorization = 'batch_accept_authorization',
  BatchAddAuthorization = 'batch_add_authorization',
  BatchAddClaim = 'batch_add_claim',
  BatchAddDefaultTrustedClaimIssuer = 'batch_add_default_trusted_claim_issuer',
  BatchAddDocument = 'batch_add_document',
  BatchAddSecondaryKeyWithAuthorization = 'batch_add_secondary_key_with_authorization',
  BatchAddSigningKeyWithAuthorization = 'batch_add_signing_key_with_authorization',
  BatchAll = 'batch_all',
  BatchAtomic = 'batch_atomic',
  BatchChangeAssetRule = 'batch_change_asset_rule',
  BatchChangeComplianceRequirement = 'batch_change_compliance_requirement',
  BatchForceHandleBridgeTx = 'batch_force_handle_bridge_tx',
  BatchFreezeTx = 'batch_freeze_tx',
  BatchHandleBridgeTx = 'batch_handle_bridge_tx',
  BatchIssue = 'batch_issue',
  BatchOld = 'batch_old',
  BatchOptimistic = 'batch_optimistic',
  BatchProposeBridgeTx = 'batch_propose_bridge_tx',
  BatchRemoveAuthorization = 'batch_remove_authorization',
  BatchRemoveDefaultTrustedClaimIssuer = 'batch_remove_default_trusted_claim_issuer',
  BatchRemoveDocument = 'batch_remove_document',
  BatchRevokeClaim = 'batch_revoke_claim',
  BatchUnfreezeTx = 'batch_unfreeze_tx',
  BatchUpdateAssetStats = 'batch_update_asset_stats',
  Bond = 'bond',
  BondAdditionalDeposit = 'bond_additional_deposit',
  BondExtra = 'bond_extra',
  BurnAccountBalance = 'burn_account_balance',
  BuyTokens = 'buy_tokens',
  Call = 'call',
  CallOldWeight = 'call_old_weight',
  Cancel = 'cancel',
  CancelBallot = 'cancel_ballot',
  CancelDeferredSlash = 'cancel_deferred_slash',
  CancelNamed = 'cancel_named',
  CancelProposal = 'cancel_proposal',
  CddRegisterDid = 'cdd_register_did',
  CddRegisterDidWithCdd = 'cdd_register_did_with_cdd',
  ChangeAdmin = 'change_admin',
  ChangeAllSignersAndSigsRequired = 'change_all_signers_and_sigs_required',
  ChangeAssetRule = 'change_asset_rule',
  ChangeBaseFee = 'change_base_fee',
  ChangeBridgeExempted = 'change_bridge_exempted',
  ChangeBridgeLimit = 'change_bridge_limit',
  ChangeCddRequirementForMkRotation = 'change_cdd_requirement_for_mk_rotation',
  ChangeCoefficient = 'change_coefficient',
  ChangeComplianceRequirement = 'change_compliance_requirement',
  ChangeController = 'change_controller',
  ChangeEnd = 'change_end',
  ChangeGroup = 'change_group',
  ChangeMeta = 'change_meta',
  ChangeRcv = 'change_rcv',
  ChangeReceiptValidity = 'change_receipt_validity',
  ChangeRecordDate = 'change_record_date',
  ChangeSigsRequired = 'change_sigs_required',
  ChangeSigsRequiredViaCreator = 'change_sigs_required_via_creator',
  ChangeSlashingAllowedFor = 'change_slashing_allowed_for',
  ChangeTemplateFees = 'change_template_fees',
  ChangeTemplateMetaUrl = 'change_template_meta_url',
  ChangeTimelock = 'change_timelock',
  Chill = 'chill',
  ChillFromGovernance = 'chill_from_governance',
  Claim = 'claim',
  ClaimClassicTicker = 'claim_classic_ticker',
  ClaimItnReward = 'claim_itn_reward',
  ClaimReceipt = 'claim_receipt',
  ClaimSurcharge = 'claim_surcharge',
  ClaimUnclaimed = 'claim_unclaimed',
  ClearSnapshot = 'clear_snapshot',
  Close = 'close',
  ControllerRedeem = 'controller_redeem',
  ControllerTransfer = 'controller_transfer',
  CreateAndChangeCustomGroup = 'create_and_change_custom_group',
  CreateAsset = 'create_asset',
  CreateAssetAndMint = 'create_asset_and_mint',
  CreateAssetWithCustomType = 'create_asset_with_custom_type',
  CreateCheckpoint = 'create_checkpoint',
  CreateChildIdentities = 'create_child_identities',
  CreateChildIdentity = 'create_child_identity',
  CreateFundraiser = 'create_fundraiser',
  CreateGroup = 'create_group',
  CreateGroupAndAddAuth = 'create_group_and_add_auth',
  CreateMultisig = 'create_multisig',
  CreateNftCollection = 'create_nft_collection',
  CreateOrApproveProposalAsIdentity = 'create_or_approve_proposal_as_identity',
  CreateOrApproveProposalAsKey = 'create_or_approve_proposal_as_key',
  CreatePortfolio = 'create_portfolio',
  CreateProposalAsIdentity = 'create_proposal_as_identity',
  CreateProposalAsKey = 'create_proposal_as_key',
  CreateSchedule = 'create_schedule',
  CreateVenue = 'create_venue',
  DecreasePolyxLimit = 'decrease_polyx_limit',
  DeletePortfolio = 'delete_portfolio',
  DepositBlockRewardReserveBalance = 'deposit_block_reward_reserve_balance',
  DisableMember = 'disable_member',
  DisallowVenues = 'disallow_venues',
  Disbursement = 'disbursement',
  DispatchAs = 'dispatch_as',
  Distribute = 'distribute',
  EmergencyReferendum = 'emergency_referendum',
  EnableIndividualCommissions = 'enable_individual_commissions',
  EnactReferendum = 'enact_referendum',
  EnactSnapshotResults = 'enact_snapshot_results',
  ExecuteManualInstruction = 'execute_manual_instruction',
  ExecuteScheduledInstruction = 'execute_scheduled_instruction',
  ExecuteScheduledInstructionV2 = 'execute_scheduled_instruction_v2',
  ExecuteScheduledInstructionV3 = 'execute_scheduled_instruction_v3',
  ExecuteScheduledPip = 'execute_scheduled_pip',
  ExecuteScheduledProposal = 'execute_scheduled_proposal',
  ExemptTickerAffirmation = 'exempt_ticker_affirmation',
  ExpireScheduledPip = 'expire_scheduled_pip',
  FastTrackProposal = 'fast_track_proposal',
  FillBlock = 'fill_block',
  FinalHint = 'final_hint',
  ForceBatch = 'force_batch',
  ForceHandleBridgeTx = 'force_handle_bridge_tx',
  ForceNewEra = 'force_new_era',
  ForceNewEraAlways = 'force_new_era_always',
  ForceNoEras = 'force_no_eras',
  ForceTransfer = 'force_transfer',
  ForceUnstake = 'force_unstake',
  ForwardedCall = 'forwarded_call',
  Free = 'free',
  Freeze = 'freeze',
  FreezeFundraiser = 'freeze_fundraiser',
  FreezeInstantiation = 'freeze_instantiation',
  FreezeSecondaryKeys = 'freeze_secondary_keys',
  FreezeSigningKeys = 'freeze_signing_keys',
  FreezeTxs = 'freeze_txs',
  GcAddCddClaim = 'gc_add_cdd_claim',
  GcRevokeCddClaim = 'gc_revoke_cdd_claim',
  GetCddOf = 'get_cdd_of',
  GetMyDid = 'get_my_did',
  HandleBridgeTx = 'handle_bridge_tx',
  HandleScheduledBridgeTx = 'handle_scheduled_bridge_tx',
  Heartbeat = 'heartbeat',
  IncreaseCustodyAllowance = 'increase_custody_allowance',
  IncreaseCustodyAllowanceOf = 'increase_custody_allowance_of',
  IncreasePolyxLimit = 'increase_polyx_limit',
  IncreaseValidatorCount = 'increase_validator_count',
  InitiateCorporateAction = 'initiate_corporate_action',
  InitiateCorporateActionAndDistribute = 'initiate_corporate_action_and_distribute',
  Instantiate = 'instantiate',
  InstantiateOldWeight = 'instantiate_old_weight',
  InstantiateWithCode = 'instantiate_with_code',
  InstantiateWithCodeOldWeight = 'instantiate_with_code_old_weight',
  InstantiateWithCodePerms = 'instantiate_with_code_perms',
  InstantiateWithHashPerms = 'instantiate_with_hash_perms',
  InvalidateCddClaims = 'invalidate_cdd_claims',
  Invest = 'invest',
  IsIssuable = 'is_issuable',
  Issue = 'issue',
  IssueNft = 'issue_nft',
  JoinIdentityAsIdentity = 'join_identity_as_identity',
  JoinIdentityAsKey = 'join_identity_as_key',
  KillPrefix = 'kill_prefix',
  KillProposal = 'kill_proposal',
  KillStorage = 'kill_storage',
  LaunchSto = 'launch_sto',
  LeaveIdentityAsIdentity = 'leave_identity_as_identity',
  LeaveIdentityAsKey = 'leave_identity_as_key',
  LegacySetPermissionToSigner = 'legacy_set_permission_to_signer',
  LinkCaDoc = 'link_ca_doc',
  MakeDivisible = 'make_divisible',
  MakeMultisigPrimary = 'make_multisig_primary',
  MakeMultisigSecondary = 'make_multisig_secondary',
  MakeMultisigSigner = 'make_multisig_signer',
  MockCddRegisterDid = 'mock_cdd_register_did',
  ModifyExemptionList = 'modify_exemption_list',
  ModifyFundraiserWindow = 'modify_fundraiser_window',
  MovePortfolioFunds = 'move_portfolio_funds',
  MovePortfolioFundsV2 = 'move_portfolio_funds_v2',
  New = 'new',
  Nominate = 'nominate',
  NotePreimage = 'note_preimage',
  NoteStalled = 'note_stalled',
  OverrideReferendumEnactmentPeriod = 'override_referendum_enactment_period',
  PauseAssetCompliance = 'pause_asset_compliance',
  PauseAssetRules = 'pause_asset_rules',
  PauseSto = 'pause_sto',
  PayoutStakers = 'payout_stakers',
  PayoutStakersBySystem = 'payout_stakers_by_system',
  PlaceholderAddAndAffirmInstruction = 'placeholder_add_and_affirm_instruction',
  PlaceholderAddAndAffirmInstructionWithMemo = 'placeholder_add_and_affirm_instruction_with_memo',
  PlaceholderAddInstruction = 'placeholder_add_instruction',
  PlaceholderAddInstructionWithMemo = 'placeholder_add_instruction_with_memo',
  PlaceholderAffirmInstruction = 'placeholder_affirm_instruction',
  PlaceholderClaimReceipt = 'placeholder_claim_receipt',
  PlaceholderFillBlock = 'placeholder_fill_block',
  PlaceholderLegacySetPermissionToSigner = 'placeholder_legacy_set_permission_to_signer',
  PlaceholderRejectInstruction = 'placeholder_reject_instruction',
  PlaceholderUnclaimReceipt = 'placeholder_unclaim_receipt',
  PlaceholderWithdrawAffirmation = 'placeholder_withdraw_affirmation',
  PlanConfigChange = 'plan_config_change',
  PreApprovePortfolio = 'pre_approve_portfolio',
  PreApproveTicker = 'pre_approve_ticker',
  Propose = 'propose',
  ProposeBridgeTx = 'propose_bridge_tx',
  PruneProposal = 'prune_proposal',
  PurgeKeys = 'purge_keys',
  PushBenefit = 'push_benefit',
  PutCode = 'put_code',
  QuitPortfolioCustody = 'quit_portfolio_custody',
  ReapStash = 'reap_stash',
  Rebond = 'rebond',
  Reclaim = 'reclaim',
  Redeem = 'redeem',
  RedeemFrom = 'redeem_from',
  RedeemFromPortfolio = 'redeem_from_portfolio',
  RedeemNft = 'redeem_nft',
  RegisterAndSetLocalAssetMetadata = 'register_and_set_local_asset_metadata',
  RegisterAssetMetadataGlobalType = 'register_asset_metadata_global_type',
  RegisterAssetMetadataLocalType = 'register_asset_metadata_local_type',
  RegisterCustomAssetType = 'register_custom_asset_type',
  RegisterCustomClaimType = 'register_custom_claim_type',
  RegisterDid = 'register_did',
  RegisterTicker = 'register_ticker',
  Reimbursement = 'reimbursement',
  RejectAsIdentity = 'reject_as_identity',
  RejectAsKey = 'reject_as_key',
  RejectInstruction = 'reject_instruction',
  RejectInstructionV2 = 'reject_instruction_v2',
  RejectProposal = 'reject_proposal',
  RejectReferendum = 'reject_referendum',
  RelayTx = 'relay_tx',
  Remark = 'remark',
  RemarkWithEvent = 'remark_with_event',
  RemoveActiveRule = 'remove_active_rule',
  RemoveAgent = 'remove_agent',
  RemoveAuthorization = 'remove_authorization',
  RemoveBallot = 'remove_ballot',
  RemoveCa = 'remove_ca',
  RemoveCode = 'remove_code',
  RemoveComplianceRequirement = 'remove_compliance_requirement',
  RemoveCreatorControls = 'remove_creator_controls',
  RemoveDefaultTrustedClaimIssuer = 'remove_default_trusted_claim_issuer',
  RemoveDistribution = 'remove_distribution',
  RemoveDocuments = 'remove_documents',
  RemoveExemptedEntities = 'remove_exempted_entities',
  RemoveFreezeAdmin = 'remove_freeze_admin',
  RemoveLocalMetadataKey = 'remove_local_metadata_key',
  RemoveMember = 'remove_member',
  RemoveMetadataValue = 'remove_metadata_value',
  RemoveMultisigSigner = 'remove_multisig_signer',
  RemoveMultisigSignersViaCreator = 'remove_multisig_signers_via_creator',
  RemovePayingKey = 'remove_paying_key',
  RemovePermissionedValidator = 'remove_permissioned_validator',
  RemovePortfolioPreApproval = 'remove_portfolio_pre_approval',
  RemovePrimaryIssuanceAgent = 'remove_primary_issuance_agent',
  RemoveSchedule = 'remove_schedule',
  RemoveSecondaryKeys = 'remove_secondary_keys',
  RemoveSecondaryKeysOld = 'remove_secondary_keys_old',
  RemoveSigningKeys = 'remove_signing_keys',
  RemoveSmartExtension = 'remove_smart_extension',
  RemoveTickerAffirmationExemption = 'remove_ticker_affirmation_exemption',
  RemoveTickerPreApproval = 'remove_ticker_pre_approval',
  RemoveTransferManager = 'remove_transfer_manager',
  RemoveTxs = 'remove_txs',
  RenameAsset = 'rename_asset',
  RenamePortfolio = 'rename_portfolio',
  ReplaceAssetCompliance = 'replace_asset_compliance',
  ReplaceAssetRules = 'replace_asset_rules',
  ReportEquivocation = 'report_equivocation',
  ReportEquivocationUnsigned = 'report_equivocation_unsigned',
  RequestPreimage = 'request_preimage',
  RescheduleExecution = 'reschedule_execution',
  RescheduleInstruction = 'reschedule_instruction',
  ReserveClassicTicker = 'reserve_classic_ticker',
  ResetActiveRules = 'reset_active_rules',
  ResetAssetCompliance = 'reset_asset_compliance',
  ResetCaa = 'reset_caa',
  ResetMembers = 'reset_members',
  ResumeAssetCompliance = 'resume_asset_compliance',
  ResumeAssetRules = 'resume_asset_rules',
  RevokeClaim = 'revoke_claim',
  RevokeClaimByIndex = 'revoke_claim_by_index',
  RevokeOffchainAuthorization = 'revoke_offchain_authorization',
  RotatePrimaryKeyToSecondary = 'rotate_primary_key_to_secondary',
  ScaleValidatorCount = 'scale_validator_count',
  Schedule = 'schedule',
  ScheduleAfter = 'schedule_after',
  ScheduleNamed = 'schedule_named',
  ScheduleNamedAfter = 'schedule_named_after',
  Set = 'set',
  SetActiveAssetStats = 'set_active_asset_stats',
  SetActiveMembersLimit = 'set_active_members_limit',
  SetActivePipLimit = 'set_active_pip_limit',
  SetAssetMetadata = 'set_asset_metadata',
  SetAssetMetadataDetails = 'set_asset_metadata_details',
  SetAssetTransferCompliance = 'set_asset_transfer_compliance',
  SetBalance = 'set_balance',
  SetChangesTrieConfig = 'set_changes_trie_config',
  SetCode = 'set_code',
  SetCodeWithoutChecks = 'set_code_without_checks',
  SetCommissionCap = 'set_commission_cap',
  SetController = 'set_controller',
  SetDefaultEnactmentPeriod = 'set_default_enactment_period',
  SetDefaultTargets = 'set_default_targets',
  SetDefaultWithholdingTax = 'set_default_withholding_tax',
  SetDidWithholdingTax = 'set_did_withholding_tax',
  SetEntitiesExempt = 'set_entities_exempt',
  SetExpiresAfter = 'set_expires_after',
  SetFundingRound = 'set_funding_round',
  SetGlobalCommission = 'set_global_commission',
  SetGroupPermissions = 'set_group_permissions',
  SetHeapPages = 'set_heap_pages',
  SetHistoryDepth = 'set_history_depth',
  SetInvulnerables = 'set_invulnerables',
  SetItnRewardStatus = 'set_itn_reward_status',
  SetKey = 'set_key',
  SetKeys = 'set_keys',
  SetMasterKey = 'set_master_key',
  SetMaxDetailsLength = 'set_max_details_length',
  SetMaxPipSkipCount = 'set_max_pip_skip_count',
  SetMinBondThreshold = 'set_min_bond_threshold',
  SetMinProposalDeposit = 'set_min_proposal_deposit',
  SetPayee = 'set_payee',
  SetPayingKey = 'set_paying_key',
  SetPendingPipExpiry = 'set_pending_pip_expiry',
  SetPermissionToSigner = 'set_permission_to_signer',
  SetPrimaryKey = 'set_primary_key',
  SetProposalCoolOffPeriod = 'set_proposal_cool_off_period',
  SetProposalDuration = 'set_proposal_duration',
  SetPruneHistoricalPips = 'set_prune_historical_pips',
  SetReleaseCoordinator = 'set_release_coordinator',
  SetSchedulesMaxComplexity = 'set_schedules_max_complexity',
  SetSecondaryKeyPermissions = 'set_secondary_key_permissions',
  SetStorage = 'set_storage',
  SetUncles = 'set_uncles',
  SetValidatorCount = 'set_validator_count',
  SetVenueFiltering = 'set_venue_filtering',
  SetVoteThreshold = 'set_vote_threshold',
  Snapshot = 'snapshot',
  Stop = 'stop',
  SubmitElectionSolution = 'submit_election_solution',
  SubmitElectionSolutionUnsigned = 'submit_election_solution_unsigned',
  Sudo = 'sudo',
  SudoAs = 'sudo_as',
  SudoUncheckedWeight = 'sudo_unchecked_weight',
  SwapMember = 'swap_member',
  Transfer = 'transfer',
  TransferWithMemo = 'transfer_with_memo',
  Unbond = 'unbond',
  UnclaimReceipt = 'unclaim_receipt',
  Unfreeze = 'unfreeze',
  UnfreezeFundraiser = 'unfreeze_fundraiser',
  UnfreezeSecondaryKeys = 'unfreeze_secondary_keys',
  UnfreezeTxs = 'unfreeze_txs',
  UnlinkChildIdentity = 'unlink_child_identity',
  UnnotePreimage = 'unnote_preimage',
  UnrequestPreimage = 'unrequest_preimage',
  UpdateAssetType = 'update_asset_type',
  UpdateCallRuntimeWhitelist = 'update_call_runtime_whitelist',
  UpdateIdentifiers = 'update_identifiers',
  UpdatePermissionedValidatorIntendedCount = 'update_permissioned_validator_intended_count',
  UpdatePolyxLimit = 'update_polyx_limit',
  UpdateVenueDetails = 'update_venue_details',
  UpdateVenueSigners = 'update_venue_signers',
  UpdateVenueType = 'update_venue_type',
  UploadCode = 'upload_code',
  Validate = 'validate',
  ValidateCddExpiryNominators = 'validate_cdd_expiry_nominators',
  Vote = 'vote',
  VoteOrPropose = 'vote_or_propose',
  WithWeight = 'with_weight',
  WithdrawAffirmation = 'withdraw_affirmation',
  WithdrawAffirmationV2 = 'withdraw_affirmation_v2',
  WithdrawUnbonded = 'withdraw_unbonded',
}

/** A filter to be used against CallIdEnum fields. All fields are combined with a logical ‘and.’ */
export type CallIdEnumFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<CallIdEnum>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<CallIdEnum>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<CallIdEnum>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<CallIdEnum>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<CallIdEnum>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<CallIdEnum>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<CallIdEnum>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<CallIdEnum>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<CallIdEnum>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<CallIdEnum>>;
};

/** A connection to a list of `ChildIdentity` values. */
export type ChildIdentitiesConnection = {
  __typename?: 'ChildIdentitiesConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<ChildIdentityAggregates>;
  /** A list of edges which contains the `ChildIdentity` and cursor to aid in pagination. */
  edges: Array<ChildIdentitiesEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<ChildIdentityAggregates>>;
  /** A list of `ChildIdentity` objects. */
  nodes: Array<Maybe<ChildIdentity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ChildIdentity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `ChildIdentity` values. */
export type ChildIdentitiesConnectionGroupedAggregatesArgs = {
  groupBy: Array<ChildIdentitiesGroupBy>;
  having?: InputMaybe<ChildIdentitiesHavingInput>;
};

/** A `ChildIdentity` edge in the connection. */
export type ChildIdentitiesEdge = {
  __typename?: 'ChildIdentitiesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ChildIdentity` at the end of the edge. */
  node?: Maybe<ChildIdentity>;
};

/** Grouping methods for `ChildIdentity` for usage during aggregation. */
export enum ChildIdentitiesGroupBy {
  ChildId = 'CHILD_ID',
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  ParentId = 'PARENT_ID',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
}

/** Conditions for `ChildIdentity` aggregates. */
export type ChildIdentitiesHavingInput = {
  AND?: InputMaybe<Array<ChildIdentitiesHavingInput>>;
  OR?: InputMaybe<Array<ChildIdentitiesHavingInput>>;
};

/** Methods to use when ordering `ChildIdentity`. */
export enum ChildIdentitiesOrderBy {
  ChildIdAsc = 'CHILD_ID_ASC',
  ChildIdDesc = 'CHILD_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  ParentIdAsc = 'PARENT_ID_ASC',
  ParentIdDesc = 'PARENT_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
}

/** Represents the parent child mapping for an Identity */
export type ChildIdentity = Node & {
  __typename?: 'ChildIdentity';
  /** Reads a single `Identity` that is related to this `ChildIdentity`. */
  child?: Maybe<Identity>;
  childId: Scalars['String']['output'];
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `ChildIdentity`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  id: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Identity` that is related to this `ChildIdentity`. */
  parent?: Maybe<Identity>;
  parentId: Scalars['String']['output'];
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `ChildIdentity`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
};

export type ChildIdentityAggregates = {
  __typename?: 'ChildIdentityAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A filter to be used against `ChildIdentity` object types. All fields are combined with a logical ‘and.’ */
export type ChildIdentityFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ChildIdentityFilter>>;
  /** Filter by the object’s `childId` field. */
  childId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ChildIdentityFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ChildIdentityFilter>>;
  /** Filter by the object’s `parentId` field. */
  parentId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
};

/**
 * A claim made about an Identity. All active identities must have a valid CDD claim, but additional claims can be made.
 *
 * e.g. The Identity belongs to an accredited, US citizen
 */
export type Claim = Node & {
  __typename?: 'Claim';
  cddId?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `Claim`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  customClaimTypeId?: Maybe<Scalars['BigFloat']['output']>;
  eventIdx: Scalars['Int']['output'];
  expiry?: Maybe<Scalars['BigFloat']['output']>;
  filterExpiry: Scalars['BigFloat']['output'];
  id: Scalars['String']['output'];
  issuanceDate: Scalars['BigFloat']['output'];
  /** Reads a single `Identity` that is related to this `Claim`. */
  issuer?: Maybe<Identity>;
  issuerId: Scalars['String']['output'];
  jurisdiction?: Maybe<Scalars['String']['output']>;
  lastUpdateDate: Scalars['BigFloat']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  revokeDate?: Maybe<Scalars['BigFloat']['output']>;
  scope?: Maybe<Scalars['JSON']['output']>;
  /** Reads a single `Identity` that is related to this `Claim`. */
  target?: Maybe<Identity>;
  targetId: Scalars['String']['output'];
  type: ClaimTypeEnum;
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `Claim`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
};

export type ClaimAggregates = {
  __typename?: 'ClaimAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A filter to be used against `Claim` object types. All fields are combined with a logical ‘and.’ */
export type ClaimFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ClaimFilter>>;
  /** Filter by the object’s `cddId` field. */
  cddId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `customClaimTypeId` field. */
  customClaimTypeId?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `eventIdx` field. */
  eventIdx?: InputMaybe<IntFilter>;
  /** Filter by the object’s `expiry` field. */
  expiry?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `filterExpiry` field. */
  filterExpiry?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `issuanceDate` field. */
  issuanceDate?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `issuerId` field. */
  issuerId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `jurisdiction` field. */
  jurisdiction?: InputMaybe<StringFilter>;
  /** Filter by the object’s `lastUpdateDate` field. */
  lastUpdateDate?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ClaimFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ClaimFilter>>;
  /** Filter by the object’s `revokeDate` field. */
  revokeDate?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `scope` field. */
  scope?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `targetId` field. */
  targetId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<ClaimTypeEnumFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
};

/**
 * The scope of a claim.
 *
 * e.g. `target` is Blocked from owning "TICKER-A" or `target` is an Affiliate of "TICKER-B"
 */
export type ClaimScope = Node & {
  __typename?: 'ClaimScope';
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `ClaimScope`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  id: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  scope?: Maybe<Scalars['JSON']['output']>;
  target: Scalars['String']['output'];
  ticker?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `ClaimScope`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
};

export type ClaimScopeAggregates = {
  __typename?: 'ClaimScopeAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A filter to be used against `ClaimScope` object types. All fields are combined with a logical ‘and.’ */
export type ClaimScopeFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ClaimScopeFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ClaimScopeFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ClaimScopeFilter>>;
  /** Filter by the object’s `scope` field. */
  scope?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `target` field. */
  target?: InputMaybe<StringFilter>;
  /** Filter by the object’s `ticker` field. */
  ticker?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
};

/** A connection to a list of `ClaimScope` values. */
export type ClaimScopesConnection = {
  __typename?: 'ClaimScopesConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<ClaimScopeAggregates>;
  /** A list of edges which contains the `ClaimScope` and cursor to aid in pagination. */
  edges: Array<ClaimScopesEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<ClaimScopeAggregates>>;
  /** A list of `ClaimScope` objects. */
  nodes: Array<Maybe<ClaimScope>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ClaimScope` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `ClaimScope` values. */
export type ClaimScopesConnectionGroupedAggregatesArgs = {
  groupBy: Array<ClaimScopesGroupBy>;
  having?: InputMaybe<ClaimScopesHavingInput>;
};

/** A `ClaimScope` edge in the connection. */
export type ClaimScopesEdge = {
  __typename?: 'ClaimScopesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ClaimScope` at the end of the edge. */
  node?: Maybe<ClaimScope>;
};

/** Grouping methods for `ClaimScope` for usage during aggregation. */
export enum ClaimScopesGroupBy {
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  Scope = 'SCOPE',
  Target = 'TARGET',
  Ticker = 'TICKER',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
}

/** Conditions for `ClaimScope` aggregates. */
export type ClaimScopesHavingInput = {
  AND?: InputMaybe<Array<ClaimScopesHavingInput>>;
  OR?: InputMaybe<Array<ClaimScopesHavingInput>>;
};

/** Methods to use when ordering `ClaimScope`. */
export enum ClaimScopesOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ScopeAsc = 'SCOPE_ASC',
  ScopeDesc = 'SCOPE_DESC',
  TargetAsc = 'TARGET_ASC',
  TargetDesc = 'TARGET_DESC',
  TickerAsc = 'TICKER_ASC',
  TickerDesc = 'TICKER_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
}

/**  Represents all possible claims that can be made of an identity */
export enum ClaimTypeEnum {
  Accredited = 'Accredited',
  Affiliate = 'Affiliate',
  Blocked = 'Blocked',
  BuyLockup = 'BuyLockup',
  Custom = 'Custom',
  CustomerDueDiligence = 'CustomerDueDiligence',
  Exempted = 'Exempted',
  InvestorUniqueness = 'InvestorUniqueness',
  InvestorUniquenessV2 = 'InvestorUniquenessV2',
  Jurisdiction = 'Jurisdiction',
  KnowYourCustomer = 'KnowYourCustomer',
  NoData = 'NoData',
  NoType = 'NoType',
  SellLockup = 'SellLockup',
}

/** A filter to be used against ClaimTypeEnum fields. All fields are combined with a logical ‘and.’ */
export type ClaimTypeEnumFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<ClaimTypeEnum>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<ClaimTypeEnum>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<ClaimTypeEnum>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<ClaimTypeEnum>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<ClaimTypeEnum>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<ClaimTypeEnum>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<ClaimTypeEnum>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<ClaimTypeEnum>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<ClaimTypeEnum>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<ClaimTypeEnum>>;
};

/** A connection to a list of `Claim` values. */
export type ClaimsConnection = {
  __typename?: 'ClaimsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<ClaimAggregates>;
  /** A list of edges which contains the `Claim` and cursor to aid in pagination. */
  edges: Array<ClaimsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<ClaimAggregates>>;
  /** A list of `Claim` objects. */
  nodes: Array<Maybe<Claim>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Claim` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Claim` values. */
export type ClaimsConnectionGroupedAggregatesArgs = {
  groupBy: Array<ClaimsGroupBy>;
  having?: InputMaybe<ClaimsHavingInput>;
};

/** A `Claim` edge in the connection. */
export type ClaimsEdge = {
  __typename?: 'ClaimsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Claim` at the end of the edge. */
  node?: Maybe<Claim>;
};

/** Grouping methods for `Claim` for usage during aggregation. */
export enum ClaimsGroupBy {
  CddId = 'CDD_ID',
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  CustomClaimTypeId = 'CUSTOM_CLAIM_TYPE_ID',
  EventIdx = 'EVENT_IDX',
  Expiry = 'EXPIRY',
  FilterExpiry = 'FILTER_EXPIRY',
  IssuanceDate = 'ISSUANCE_DATE',
  IssuerId = 'ISSUER_ID',
  Jurisdiction = 'JURISDICTION',
  LastUpdateDate = 'LAST_UPDATE_DATE',
  RevokeDate = 'REVOKE_DATE',
  Scope = 'SCOPE',
  TargetId = 'TARGET_ID',
  Type = 'TYPE',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
}

/** Conditions for `Claim` aggregates. */
export type ClaimsHavingInput = {
  AND?: InputMaybe<Array<ClaimsHavingInput>>;
  OR?: InputMaybe<Array<ClaimsHavingInput>>;
};

/** Methods to use when ordering `Claim`. */
export enum ClaimsOrderBy {
  CddIdAsc = 'CDD_ID_ASC',
  CddIdDesc = 'CDD_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  CustomClaimTypeIdAsc = 'CUSTOM_CLAIM_TYPE_ID_ASC',
  CustomClaimTypeIdDesc = 'CUSTOM_CLAIM_TYPE_ID_DESC',
  EventIdxAsc = 'EVENT_IDX_ASC',
  EventIdxDesc = 'EVENT_IDX_DESC',
  ExpiryAsc = 'EXPIRY_ASC',
  ExpiryDesc = 'EXPIRY_DESC',
  FilterExpiryAsc = 'FILTER_EXPIRY_ASC',
  FilterExpiryDesc = 'FILTER_EXPIRY_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IssuanceDateAsc = 'ISSUANCE_DATE_ASC',
  IssuanceDateDesc = 'ISSUANCE_DATE_DESC',
  IssuerIdAsc = 'ISSUER_ID_ASC',
  IssuerIdDesc = 'ISSUER_ID_DESC',
  JurisdictionAsc = 'JURISDICTION_ASC',
  JurisdictionDesc = 'JURISDICTION_DESC',
  LastUpdateDateAsc = 'LAST_UPDATE_DATE_ASC',
  LastUpdateDateDesc = 'LAST_UPDATE_DATE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RevokeDateAsc = 'REVOKE_DATE_ASC',
  RevokeDateDesc = 'REVOKE_DATE_DESC',
  ScopeAsc = 'SCOPE_ASC',
  ScopeDesc = 'SCOPE_DESC',
  TargetIdAsc = 'TARGET_ID_ASC',
  TargetIdDesc = 'TARGET_ID_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
}

/**
 * Represents a restriction all investor must comply with for a given Asset
 *
 * e.g. All investors must be German citizens
 */
export type Compliance = Node & {
  __typename?: 'Compliance';
  /** Reads a single `Asset` that is related to this `Compliance`. */
  asset?: Maybe<Asset>;
  assetId: Scalars['String']['output'];
  complianceId: Scalars['Int']['output'];
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `Compliance`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  data: Scalars['String']['output'];
  id: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `Compliance`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
};

export type ComplianceAggregates = {
  __typename?: 'ComplianceAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A filter to be used against `Compliance` object types. All fields are combined with a logical ‘and.’ */
export type ComplianceFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ComplianceFilter>>;
  /** Filter by the object’s `assetId` field. */
  assetId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `complianceId` field. */
  complianceId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `data` field. */
  data?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ComplianceFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ComplianceFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
};

/** A connection to a list of `Compliance` values. */
export type CompliancesConnection = {
  __typename?: 'CompliancesConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<ComplianceAggregates>;
  /** A list of edges which contains the `Compliance` and cursor to aid in pagination. */
  edges: Array<CompliancesEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<ComplianceAggregates>>;
  /** A list of `Compliance` objects. */
  nodes: Array<Maybe<Compliance>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Compliance` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Compliance` values. */
export type CompliancesConnectionGroupedAggregatesArgs = {
  groupBy: Array<CompliancesGroupBy>;
  having?: InputMaybe<CompliancesHavingInput>;
};

/** A `Compliance` edge in the connection. */
export type CompliancesEdge = {
  __typename?: 'CompliancesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Compliance` at the end of the edge. */
  node?: Maybe<Compliance>;
};

/** Grouping methods for `Compliance` for usage during aggregation. */
export enum CompliancesGroupBy {
  AssetId = 'ASSET_ID',
  ComplianceId = 'COMPLIANCE_ID',
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  Data = 'DATA',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
}

/** Conditions for `Compliance` aggregates. */
export type CompliancesHavingInput = {
  AND?: InputMaybe<Array<CompliancesHavingInput>>;
  OR?: InputMaybe<Array<CompliancesHavingInput>>;
};

/** Methods to use when ordering `Compliance`. */
export enum CompliancesOrderBy {
  AssetIdAsc = 'ASSET_ID_ASC',
  AssetIdDesc = 'ASSET_ID_DESC',
  ComplianceIdAsc = 'COMPLIANCE_ID_ASC',
  ComplianceIdDesc = 'COMPLIANCE_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  DataAsc = 'DATA_ASC',
  DataDesc = 'DATA_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
}

/** A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’ */
export type DatetimeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Datetime']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Datetime']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Datetime']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Datetime']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Datetime']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Datetime']['input']>>;
};

export type Debug = Node & {
  __typename?: 'Debug';
  context?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['Datetime']['output'];
  id: Scalars['String']['output'];
  line?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  updatedAt: Scalars['Datetime']['output'];
};

export type DebugAggregates = {
  __typename?: 'DebugAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A filter to be used against `Debug` object types. All fields are combined with a logical ‘and.’ */
export type DebugFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DebugFilter>>;
  /** Filter by the object’s `context` field. */
  context?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `line` field. */
  line?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DebugFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DebugFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** A connection to a list of `Debug` values. */
export type DebugsConnection = {
  __typename?: 'DebugsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<DebugAggregates>;
  /** A list of edges which contains the `Debug` and cursor to aid in pagination. */
  edges: Array<DebugsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<DebugAggregates>>;
  /** A list of `Debug` objects. */
  nodes: Array<Maybe<Debug>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Debug` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Debug` values. */
export type DebugsConnectionGroupedAggregatesArgs = {
  groupBy: Array<DebugsGroupBy>;
  having?: InputMaybe<DebugsHavingInput>;
};

/** A `Debug` edge in the connection. */
export type DebugsEdge = {
  __typename?: 'DebugsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Debug` at the end of the edge. */
  node?: Maybe<Debug>;
};

/** Grouping methods for `Debug` for usage during aggregation. */
export enum DebugsGroupBy {
  Context = 'CONTEXT',
  CreatedAt = 'CREATED_AT',
  Line = 'LINE',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `Debug` aggregates. */
export type DebugsHavingInput = {
  AND?: InputMaybe<Array<DebugsHavingInput>>;
  OR?: InputMaybe<Array<DebugsHavingInput>>;
};

/** Methods to use when ordering `Debug`. */
export enum DebugsOrderBy {
  ContextAsc = 'CONTEXT_ASC',
  ContextDesc = 'CONTEXT_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LineAsc = 'LINE_ASC',
  LineDesc = 'LINE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
}

/** Represents a distribution to the owners of an Asset. e.g. dividend payment */
export type Distribution = Node & {
  __typename?: 'Distribution';
  amount: Scalars['BigFloat']['output'];
  /** Reads a single `Asset` that is related to this `Distribution`. */
  asset?: Maybe<Asset>;
  assetId: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `Block`. */
  blocksByDistributionPaymentDistributionIdAndCreatedBlockId: DistributionBlocksByDistributionPaymentDistributionIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByDistributionPaymentDistributionIdAndUpdatedBlockId: DistributionBlocksByDistributionPaymentDistributionIdAndUpdatedBlockIdManyToManyConnection;
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `Distribution`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  currency: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `DistributionPayment`. */
  distributionPayments: DistributionPaymentsConnection;
  expiresAt?: Maybe<Scalars['BigFloat']['output']>;
  id: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByDistributionPaymentDistributionIdAndTargetId: DistributionIdentitiesByDistributionPaymentDistributionIdAndTargetIdManyToManyConnection;
  /** Reads a single `Identity` that is related to this `Distribution`. */
  identity?: Maybe<Identity>;
  identityId: Scalars['String']['output'];
  localId: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  paymentAt: Scalars['BigFloat']['output'];
  perShare: Scalars['BigFloat']['output'];
  /** Reads a single `Portfolio` that is related to this `Distribution`. */
  portfolio?: Maybe<Portfolio>;
  portfolioId: Scalars['String']['output'];
  remaining: Scalars['BigFloat']['output'];
  taxes: Scalars['BigFloat']['output'];
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `Distribution`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
};

/** Represents a distribution to the owners of an Asset. e.g. dividend payment */
export type DistributionBlocksByDistributionPaymentDistributionIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a distribution to the owners of an Asset. e.g. dividend payment */
export type DistributionBlocksByDistributionPaymentDistributionIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a distribution to the owners of an Asset. e.g. dividend payment */
export type DistributionDistributionPaymentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<DistributionPaymentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DistributionPaymentsOrderBy>>;
};

/** Represents a distribution to the owners of an Asset. e.g. dividend payment */
export type DistributionIdentitiesByDistributionPaymentDistributionIdAndTargetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

export type DistributionAggregates = {
  __typename?: 'DistributionAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A connection to a list of `Block` values, with data from `DistributionPayment`. */
export type DistributionBlocksByDistributionPaymentDistributionIdAndCreatedBlockIdManyToManyConnection =
  {
    __typename?: 'DistributionBlocksByDistributionPaymentDistributionIdAndCreatedBlockIdManyToManyConnection';
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<BlockAggregates>;
    /** A list of edges which contains the `Block`, info from the `DistributionPayment`, and the cursor to aid in pagination. */
    edges: Array<DistributionBlocksByDistributionPaymentDistributionIdAndCreatedBlockIdManyToManyEdge>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<BlockAggregates>>;
    /** A list of `Block` objects. */
    nodes: Array<Maybe<Block>>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Block` you could get from the connection. */
    totalCount: Scalars['Int']['output'];
  };

/** A connection to a list of `Block` values, with data from `DistributionPayment`. */
export type DistributionBlocksByDistributionPaymentDistributionIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `DistributionPayment`. */
export type DistributionBlocksByDistributionPaymentDistributionIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'DistributionBlocksByDistributionPaymentDistributionIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `DistributionPayment`. */
  distributionPaymentsByCreatedBlockId: DistributionPaymentsConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `DistributionPayment`. */
export type DistributionBlocksByDistributionPaymentDistributionIdAndCreatedBlockIdManyToManyEdgeDistributionPaymentsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<DistributionPaymentFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<DistributionPaymentsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `DistributionPayment`. */
export type DistributionBlocksByDistributionPaymentDistributionIdAndUpdatedBlockIdManyToManyConnection =
  {
    __typename?: 'DistributionBlocksByDistributionPaymentDistributionIdAndUpdatedBlockIdManyToManyConnection';
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<BlockAggregates>;
    /** A list of edges which contains the `Block`, info from the `DistributionPayment`, and the cursor to aid in pagination. */
    edges: Array<DistributionBlocksByDistributionPaymentDistributionIdAndUpdatedBlockIdManyToManyEdge>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<BlockAggregates>>;
    /** A list of `Block` objects. */
    nodes: Array<Maybe<Block>>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Block` you could get from the connection. */
    totalCount: Scalars['Int']['output'];
  };

/** A connection to a list of `Block` values, with data from `DistributionPayment`. */
export type DistributionBlocksByDistributionPaymentDistributionIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `DistributionPayment`. */
export type DistributionBlocksByDistributionPaymentDistributionIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'DistributionBlocksByDistributionPaymentDistributionIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `DistributionPayment`. */
  distributionPaymentsByUpdatedBlockId: DistributionPaymentsConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `DistributionPayment`. */
export type DistributionBlocksByDistributionPaymentDistributionIdAndUpdatedBlockIdManyToManyEdgeDistributionPaymentsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<DistributionPaymentFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<DistributionPaymentsOrderBy>>;
  };

/** A filter to be used against `Distribution` object types. All fields are combined with a logical ‘and.’ */
export type DistributionFilter = {
  /** Filter by the object’s `amount` field. */
  amount?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DistributionFilter>>;
  /** Filter by the object’s `assetId` field. */
  assetId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `currency` field. */
  currency?: InputMaybe<StringFilter>;
  /** Filter by the object’s `expiresAt` field. */
  expiresAt?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `identityId` field. */
  identityId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `localId` field. */
  localId?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DistributionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DistributionFilter>>;
  /** Filter by the object’s `paymentAt` field. */
  paymentAt?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `perShare` field. */
  perShare?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `portfolioId` field. */
  portfolioId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `remaining` field. */
  remaining?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `taxes` field. */
  taxes?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
};

/** A connection to a list of `Identity` values, with data from `DistributionPayment`. */
export type DistributionIdentitiesByDistributionPaymentDistributionIdAndTargetIdManyToManyConnection =
  {
    __typename?: 'DistributionIdentitiesByDistributionPaymentDistributionIdAndTargetIdManyToManyConnection';
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<IdentityAggregates>;
    /** A list of edges which contains the `Identity`, info from the `DistributionPayment`, and the cursor to aid in pagination. */
    edges: Array<DistributionIdentitiesByDistributionPaymentDistributionIdAndTargetIdManyToManyEdge>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<IdentityAggregates>>;
    /** A list of `Identity` objects. */
    nodes: Array<Maybe<Identity>>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Identity` you could get from the connection. */
    totalCount: Scalars['Int']['output'];
  };

/** A connection to a list of `Identity` values, with data from `DistributionPayment`. */
export type DistributionIdentitiesByDistributionPaymentDistributionIdAndTargetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `DistributionPayment`. */
export type DistributionIdentitiesByDistributionPaymentDistributionIdAndTargetIdManyToManyEdge = {
  __typename?: 'DistributionIdentitiesByDistributionPaymentDistributionIdAndTargetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `DistributionPayment`. */
  distributionPaymentsByTargetId: DistributionPaymentsConnection;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
};

/** A `Identity` edge in the connection, with data from `DistributionPayment`. */
export type DistributionIdentitiesByDistributionPaymentDistributionIdAndTargetIdManyToManyEdgeDistributionPaymentsByTargetIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<DistributionPaymentFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<DistributionPaymentsOrderBy>>;
  };

/** Represents an owner of an asset collecting a distribution e.g. accepting a dividend */
export type DistributionPayment = Node & {
  __typename?: 'DistributionPayment';
  amount: Scalars['BigFloat']['output'];
  amountAfterTax: Scalars['BigFloat']['output'];
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `DistributionPayment`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  datetime: Scalars['Datetime']['output'];
  /** Reads a single `Distribution` that is related to this `DistributionPayment`. */
  distribution?: Maybe<Distribution>;
  distributionId: Scalars['String']['output'];
  eventId: EventIdEnum;
  id: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  reclaimed: Scalars['Boolean']['output'];
  /** Reads a single `Identity` that is related to this `DistributionPayment`. */
  target?: Maybe<Identity>;
  targetId: Scalars['String']['output'];
  tax: Scalars['BigFloat']['output'];
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `DistributionPayment`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
};

export type DistributionPaymentAggregates = {
  __typename?: 'DistributionPaymentAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A filter to be used against `DistributionPayment` object types. All fields are combined with a logical ‘and.’ */
export type DistributionPaymentFilter = {
  /** Filter by the object’s `amount` field. */
  amount?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountAfterTax` field. */
  amountAfterTax?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DistributionPaymentFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `datetime` field. */
  datetime?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `distributionId` field. */
  distributionId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `eventId` field. */
  eventId?: InputMaybe<EventIdEnumFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DistributionPaymentFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DistributionPaymentFilter>>;
  /** Filter by the object’s `reclaimed` field. */
  reclaimed?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `targetId` field. */
  targetId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `tax` field. */
  tax?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
};

/** A connection to a list of `DistributionPayment` values. */
export type DistributionPaymentsConnection = {
  __typename?: 'DistributionPaymentsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<DistributionPaymentAggregates>;
  /** A list of edges which contains the `DistributionPayment` and cursor to aid in pagination. */
  edges: Array<DistributionPaymentsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<DistributionPaymentAggregates>>;
  /** A list of `DistributionPayment` objects. */
  nodes: Array<Maybe<DistributionPayment>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DistributionPayment` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `DistributionPayment` values. */
export type DistributionPaymentsConnectionGroupedAggregatesArgs = {
  groupBy: Array<DistributionPaymentsGroupBy>;
  having?: InputMaybe<DistributionPaymentsHavingInput>;
};

/** A `DistributionPayment` edge in the connection. */
export type DistributionPaymentsEdge = {
  __typename?: 'DistributionPaymentsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DistributionPayment` at the end of the edge. */
  node?: Maybe<DistributionPayment>;
};

/** Grouping methods for `DistributionPayment` for usage during aggregation. */
export enum DistributionPaymentsGroupBy {
  Amount = 'AMOUNT',
  AmountAfterTax = 'AMOUNT_AFTER_TAX',
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  Datetime = 'DATETIME',
  DistributionId = 'DISTRIBUTION_ID',
  EventId = 'EVENT_ID',
  Reclaimed = 'RECLAIMED',
  TargetId = 'TARGET_ID',
  Tax = 'TAX',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
}

/** Conditions for `DistributionPayment` aggregates. */
export type DistributionPaymentsHavingInput = {
  AND?: InputMaybe<Array<DistributionPaymentsHavingInput>>;
  OR?: InputMaybe<Array<DistributionPaymentsHavingInput>>;
};

/** Methods to use when ordering `DistributionPayment`. */
export enum DistributionPaymentsOrderBy {
  AmountAfterTaxAsc = 'AMOUNT_AFTER_TAX_ASC',
  AmountAfterTaxDesc = 'AMOUNT_AFTER_TAX_DESC',
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  DatetimeAsc = 'DATETIME_ASC',
  DatetimeDesc = 'DATETIME_DESC',
  DistributionIdAsc = 'DISTRIBUTION_ID_ASC',
  DistributionIdDesc = 'DISTRIBUTION_ID_DESC',
  EventIdAsc = 'EVENT_ID_ASC',
  EventIdDesc = 'EVENT_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ReclaimedAsc = 'RECLAIMED_ASC',
  ReclaimedDesc = 'RECLAIMED_DESC',
  TargetIdAsc = 'TARGET_ID_ASC',
  TargetIdDesc = 'TARGET_ID_DESC',
  TaxAsc = 'TAX_ASC',
  TaxDesc = 'TAX_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
}

/** A connection to a list of `Distribution` values. */
export type DistributionsConnection = {
  __typename?: 'DistributionsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<DistributionAggregates>;
  /** A list of edges which contains the `Distribution` and cursor to aid in pagination. */
  edges: Array<DistributionsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<DistributionAggregates>>;
  /** A list of `Distribution` objects. */
  nodes: Array<Maybe<Distribution>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Distribution` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Distribution` values. */
export type DistributionsConnectionGroupedAggregatesArgs = {
  groupBy: Array<DistributionsGroupBy>;
  having?: InputMaybe<DistributionsHavingInput>;
};

/** A `Distribution` edge in the connection. */
export type DistributionsEdge = {
  __typename?: 'DistributionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Distribution` at the end of the edge. */
  node?: Maybe<Distribution>;
};

/** Grouping methods for `Distribution` for usage during aggregation. */
export enum DistributionsGroupBy {
  Amount = 'AMOUNT',
  AssetId = 'ASSET_ID',
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  Currency = 'CURRENCY',
  ExpiresAt = 'EXPIRES_AT',
  IdentityId = 'IDENTITY_ID',
  LocalId = 'LOCAL_ID',
  PaymentAt = 'PAYMENT_AT',
  PerShare = 'PER_SHARE',
  PortfolioId = 'PORTFOLIO_ID',
  Remaining = 'REMAINING',
  Taxes = 'TAXES',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
}

/** Conditions for `Distribution` aggregates. */
export type DistributionsHavingInput = {
  AND?: InputMaybe<Array<DistributionsHavingInput>>;
  OR?: InputMaybe<Array<DistributionsHavingInput>>;
};

/** Methods to use when ordering `Distribution`. */
export enum DistributionsOrderBy {
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  AssetIdAsc = 'ASSET_ID_ASC',
  AssetIdDesc = 'ASSET_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  CurrencyAsc = 'CURRENCY_ASC',
  CurrencyDesc = 'CURRENCY_DESC',
  DistributionPaymentsCountAsc = 'DISTRIBUTION_PAYMENTS_COUNT_ASC',
  DistributionPaymentsCountDesc = 'DISTRIBUTION_PAYMENTS_COUNT_DESC',
  ExpiresAtAsc = 'EXPIRES_AT_ASC',
  ExpiresAtDesc = 'EXPIRES_AT_DESC',
  IdentityIdAsc = 'IDENTITY_ID_ASC',
  IdentityIdDesc = 'IDENTITY_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LocalIdAsc = 'LOCAL_ID_ASC',
  LocalIdDesc = 'LOCAL_ID_DESC',
  Natural = 'NATURAL',
  PaymentAtAsc = 'PAYMENT_AT_ASC',
  PaymentAtDesc = 'PAYMENT_AT_DESC',
  PerShareAsc = 'PER_SHARE_ASC',
  PerShareDesc = 'PER_SHARE_DESC',
  PortfolioIdAsc = 'PORTFOLIO_ID_ASC',
  PortfolioIdDesc = 'PORTFOLIO_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RemainingAsc = 'REMAINING_ASC',
  RemainingDesc = 'REMAINING_DESC',
  TaxesAsc = 'TAXES_ASC',
  TaxesDesc = 'TAXES_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
}

/** Information of a chain state transition on. For most use cases a more specific entity should be queried */
export type Event = Node & {
  __typename?: 'Event';
  attributes?: Maybe<Scalars['JSON']['output']>;
  attributesTxt: Scalars['String']['output'];
  /** Reads a single `Block` that is related to this `Event`. */
  block?: Maybe<Block>;
  blockId: Scalars['String']['output'];
  claimExpiry?: Maybe<Scalars['String']['output']>;
  claimIssuer?: Maybe<Scalars['String']['output']>;
  claimScope?: Maybe<Scalars['String']['output']>;
  claimType?: Maybe<Scalars['String']['output']>;
  corporateActionTicker?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['Datetime']['output'];
  eventArg0?: Maybe<Scalars['String']['output']>;
  eventArg1?: Maybe<Scalars['String']['output']>;
  eventArg2?: Maybe<Scalars['String']['output']>;
  eventArg3?: Maybe<Scalars['String']['output']>;
  eventId: EventIdEnum;
  eventIdx: Scalars['Int']['output'];
  extrinsicIdx?: Maybe<Scalars['Int']['output']>;
  fundraiserOfferingAsset?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  moduleId: ModuleIdEnum;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  specVersionId: Scalars['Int']['output'];
  transferTo?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['Datetime']['output'];
};

export type EventAggregates = {
  __typename?: 'EventAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A filter to be used against `Event` object types. All fields are combined with a logical ‘and.’ */
export type EventFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<EventFilter>>;
  /** Filter by the object’s `attributes` field. */
  attributes?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `attributesTxt` field. */
  attributesTxt?: InputMaybe<StringFilter>;
  /** Filter by the object’s `blockId` field. */
  blockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `claimExpiry` field. */
  claimExpiry?: InputMaybe<StringFilter>;
  /** Filter by the object’s `claimIssuer` field. */
  claimIssuer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `claimScope` field. */
  claimScope?: InputMaybe<StringFilter>;
  /** Filter by the object’s `claimType` field. */
  claimType?: InputMaybe<StringFilter>;
  /** Filter by the object’s `corporateActionTicker` field. */
  corporateActionTicker?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `eventArg0` field. */
  eventArg0?: InputMaybe<StringFilter>;
  /** Filter by the object’s `eventArg1` field. */
  eventArg1?: InputMaybe<StringFilter>;
  /** Filter by the object’s `eventArg2` field. */
  eventArg2?: InputMaybe<StringFilter>;
  /** Filter by the object’s `eventArg3` field. */
  eventArg3?: InputMaybe<StringFilter>;
  /** Filter by the object’s `eventId` field. */
  eventId?: InputMaybe<EventIdEnumFilter>;
  /** Filter by the object’s `eventIdx` field. */
  eventIdx?: InputMaybe<IntFilter>;
  /** Filter by the object’s `extrinsicIdx` field. */
  extrinsicIdx?: InputMaybe<IntFilter>;
  /** Filter by the object’s `fundraiserOfferingAsset` field. */
  fundraiserOfferingAsset?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `moduleId` field. */
  moduleId?: InputMaybe<ModuleIdEnumFilter>;
  /** Negates the expression. */
  not?: InputMaybe<EventFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<EventFilter>>;
  /** Filter by the object’s `specVersionId` field. */
  specVersionId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `transferTo` field. */
  transferTo?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/**  Events are emitted when chain state is changed. This enum represents all known events */
export enum EventIdEnum {
  AcceptedPayingKey = 'AcceptedPayingKey',
  AccountBalanceBurned = 'AccountBalanceBurned',
  ActiveLimitChanged = 'ActiveLimitChanged',
  ActivePipLimitChanged = 'ActivePipLimitChanged',
  AdminChanged = 'AdminChanged',
  AffirmationWithdrawn = 'AffirmationWithdrawn',
  AgentAdded = 'AgentAdded',
  AgentRemoved = 'AgentRemoved',
  AllGood = 'AllGood',
  Approval = 'Approval',
  Approved = 'Approved',
  AssetBalanceUpdated = 'AssetBalanceUpdated',
  AssetCompliancePaused = 'AssetCompliancePaused',
  AssetComplianceReplaced = 'AssetComplianceReplaced',
  AssetComplianceReset = 'AssetComplianceReset',
  AssetComplianceResumed = 'AssetComplianceResumed',
  AssetCreated = 'AssetCreated',
  AssetDidRegistered = 'AssetDidRegistered',
  AssetFrozen = 'AssetFrozen',
  AssetOwnershipTransferred = 'AssetOwnershipTransferred',
  AssetPurchased = 'AssetPurchased',
  AssetRenamed = 'AssetRenamed',
  AssetRuleChanged = 'AssetRuleChanged',
  AssetRuleRemoved = 'AssetRuleRemoved',
  AssetRulesPaused = 'AssetRulesPaused',
  AssetRulesReplaced = 'AssetRulesReplaced',
  AssetRulesReset = 'AssetRulesReset',
  AssetRulesResumed = 'AssetRulesResumed',
  AssetStatsUpdated = 'AssetStatsUpdated',
  AssetTypeChanged = 'AssetTypeChanged',
  AssetUnfrozen = 'AssetUnfrozen',
  AuthorizationAdded = 'AuthorizationAdded',
  AuthorizationConsumed = 'AuthorizationConsumed',
  AuthorizationRejected = 'AuthorizationRejected',
  AuthorizationRetryLimitReached = 'AuthorizationRetryLimitReached',
  AuthorizationRevoked = 'AuthorizationRevoked',
  AuthorizedPayingKey = 'AuthorizedPayingKey',
  BalanceSet = 'BalanceSet',
  BallotCancelled = 'BallotCancelled',
  BallotCreated = 'BallotCreated',
  BatchCompleted = 'BatchCompleted',
  BatchCompletedOld = 'BatchCompletedOld',
  BatchCompletedWithErrors = 'BatchCompletedWithErrors',
  BatchInterrupted = 'BatchInterrupted',
  BatchInterruptedOld = 'BatchInterruptedOld',
  BatchOptimisticFailed = 'BatchOptimisticFailed',
  BenefitClaimed = 'BenefitClaimed',
  Bonded = 'Bonded',
  BridgeLimitUpdated = 'BridgeLimitUpdated',
  BridgeTxFailed = 'BridgeTxFailed',
  BridgeTxScheduleFailed = 'BridgeTxScheduleFailed',
  BridgeTxScheduled = 'BridgeTxScheduled',
  Bridged = 'Bridged',
  CaaTransferred = 'CAATransferred',
  CaInitiated = 'CAInitiated',
  CaLinkedToDoc = 'CALinkedToDoc',
  CaRemoved = 'CARemoved',
  CallLookupFailed = 'CallLookupFailed',
  CallUnavailable = 'CallUnavailable',
  Called = 'Called',
  Canceled = 'Canceled',
  CddClaimsInvalidated = 'CddClaimsInvalidated',
  CddRequirementForMasterKeyUpdated = 'CddRequirementForMasterKeyUpdated',
  CddRequirementForPrimaryKeyUpdated = 'CddRequirementForPrimaryKeyUpdated',
  CddStatus = 'CddStatus',
  CheckpointCreated = 'CheckpointCreated',
  ChildDidCreated = 'ChildDidCreated',
  ChildDidUnlinked = 'ChildDidUnlinked',
  ClaimAdded = 'ClaimAdded',
  ClaimRevoked = 'ClaimRevoked',
  ClassicTickerClaimed = 'ClassicTickerClaimed',
  Cleared = 'Cleared',
  Closed = 'Closed',
  CodeRemoved = 'CodeRemoved',
  CodeStored = 'CodeStored',
  CodeUpdated = 'CodeUpdated',
  CoefficientSet = 'CoefficientSet',
  CommissionCapUpdated = 'CommissionCapUpdated',
  ComplianceRequirementChanged = 'ComplianceRequirementChanged',
  ComplianceRequirementCreated = 'ComplianceRequirementCreated',
  ComplianceRequirementRemoved = 'ComplianceRequirementRemoved',
  ContractCodeUpdated = 'ContractCodeUpdated',
  ContractEmitted = 'ContractEmitted',
  ContractExecution = 'ContractExecution',
  ControllerChanged = 'ControllerChanged',
  ControllerRedemption = 'ControllerRedemption',
  ControllerTransfer = 'ControllerTransfer',
  Created = 'Created',
  CustodyAllowanceChanged = 'CustodyAllowanceChanged',
  CustodyTransfer = 'CustodyTransfer',
  CustomAssetTypeExists = 'CustomAssetTypeExists',
  CustomAssetTypeRegistered = 'CustomAssetTypeRegistered',
  CustomClaimTypeAdded = 'CustomClaimTypeAdded',
  DefaultEnactmentPeriodChanged = 'DefaultEnactmentPeriodChanged',
  DefaultTargetIdentitiesChanged = 'DefaultTargetIdentitiesChanged',
  DefaultWithholdingTaxChanged = 'DefaultWithholdingTaxChanged',
  DelegateCalled = 'DelegateCalled',
  DidCreated = 'DidCreated',
  DidStatus = 'DidStatus',
  DidWithholdingTaxChanged = 'DidWithholdingTaxChanged',
  Dispatched = 'Dispatched',
  DispatchedAs = 'DispatchedAs',
  DividendCanceled = 'DividendCanceled',
  DividendCreated = 'DividendCreated',
  DividendPaidOutToUser = 'DividendPaidOutToUser',
  DividendRemainingClaimed = 'DividendRemainingClaimed',
  DivisibilityChanged = 'DivisibilityChanged',
  DocumentAdded = 'DocumentAdded',
  DocumentRemoved = 'DocumentRemoved',
  Dummy = 'Dummy',
  Endowed = 'Endowed',
  EraPayout = 'EraPayout',
  Evicted = 'Evicted',
  Executed = 'Executed',
  ExecutionCancellingFailed = 'ExecutionCancellingFailed',
  ExecutionScheduled = 'ExecutionScheduled',
  ExecutionSchedulingFailed = 'ExecutionSchedulingFailed',
  ExemptedUpdated = 'ExemptedUpdated',
  ExemptionListModified = 'ExemptionListModified',
  ExemptionsAdded = 'ExemptionsAdded',
  ExemptionsRemoved = 'ExemptionsRemoved',
  ExpiresAfterUpdated = 'ExpiresAfterUpdated',
  ExpiryScheduled = 'ExpiryScheduled',
  ExpirySchedulingFailed = 'ExpirySchedulingFailed',
  ExtensionAdded = 'ExtensionAdded',
  ExtensionArchived = 'ExtensionArchived',
  ExtensionRemoved = 'ExtensionRemoved',
  ExtensionUnArchive = 'ExtensionUnArchive',
  ExtrinsicFailed = 'ExtrinsicFailed',
  ExtrinsicSuccess = 'ExtrinsicSuccess',
  FailedToExecuteInstruction = 'FailedToExecuteInstruction',
  FeeCharged = 'FeeCharged',
  FeeSet = 'FeeSet',
  FinalVotes = 'FinalVotes',
  FreezeAdminAdded = 'FreezeAdminAdded',
  FreezeAdminRemoved = 'FreezeAdminRemoved',
  Frozen = 'Frozen',
  FrozenTx = 'FrozenTx',
  FundingRoundSet = 'FundingRoundSet',
  FundraiserClosed = 'FundraiserClosed',
  FundraiserCreated = 'FundraiserCreated',
  FundraiserFrozen = 'FundraiserFrozen',
  FundraiserUnfrozen = 'FundraiserUnfrozen',
  FundraiserWindowModifed = 'FundraiserWindowModifed',
  FundraiserWindowModified = 'FundraiserWindowModified',
  FundsMovedBetweenPortfolios = 'FundsMovedBetweenPortfolios',
  FundsRaised = 'FundsRaised',
  FungibleTokensMovedBetweenPortfolios = 'FungibleTokensMovedBetweenPortfolios',
  GlobalCommissionUpdated = 'GlobalCommissionUpdated',
  GroupChanged = 'GroupChanged',
  GroupCreated = 'GroupCreated',
  GroupPermissionsUpdated = 'GroupPermissionsUpdated',
  HeartbeatReceived = 'HeartbeatReceived',
  HistoricalPipsPruned = 'HistoricalPipsPruned',
  IdentifiersUpdated = 'IdentifiersUpdated',
  IndexAssigned = 'IndexAssigned',
  IndexFreed = 'IndexFreed',
  IndexFrozen = 'IndexFrozen',
  IndividualCommissionEnabled = 'IndividualCommissionEnabled',
  Instantiated = 'Instantiated',
  InstantiationFeeChanged = 'InstantiationFeeChanged',
  InstantiationFreezed = 'InstantiationFreezed',
  InstantiationUnFreezed = 'InstantiationUnFreezed',
  InstructionAffirmed = 'InstructionAffirmed',
  InstructionAuthorized = 'InstructionAuthorized',
  InstructionCreated = 'InstructionCreated',
  InstructionExecuted = 'InstructionExecuted',
  InstructionFailed = 'InstructionFailed',
  InstructionRejected = 'InstructionRejected',
  InstructionRescheduled = 'InstructionRescheduled',
  InstructionUnauthorized = 'InstructionUnauthorized',
  InstructionV2Created = 'InstructionV2Created',
  InvalidatedNominators = 'InvalidatedNominators',
  Invested = 'Invested',
  InvestorUniquenessClaimNotAllowed = 'InvestorUniquenessClaimNotAllowed',
  IsIssuable = 'IsIssuable',
  Issued = 'Issued',
  IssuedNft = 'IssuedNFT',
  ItemCompleted = 'ItemCompleted',
  ItemFailed = 'ItemFailed',
  ItnRewardClaimed = 'ItnRewardClaimed',
  KeyChanged = 'KeyChanged',
  KilledAccount = 'KilledAccount',
  LegFailedExecution = 'LegFailedExecution',
  LocalMetadataKeyDeleted = 'LocalMetadataKeyDeleted',
  MasterKeyUpdated = 'MasterKeyUpdated',
  MaxDetailsLengthChanged = 'MaxDetailsLengthChanged',
  MaxPipSkipCountChanged = 'MaxPipSkipCountChanged',
  MaximumSchedulesComplexityChanged = 'MaximumSchedulesComplexityChanged',
  MemberAdded = 'MemberAdded',
  MemberRemoved = 'MemberRemoved',
  MemberRevoked = 'MemberRevoked',
  MembersReset = 'MembersReset',
  MembersSwapped = 'MembersSwapped',
  MetaChanged = 'MetaChanged',
  MetadataValueDeleted = 'MetadataValueDeleted',
  MinimumBondThresholdUpdated = 'MinimumBondThresholdUpdated',
  MinimumProposalDepositChanged = 'MinimumProposalDepositChanged',
  MockInvestorUidCreated = 'MockInvestorUIDCreated',
  MovedBetweenPortfolios = 'MovedBetweenPortfolios',
  MultiSigCreated = 'MultiSigCreated',
  MultiSigSignaturesRequiredChanged = 'MultiSigSignaturesRequiredChanged',
  MultiSigSignerAdded = 'MultiSigSignerAdded',
  MultiSigSignerAuthorized = 'MultiSigSignerAuthorized',
  MultiSigSignerRemoved = 'MultiSigSignerRemoved',
  NftPortfolioUpdated = 'NFTPortfolioUpdated',
  NfTsMovedBetweenPortfolios = 'NFTsMovedBetweenPortfolios',
  NewAccount = 'NewAccount',
  NewAssetRuleCreated = 'NewAssetRuleCreated',
  NewAuthorities = 'NewAuthorities',
  NewSession = 'NewSession',
  NftCollectionCreated = 'NftCollectionCreated',
  Nominated = 'Nominated',
  Noted = 'Noted',
  OffChainAuthorizationRevoked = 'OffChainAuthorizationRevoked',
  Offence = 'Offence',
  OldSlashingReportDiscarded = 'OldSlashingReportDiscarded',
  Paused = 'Paused',
  PendingPipExpiryChanged = 'PendingPipExpiryChanged',
  PeriodicFailed = 'PeriodicFailed',
  PermanentlyOverweight = 'PermanentlyOverweight',
  PermissionedIdentityAdded = 'PermissionedIdentityAdded',
  PermissionedIdentityRemoved = 'PermissionedIdentityRemoved',
  PermissionedValidatorAdded = 'PermissionedValidatorAdded',
  PermissionedValidatorRemoved = 'PermissionedValidatorRemoved',
  PermissionedValidatorStatusChanged = 'PermissionedValidatorStatusChanged',
  PipClosed = 'PipClosed',
  PipSkipped = 'PipSkipped',
  PlaceholderFillBlock = 'PlaceholderFillBlock',
  PortfolioCreated = 'PortfolioCreated',
  PortfolioCustodianChanged = 'PortfolioCustodianChanged',
  PortfolioDeleted = 'PortfolioDeleted',
  PortfolioRenamed = 'PortfolioRenamed',
  PrimaryIssuanceAgentTransfered = 'PrimaryIssuanceAgentTransfered',
  PrimaryIssuanceAgentTransferred = 'PrimaryIssuanceAgentTransferred',
  PrimaryKeyUpdated = 'PrimaryKeyUpdated',
  ProposalAdded = 'ProposalAdded',
  ProposalApproved = 'ProposalApproved',
  ProposalBondAdjusted = 'ProposalBondAdjusted',
  ProposalCoolOffPeriodChanged = 'ProposalCoolOffPeriodChanged',
  ProposalCreated = 'ProposalCreated',
  ProposalDetailsAmended = 'ProposalDetailsAmended',
  ProposalDurationChanged = 'ProposalDurationChanged',
  ProposalExecuted = 'ProposalExecuted',
  ProposalExecutionFailed = 'ProposalExecutionFailed',
  ProposalRefund = 'ProposalRefund',
  ProposalRejected = 'ProposalRejected',
  ProposalRejectionVote = 'ProposalRejectionVote',
  ProposalStateUpdated = 'ProposalStateUpdated',
  Proposed = 'Proposed',
  PutCodeFlagChanged = 'PutCodeFlagChanged',
  QuorumThresholdChanged = 'QuorumThresholdChanged',
  RcvChanged = 'RCVChanged',
  RangeChanged = 'RangeChanged',
  RangeProofAdded = 'RangeProofAdded',
  RangeProofVerified = 'RangeProofVerified',
  ReceiptClaimed = 'ReceiptClaimed',
  ReceiptUnclaimed = 'ReceiptUnclaimed',
  ReceiptValidityChanged = 'ReceiptValidityChanged',
  Reclaimed = 'Reclaimed',
  RecordDateChanged = 'RecordDateChanged',
  Redeemed = 'Redeemed',
  RedeemedNft = 'RedeemedNFT',
  ReferendumCreated = 'ReferendumCreated',
  ReferendumScheduled = 'ReferendumScheduled',
  ReferendumStateUpdated = 'ReferendumStateUpdated',
  RegisterAssetMetadataGlobalType = 'RegisterAssetMetadataGlobalType',
  RegisterAssetMetadataLocalType = 'RegisterAssetMetadataLocalType',
  Rejected = 'Rejected',
  RelayedTx = 'RelayedTx',
  ReleaseCoordinatorUpdated = 'ReleaseCoordinatorUpdated',
  Remarked = 'Remarked',
  Removed = 'Removed',
  RemovedPayingKey = 'RemovedPayingKey',
  Requested = 'Requested',
  ReserveRepatriated = 'ReserveRepatriated',
  Reserved = 'Reserved',
  Restored = 'Restored',
  Resumed = 'Resumed',
  Reward = 'Reward',
  RewardPaymentSchedulingInterrupted = 'RewardPaymentSchedulingInterrupted',
  ScheduleCreated = 'ScheduleCreated',
  ScheduleRemoved = 'ScheduleRemoved',
  ScheduleUpdated = 'ScheduleUpdated',
  Scheduled = 'Scheduled',
  SchedulingFailed = 'SchedulingFailed',
  SecondaryKeyLeftIdentity = 'SecondaryKeyLeftIdentity',
  SecondaryKeyPermissionsUpdated = 'SecondaryKeyPermissionsUpdated',
  SecondaryKeysAdded = 'SecondaryKeysAdded',
  SecondaryKeysFrozen = 'SecondaryKeysFrozen',
  SecondaryKeysRemoved = 'SecondaryKeysRemoved',
  SecondaryKeysUnfrozen = 'SecondaryKeysUnfrozen',
  SecondaryPermissionsUpdated = 'SecondaryPermissionsUpdated',
  SetAssetMetadataValue = 'SetAssetMetadataValue',
  SetAssetMetadataValueDetails = 'SetAssetMetadataValueDetails',
  SetAssetTransferCompliance = 'SetAssetTransferCompliance',
  SettlementManuallyExecuted = 'SettlementManuallyExecuted',
  SignerLeft = 'SignerLeft',
  SigningKeysAdded = 'SigningKeysAdded',
  SigningKeysFrozen = 'SigningKeysFrozen',
  SigningKeysRemoved = 'SigningKeysRemoved',
  SigningKeysUnfrozen = 'SigningKeysUnfrozen',
  SigningPermissionsUpdated = 'SigningPermissionsUpdated',
  Slash = 'Slash',
  SlashingAllowedForChanged = 'SlashingAllowedForChanged',
  SlashingParamsUpdated = 'SlashingParamsUpdated',
  SnapshotCleared = 'SnapshotCleared',
  SnapshotResultsEnacted = 'SnapshotResultsEnacted',
  SnapshotTaken = 'SnapshotTaken',
  SolutionStored = 'SolutionStored',
  SomeOffline = 'SomeOffline',
  StakingElection = 'StakingElection',
  StatTypesAdded = 'StatTypesAdded',
  StatTypesRemoved = 'StatTypesRemoved',
  Sudid = 'Sudid',
  SudoAsDone = 'SudoAsDone',
  TemplateInstantiationFeeChanged = 'TemplateInstantiationFeeChanged',
  TemplateMetaUrlChanged = 'TemplateMetaUrlChanged',
  TemplateOwnershipTransferred = 'TemplateOwnershipTransferred',
  TemplateUsageFeeChanged = 'TemplateUsageFeeChanged',
  Terminated = 'Terminated',
  TickerRegistered = 'TickerRegistered',
  TickerTransferred = 'TickerTransferred',
  TimelockChanged = 'TimelockChanged',
  TransactionFeePaid = 'TransactionFeePaid',
  Transfer = 'Transfer',
  TransferConditionExemptionsAdded = 'TransferConditionExemptionsAdded',
  TransferConditionExemptionsRemoved = 'TransferConditionExemptionsRemoved',
  TransferManagerAdded = 'TransferManagerAdded',
  TransferManagerRemoved = 'TransferManagerRemoved',
  TransferWithData = 'TransferWithData',
  TreasuryDidSet = 'TreasuryDidSet',
  TreasuryDisbursement = 'TreasuryDisbursement',
  TreasuryDisbursementFailed = 'TreasuryDisbursementFailed',
  TreasuryReimbursement = 'TreasuryReimbursement',
  TrustedDefaultClaimIssuerAdded = 'TrustedDefaultClaimIssuerAdded',
  TrustedDefaultClaimIssuerRemoved = 'TrustedDefaultClaimIssuerRemoved',
  TxRemoved = 'TxRemoved',
  TxsHandled = 'TxsHandled',
  Unbonded = 'Unbonded',
  UnexpectedError = 'UnexpectedError',
  Unfrozen = 'Unfrozen',
  UnfrozenTx = 'UnfrozenTx',
  Unreserved = 'Unreserved',
  UpdatedPolyxLimit = 'UpdatedPolyxLimit',
  UserPortfolios = 'UserPortfolios',
  VenueCreated = 'VenueCreated',
  VenueDetailsUpdated = 'VenueDetailsUpdated',
  VenueFiltering = 'VenueFiltering',
  VenueSignersUpdated = 'VenueSignersUpdated',
  VenueTypeUpdated = 'VenueTypeUpdated',
  VenueUnauthorized = 'VenueUnauthorized',
  VenueUpdated = 'VenueUpdated',
  VenuesAllowed = 'VenuesAllowed',
  VenuesBlocked = 'VenuesBlocked',
  VoteCast = 'VoteCast',
  VoteEnactReferendum = 'VoteEnactReferendum',
  VoteRejectReferendum = 'VoteRejectReferendum',
  VoteRetracted = 'VoteRetracted',
  VoteThresholdUpdated = 'VoteThresholdUpdated',
  Voted = 'Voted',
  Withdrawn = 'Withdrawn',
}

/** A filter to be used against EventIdEnum fields. All fields are combined with a logical ‘and.’ */
export type EventIdEnumFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<EventIdEnum>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<EventIdEnum>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<EventIdEnum>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<EventIdEnum>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<EventIdEnum>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<EventIdEnum>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<EventIdEnum>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<EventIdEnum>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<EventIdEnum>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<EventIdEnum>>;
};

/** A connection to a list of `Event` values. */
export type EventsConnection = {
  __typename?: 'EventsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<EventAggregates>;
  /** A list of edges which contains the `Event` and cursor to aid in pagination. */
  edges: Array<EventsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<EventAggregates>>;
  /** A list of `Event` objects. */
  nodes: Array<Maybe<Event>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Event` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Event` values. */
export type EventsConnectionGroupedAggregatesArgs = {
  groupBy: Array<EventsGroupBy>;
  having?: InputMaybe<EventsHavingInput>;
};

/** A `Event` edge in the connection. */
export type EventsEdge = {
  __typename?: 'EventsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Event` at the end of the edge. */
  node?: Maybe<Event>;
};

/** Grouping methods for `Event` for usage during aggregation. */
export enum EventsGroupBy {
  Attributes = 'ATTRIBUTES',
  AttributesTxt = 'ATTRIBUTES_TXT',
  BlockId = 'BLOCK_ID',
  ClaimExpiry = 'CLAIM_EXPIRY',
  ClaimIssuer = 'CLAIM_ISSUER',
  ClaimScope = 'CLAIM_SCOPE',
  ClaimType = 'CLAIM_TYPE',
  CorporateActionTicker = 'CORPORATE_ACTION_TICKER',
  CreatedAt = 'CREATED_AT',
  EventArg_0 = 'EVENT_ARG_0',
  EventArg_1 = 'EVENT_ARG_1',
  EventArg_2 = 'EVENT_ARG_2',
  EventArg_3 = 'EVENT_ARG_3',
  EventId = 'EVENT_ID',
  EventIdx = 'EVENT_IDX',
  ExtrinsicIdx = 'EXTRINSIC_IDX',
  FundraiserOfferingAsset = 'FUNDRAISER_OFFERING_ASSET',
  ModuleId = 'MODULE_ID',
  SpecVersionId = 'SPEC_VERSION_ID',
  TransferTo = 'TRANSFER_TO',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `Event` aggregates. */
export type EventsHavingInput = {
  AND?: InputMaybe<Array<EventsHavingInput>>;
  OR?: InputMaybe<Array<EventsHavingInput>>;
};

/** Methods to use when ordering `Event`. */
export enum EventsOrderBy {
  AttributesAsc = 'ATTRIBUTES_ASC',
  AttributesDesc = 'ATTRIBUTES_DESC',
  AttributesTxtAsc = 'ATTRIBUTES_TXT_ASC',
  AttributesTxtDesc = 'ATTRIBUTES_TXT_DESC',
  BlockIdAsc = 'BLOCK_ID_ASC',
  BlockIdDesc = 'BLOCK_ID_DESC',
  ClaimExpiryAsc = 'CLAIM_EXPIRY_ASC',
  ClaimExpiryDesc = 'CLAIM_EXPIRY_DESC',
  ClaimIssuerAsc = 'CLAIM_ISSUER_ASC',
  ClaimIssuerDesc = 'CLAIM_ISSUER_DESC',
  ClaimScopeAsc = 'CLAIM_SCOPE_ASC',
  ClaimScopeDesc = 'CLAIM_SCOPE_DESC',
  ClaimTypeAsc = 'CLAIM_TYPE_ASC',
  ClaimTypeDesc = 'CLAIM_TYPE_DESC',
  CorporateActionTickerAsc = 'CORPORATE_ACTION_TICKER_ASC',
  CorporateActionTickerDesc = 'CORPORATE_ACTION_TICKER_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  EventArg_0Asc = 'EVENT_ARG_0_ASC',
  EventArg_0Desc = 'EVENT_ARG_0_DESC',
  EventArg_1Asc = 'EVENT_ARG_1_ASC',
  EventArg_1Desc = 'EVENT_ARG_1_DESC',
  EventArg_2Asc = 'EVENT_ARG_2_ASC',
  EventArg_2Desc = 'EVENT_ARG_2_DESC',
  EventArg_3Asc = 'EVENT_ARG_3_ASC',
  EventArg_3Desc = 'EVENT_ARG_3_DESC',
  EventIdxAsc = 'EVENT_IDX_ASC',
  EventIdxDesc = 'EVENT_IDX_DESC',
  EventIdAsc = 'EVENT_ID_ASC',
  EventIdDesc = 'EVENT_ID_DESC',
  ExtrinsicIdxAsc = 'EXTRINSIC_IDX_ASC',
  ExtrinsicIdxDesc = 'EXTRINSIC_IDX_DESC',
  FundraiserOfferingAssetAsc = 'FUNDRAISER_OFFERING_ASSET_ASC',
  FundraiserOfferingAssetDesc = 'FUNDRAISER_OFFERING_ASSET_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModuleIdAsc = 'MODULE_ID_ASC',
  ModuleIdDesc = 'MODULE_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SpecVersionIdAsc = 'SPEC_VERSION_ID_ASC',
  SpecVersionIdDesc = 'SPEC_VERSION_ID_DESC',
  TransferToAsc = 'TRANSFER_TO_ASC',
  TransferToDesc = 'TRANSFER_TO_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
}

/**
 * Represents external data included into the chain. Virtually all user actions, as well as runtime operations are extrinsics
 *
 * Usually extrinsics are signed. When the block author includes data, e.g. `timestamp.set` then the signature is implied. This is indicated with `signed = 0`
 */
export type Extrinsic = Node & {
  __typename?: 'Extrinsic';
  address?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Block` that is related to this `Extrinsic`. */
  block?: Maybe<Block>;
  blockId: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `Block`. */
  blocksByPolyxTransactionExtrinsicIdAndCreatedBlockId: ExtrinsicBlocksByPolyxTransactionExtrinsicIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByPolyxTransactionExtrinsicIdAndUpdatedBlockId: ExtrinsicBlocksByPolyxTransactionExtrinsicIdAndUpdatedBlockIdManyToManyConnection;
  callId: CallIdEnum;
  createdAt: Scalars['Datetime']['output'];
  extrinsicHash?: Maybe<Scalars['String']['output']>;
  extrinsicIdx: Scalars['Int']['output'];
  extrinsicLength: Scalars['Int']['output'];
  id: Scalars['String']['output'];
  moduleId: ModuleIdEnum;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  nonce?: Maybe<Scalars['Int']['output']>;
  params?: Maybe<Scalars['JSON']['output']>;
  paramsTxt: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `PolyxTransaction`. */
  polyxTransactions: PolyxTransactionsConnection;
  signed: Scalars['Int']['output'];
  /** `signedbyAddress` is now deprecated in favour of `signed` */
  signedbyAddress: Scalars['Int']['output'];
  specVersionId: Scalars['Int']['output'];
  success: Scalars['Int']['output'];
  updatedAt: Scalars['Datetime']['output'];
};

/**
 * Represents external data included into the chain. Virtually all user actions, as well as runtime operations are extrinsics
 *
 * Usually extrinsics are signed. When the block author includes data, e.g. `timestamp.set` then the signature is implied. This is indicated with `signed = 0`
 */
export type ExtrinsicBlocksByPolyxTransactionExtrinsicIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents external data included into the chain. Virtually all user actions, as well as runtime operations are extrinsics
 *
 * Usually extrinsics are signed. When the block author includes data, e.g. `timestamp.set` then the signature is implied. This is indicated with `signed = 0`
 */
export type ExtrinsicBlocksByPolyxTransactionExtrinsicIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents external data included into the chain. Virtually all user actions, as well as runtime operations are extrinsics
 *
 * Usually extrinsics are signed. When the block author includes data, e.g. `timestamp.set` then the signature is implied. This is indicated with `signed = 0`
 */
export type ExtrinsicPolyxTransactionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PolyxTransactionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PolyxTransactionsOrderBy>>;
};

export type ExtrinsicAggregates = {
  __typename?: 'ExtrinsicAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A connection to a list of `Block` values, with data from `PolyxTransaction`. */
export type ExtrinsicBlocksByPolyxTransactionExtrinsicIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'ExtrinsicBlocksByPolyxTransactionExtrinsicIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `PolyxTransaction`, and the cursor to aid in pagination. */
  edges: Array<ExtrinsicBlocksByPolyxTransactionExtrinsicIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `PolyxTransaction`. */
export type ExtrinsicBlocksByPolyxTransactionExtrinsicIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `PolyxTransaction`. */
export type ExtrinsicBlocksByPolyxTransactionExtrinsicIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'ExtrinsicBlocksByPolyxTransactionExtrinsicIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `PolyxTransaction`. */
  polyxTransactionsByCreatedBlockId: PolyxTransactionsConnection;
};

/** A `Block` edge in the connection, with data from `PolyxTransaction`. */
export type ExtrinsicBlocksByPolyxTransactionExtrinsicIdAndCreatedBlockIdManyToManyEdgePolyxTransactionsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<PolyxTransactionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<PolyxTransactionsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `PolyxTransaction`. */
export type ExtrinsicBlocksByPolyxTransactionExtrinsicIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'ExtrinsicBlocksByPolyxTransactionExtrinsicIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `PolyxTransaction`, and the cursor to aid in pagination. */
  edges: Array<ExtrinsicBlocksByPolyxTransactionExtrinsicIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `PolyxTransaction`. */
export type ExtrinsicBlocksByPolyxTransactionExtrinsicIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `PolyxTransaction`. */
export type ExtrinsicBlocksByPolyxTransactionExtrinsicIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'ExtrinsicBlocksByPolyxTransactionExtrinsicIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `PolyxTransaction`. */
  polyxTransactionsByUpdatedBlockId: PolyxTransactionsConnection;
};

/** A `Block` edge in the connection, with data from `PolyxTransaction`. */
export type ExtrinsicBlocksByPolyxTransactionExtrinsicIdAndUpdatedBlockIdManyToManyEdgePolyxTransactionsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<PolyxTransactionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<PolyxTransactionsOrderBy>>;
  };

/** A filter to be used against `Extrinsic` object types. All fields are combined with a logical ‘and.’ */
export type ExtrinsicFilter = {
  /** Filter by the object’s `address` field. */
  address?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ExtrinsicFilter>>;
  /** Filter by the object’s `blockId` field. */
  blockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `callId` field. */
  callId?: InputMaybe<CallIdEnumFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `extrinsicHash` field. */
  extrinsicHash?: InputMaybe<StringFilter>;
  /** Filter by the object’s `extrinsicIdx` field. */
  extrinsicIdx?: InputMaybe<IntFilter>;
  /** Filter by the object’s `extrinsicLength` field. */
  extrinsicLength?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `moduleId` field. */
  moduleId?: InputMaybe<ModuleIdEnumFilter>;
  /** Filter by the object’s `nonce` field. */
  nonce?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ExtrinsicFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ExtrinsicFilter>>;
  /** Filter by the object’s `params` field. */
  params?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `paramsTxt` field. */
  paramsTxt?: InputMaybe<StringFilter>;
  /** Filter by the object’s `signed` field. */
  signed?: InputMaybe<IntFilter>;
  /** Filter by the object’s `signedbyAddress` field. */
  signedbyAddress?: InputMaybe<IntFilter>;
  /** Filter by the object’s `specVersionId` field. */
  specVersionId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `success` field. */
  success?: InputMaybe<IntFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** A connection to a list of `Extrinsic` values. */
export type ExtrinsicsConnection = {
  __typename?: 'ExtrinsicsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<ExtrinsicAggregates>;
  /** A list of edges which contains the `Extrinsic` and cursor to aid in pagination. */
  edges: Array<ExtrinsicsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<ExtrinsicAggregates>>;
  /** A list of `Extrinsic` objects. */
  nodes: Array<Maybe<Extrinsic>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Extrinsic` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Extrinsic` values. */
export type ExtrinsicsConnectionGroupedAggregatesArgs = {
  groupBy: Array<ExtrinsicsGroupBy>;
  having?: InputMaybe<ExtrinsicsHavingInput>;
};

/** A `Extrinsic` edge in the connection. */
export type ExtrinsicsEdge = {
  __typename?: 'ExtrinsicsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Extrinsic` at the end of the edge. */
  node?: Maybe<Extrinsic>;
};

/** Grouping methods for `Extrinsic` for usage during aggregation. */
export enum ExtrinsicsGroupBy {
  Address = 'ADDRESS',
  BlockId = 'BLOCK_ID',
  CallId = 'CALL_ID',
  CreatedAt = 'CREATED_AT',
  ExtrinsicHash = 'EXTRINSIC_HASH',
  ExtrinsicIdx = 'EXTRINSIC_IDX',
  ExtrinsicLength = 'EXTRINSIC_LENGTH',
  ModuleId = 'MODULE_ID',
  Nonce = 'NONCE',
  Params = 'PARAMS',
  ParamsTxt = 'PARAMS_TXT',
  Signed = 'SIGNED',
  SignedbyAddress = 'SIGNEDBY_ADDRESS',
  SpecVersionId = 'SPEC_VERSION_ID',
  Success = 'SUCCESS',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `Extrinsic` aggregates. */
export type ExtrinsicsHavingInput = {
  AND?: InputMaybe<Array<ExtrinsicsHavingInput>>;
  OR?: InputMaybe<Array<ExtrinsicsHavingInput>>;
};

/** Methods to use when ordering `Extrinsic`. */
export enum ExtrinsicsOrderBy {
  AddressAsc = 'ADDRESS_ASC',
  AddressDesc = 'ADDRESS_DESC',
  BlockIdAsc = 'BLOCK_ID_ASC',
  BlockIdDesc = 'BLOCK_ID_DESC',
  CallIdAsc = 'CALL_ID_ASC',
  CallIdDesc = 'CALL_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  ExtrinsicHashAsc = 'EXTRINSIC_HASH_ASC',
  ExtrinsicHashDesc = 'EXTRINSIC_HASH_DESC',
  ExtrinsicIdxAsc = 'EXTRINSIC_IDX_ASC',
  ExtrinsicIdxDesc = 'EXTRINSIC_IDX_DESC',
  ExtrinsicLengthAsc = 'EXTRINSIC_LENGTH_ASC',
  ExtrinsicLengthDesc = 'EXTRINSIC_LENGTH_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModuleIdAsc = 'MODULE_ID_ASC',
  ModuleIdDesc = 'MODULE_ID_DESC',
  Natural = 'NATURAL',
  NonceAsc = 'NONCE_ASC',
  NonceDesc = 'NONCE_DESC',
  ParamsAsc = 'PARAMS_ASC',
  ParamsDesc = 'PARAMS_DESC',
  ParamsTxtAsc = 'PARAMS_TXT_ASC',
  ParamsTxtDesc = 'PARAMS_TXT_DESC',
  PolyxTransactionsCountAsc = 'POLYX_TRANSACTIONS_COUNT_ASC',
  PolyxTransactionsCountDesc = 'POLYX_TRANSACTIONS_COUNT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SignedbyAddressAsc = 'SIGNEDBY_ADDRESS_ASC',
  SignedbyAddressDesc = 'SIGNEDBY_ADDRESS_DESC',
  SignedAsc = 'SIGNED_ASC',
  SignedDesc = 'SIGNED_DESC',
  SpecVersionIdAsc = 'SPEC_VERSION_ID_ASC',
  SpecVersionIdDesc = 'SPEC_VERSION_ID_DESC',
  SuccessAsc = 'SUCCESS_ASC',
  SuccessDesc = 'SUCCESS_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
}

export type FoundType = Node & {
  __typename?: 'FoundType';
  createdAt: Scalars['Datetime']['output'];
  id: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  rawType: Scalars['String']['output'];
  updatedAt: Scalars['Datetime']['output'];
};

export type FoundTypeAggregates = {
  __typename?: 'FoundTypeAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A filter to be used against `FoundType` object types. All fields are combined with a logical ‘and.’ */
export type FoundTypeFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FoundTypeFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FoundTypeFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FoundTypeFilter>>;
  /** Filter by the object’s `rawType` field. */
  rawType?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** A connection to a list of `FoundType` values. */
export type FoundTypesConnection = {
  __typename?: 'FoundTypesConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<FoundTypeAggregates>;
  /** A list of edges which contains the `FoundType` and cursor to aid in pagination. */
  edges: Array<FoundTypesEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<FoundTypeAggregates>>;
  /** A list of `FoundType` objects. */
  nodes: Array<Maybe<FoundType>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FoundType` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `FoundType` values. */
export type FoundTypesConnectionGroupedAggregatesArgs = {
  groupBy: Array<FoundTypesGroupBy>;
  having?: InputMaybe<FoundTypesHavingInput>;
};

/** A `FoundType` edge in the connection. */
export type FoundTypesEdge = {
  __typename?: 'FoundTypesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FoundType` at the end of the edge. */
  node?: Maybe<FoundType>;
};

/** Grouping methods for `FoundType` for usage during aggregation. */
export enum FoundTypesGroupBy {
  CreatedAt = 'CREATED_AT',
  RawType = 'RAW_TYPE',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `FoundType` aggregates. */
export type FoundTypesHavingInput = {
  AND?: InputMaybe<Array<FoundTypesHavingInput>>;
  OR?: InputMaybe<Array<FoundTypesHavingInput>>;
};

/** Methods to use when ordering `FoundType`. */
export enum FoundTypesOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RawTypeAsc = 'RAW_TYPE_ASC',
  RawTypeDesc = 'RAW_TYPE_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
}

/** Represents an investment into an Asset */
export type Funding = Node & {
  __typename?: 'Funding';
  amount: Scalars['BigFloat']['output'];
  /** Reads a single `Asset` that is related to this `Funding`. */
  asset?: Maybe<Asset>;
  assetId: Scalars['String']['output'];
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `Funding`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  datetime: Scalars['Datetime']['output'];
  fundingRound: Scalars['String']['output'];
  id: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  totalFundingAmount: Scalars['BigFloat']['output'];
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `Funding`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
};

export type FundingAggregates = {
  __typename?: 'FundingAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A filter to be used against `Funding` object types. All fields are combined with a logical ‘and.’ */
export type FundingFilter = {
  /** Filter by the object’s `amount` field. */
  amount?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FundingFilter>>;
  /** Filter by the object’s `assetId` field. */
  assetId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `datetime` field. */
  datetime?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `fundingRound` field. */
  fundingRound?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FundingFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FundingFilter>>;
  /** Filter by the object’s `totalFundingAmount` field. */
  totalFundingAmount?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
};

/** A connection to a list of `Funding` values. */
export type FundingsConnection = {
  __typename?: 'FundingsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<FundingAggregates>;
  /** A list of edges which contains the `Funding` and cursor to aid in pagination. */
  edges: Array<FundingsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<FundingAggregates>>;
  /** A list of `Funding` objects. */
  nodes: Array<Maybe<Funding>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Funding` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Funding` values. */
export type FundingsConnectionGroupedAggregatesArgs = {
  groupBy: Array<FundingsGroupBy>;
  having?: InputMaybe<FundingsHavingInput>;
};

/** A `Funding` edge in the connection. */
export type FundingsEdge = {
  __typename?: 'FundingsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Funding` at the end of the edge. */
  node?: Maybe<Funding>;
};

/** Grouping methods for `Funding` for usage during aggregation. */
export enum FundingsGroupBy {
  Amount = 'AMOUNT',
  AssetId = 'ASSET_ID',
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  Datetime = 'DATETIME',
  FundingRound = 'FUNDING_ROUND',
  TotalFundingAmount = 'TOTAL_FUNDING_AMOUNT',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
}

/** Conditions for `Funding` aggregates. */
export type FundingsHavingInput = {
  AND?: InputMaybe<Array<FundingsHavingInput>>;
  OR?: InputMaybe<Array<FundingsHavingInput>>;
};

/** Methods to use when ordering `Funding`. */
export enum FundingsOrderBy {
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  AssetIdAsc = 'ASSET_ID_ASC',
  AssetIdDesc = 'ASSET_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  DatetimeAsc = 'DATETIME_ASC',
  DatetimeDesc = 'DATETIME_DESC',
  FundingRoundAsc = 'FUNDING_ROUND_ASC',
  FundingRoundDesc = 'FUNDING_ROUND_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TotalFundingAmountAsc = 'TOTAL_FUNDING_AMOUNT_ASC',
  TotalFundingAmountDesc = 'TOTAL_FUNDING_AMOUNT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
}

/** A connection to a list of `Identity` values. */
export type IdentitiesConnection = {
  __typename?: 'IdentitiesConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity` and cursor to aid in pagination. */
  edges: Array<IdentitiesEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values. */
export type IdentitiesConnectionGroupedAggregatesArgs = {
  groupBy: Array<IdentitiesGroupBy>;
  having?: InputMaybe<IdentitiesHavingInput>;
};

/** A `Identity` edge in the connection. */
export type IdentitiesEdge = {
  __typename?: 'IdentitiesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
};

/** Grouping methods for `Identity` for usage during aggregation. */
export enum IdentitiesGroupBy {
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  Datetime = 'DATETIME',
  EventId = 'EVENT_ID',
  PrimaryAccount = 'PRIMARY_ACCOUNT',
  SecondaryKeysFrozen = 'SECONDARY_KEYS_FROZEN',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
}

/** Conditions for `Identity` aggregates. */
export type IdentitiesHavingInput = {
  AND?: InputMaybe<Array<IdentitiesHavingInput>>;
  OR?: InputMaybe<Array<IdentitiesHavingInput>>;
};

/** Methods to use when ordering `Identity`. */
export enum IdentitiesOrderBy {
  AssetsByOwnerIdCountAsc = 'ASSETS_BY_OWNER_ID_COUNT_ASC',
  AssetsByOwnerIdCountDesc = 'ASSETS_BY_OWNER_ID_COUNT_DESC',
  AuthorizationsByFromIdCountAsc = 'AUTHORIZATIONS_BY_FROM_ID_COUNT_ASC',
  AuthorizationsByFromIdCountDesc = 'AUTHORIZATIONS_BY_FROM_ID_COUNT_DESC',
  BridgeEventsCountAsc = 'BRIDGE_EVENTS_COUNT_ASC',
  BridgeEventsCountDesc = 'BRIDGE_EVENTS_COUNT_DESC',
  ChildrenCountAsc = 'CHILDREN_COUNT_ASC',
  ChildrenCountDesc = 'CHILDREN_COUNT_DESC',
  ClaimsByIssuerIdCountAsc = 'CLAIMS_BY_ISSUER_ID_COUNT_ASC',
  ClaimsByIssuerIdCountDesc = 'CLAIMS_BY_ISSUER_ID_COUNT_DESC',
  ClaimsByTargetIdCountAsc = 'CLAIMS_BY_TARGET_ID_COUNT_ASC',
  ClaimsByTargetIdCountDesc = 'CLAIMS_BY_TARGET_ID_COUNT_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  DatetimeAsc = 'DATETIME_ASC',
  DatetimeDesc = 'DATETIME_DESC',
  DidAsc = 'DID_ASC',
  DidDesc = 'DID_DESC',
  DistributionsCountAsc = 'DISTRIBUTIONS_COUNT_ASC',
  DistributionsCountDesc = 'DISTRIBUTIONS_COUNT_DESC',
  DistributionPaymentsByTargetIdCountAsc = 'DISTRIBUTION_PAYMENTS_BY_TARGET_ID_COUNT_ASC',
  DistributionPaymentsByTargetIdCountDesc = 'DISTRIBUTION_PAYMENTS_BY_TARGET_ID_COUNT_DESC',
  EventIdAsc = 'EVENT_ID_ASC',
  EventIdDesc = 'EVENT_ID_DESC',
  HeldAssetsCountAsc = 'HELD_ASSETS_COUNT_ASC',
  HeldAssetsCountDesc = 'HELD_ASSETS_COUNT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InvestmentsByInvestorIdCountAsc = 'INVESTMENTS_BY_INVESTOR_ID_COUNT_ASC',
  InvestmentsByInvestorIdCountDesc = 'INVESTMENTS_BY_INVESTOR_ID_COUNT_DESC',
  Natural = 'NATURAL',
  ParentChildIdentitiesCountAsc = 'PARENT_CHILD_IDENTITIES_COUNT_ASC',
  ParentChildIdentitiesCountDesc = 'PARENT_CHILD_IDENTITIES_COUNT_DESC',
  PortfoliosByCustodianIdCountAsc = 'PORTFOLIOS_BY_CUSTODIAN_ID_COUNT_ASC',
  PortfoliosByCustodianIdCountDesc = 'PORTFOLIOS_BY_CUSTODIAN_ID_COUNT_DESC',
  PortfoliosCountAsc = 'PORTFOLIOS_COUNT_ASC',
  PortfoliosCountDesc = 'PORTFOLIOS_COUNT_DESC',
  PrimaryAccountAsc = 'PRIMARY_ACCOUNT_ASC',
  PrimaryAccountDesc = 'PRIMARY_ACCOUNT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ProposalsByOwnerIdCountAsc = 'PROPOSALS_BY_OWNER_ID_COUNT_ASC',
  ProposalsByOwnerIdCountDesc = 'PROPOSALS_BY_OWNER_ID_COUNT_DESC',
  SecondaryAccountsCountAsc = 'SECONDARY_ACCOUNTS_COUNT_ASC',
  SecondaryAccountsCountDesc = 'SECONDARY_ACCOUNTS_COUNT_DESC',
  SecondaryKeysFrozenAsc = 'SECONDARY_KEYS_FROZEN_ASC',
  SecondaryKeysFrozenDesc = 'SECONDARY_KEYS_FROZEN_DESC',
  StakingEventsCountAsc = 'STAKING_EVENTS_COUNT_ASC',
  StakingEventsCountDesc = 'STAKING_EVENTS_COUNT_DESC',
  StatTypesByClaimIssuerIdCountAsc = 'STAT_TYPES_BY_CLAIM_ISSUER_ID_COUNT_ASC',
  StatTypesByClaimIssuerIdCountDesc = 'STAT_TYPES_BY_CLAIM_ISSUER_ID_COUNT_DESC',
  StosByCreatorIdCountAsc = 'STOS_BY_CREATOR_ID_COUNT_ASC',
  StosByCreatorIdCountDesc = 'STOS_BY_CREATOR_ID_COUNT_DESC',
  TickerExternalAgentsByCallerIdCountAsc = 'TICKER_EXTERNAL_AGENTS_BY_CALLER_ID_COUNT_ASC',
  TickerExternalAgentsByCallerIdCountDesc = 'TICKER_EXTERNAL_AGENTS_BY_CALLER_ID_COUNT_DESC',
  TickerExternalAgentActionsByCallerIdCountAsc = 'TICKER_EXTERNAL_AGENT_ACTIONS_BY_CALLER_ID_COUNT_ASC',
  TickerExternalAgentActionsByCallerIdCountDesc = 'TICKER_EXTERNAL_AGENT_ACTIONS_BY_CALLER_ID_COUNT_DESC',
  TickerExternalAgentHistoriesCountAsc = 'TICKER_EXTERNAL_AGENT_HISTORIES_COUNT_ASC',
  TickerExternalAgentHistoriesCountDesc = 'TICKER_EXTERNAL_AGENT_HISTORIES_COUNT_DESC',
  TransferCompliancesByClaimIssuerIdCountAsc = 'TRANSFER_COMPLIANCES_BY_CLAIM_ISSUER_ID_COUNT_ASC',
  TransferCompliancesByClaimIssuerIdCountDesc = 'TRANSFER_COMPLIANCES_BY_CLAIM_ISSUER_ID_COUNT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  VenuesByOwnerIdCountAsc = 'VENUES_BY_OWNER_ID_COUNT_ASC',
  VenuesByOwnerIdCountDesc = 'VENUES_BY_OWNER_ID_COUNT_DESC',
}

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type Identity = Node & {
  __typename?: 'Identity';
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByAssetHolderIdentityIdAndAssetId: IdentityAssetsByAssetHolderIdentityIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByDistributionIdentityIdAndAssetId: IdentityAssetsByDistributionIdentityIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByOwnerId: AssetsConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByStatTypeClaimIssuerIdAndAssetId: IdentityAssetsByStatTypeClaimIssuerIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByStoCreatorIdAndOfferingAssetId: IdentityAssetsByStoCreatorIdAndOfferingAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTickerExternalAgentActionCallerIdAndAssetId: IdentityAssetsByTickerExternalAgentActionCallerIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTickerExternalAgentCallerIdAndAssetId: IdentityAssetsByTickerExternalAgentCallerIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTickerExternalAgentHistoryIdentityIdAndAssetId: IdentityAssetsByTickerExternalAgentHistoryIdentityIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTransferComplianceClaimIssuerIdAndAssetId: IdentityAssetsByTransferComplianceClaimIssuerIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Authorization`. */
  authorizationsByFromId: AuthorizationsConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAccountIdentityIdAndCreatedBlockId: IdentityBlocksByAccountIdentityIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAccountIdentityIdAndUpdatedBlockId: IdentityBlocksByAccountIdentityIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetHolderIdentityIdAndCreatedBlockId: IdentityBlocksByAssetHolderIdentityIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetHolderIdentityIdAndUpdatedBlockId: IdentityBlocksByAssetHolderIdentityIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetOwnerIdAndCreatedBlockId: IdentityBlocksByAssetOwnerIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetOwnerIdAndUpdatedBlockId: IdentityBlocksByAssetOwnerIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAuthorizationFromIdAndCreatedBlockId: IdentityBlocksByAuthorizationFromIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAuthorizationFromIdAndUpdatedBlockId: IdentityBlocksByAuthorizationFromIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByBridgeEventIdentityIdAndCreatedBlockId: IdentityBlocksByBridgeEventIdentityIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByBridgeEventIdentityIdAndUpdatedBlockId: IdentityBlocksByBridgeEventIdentityIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByChildIdentityChildIdAndCreatedBlockId: IdentityBlocksByChildIdentityChildIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByChildIdentityChildIdAndUpdatedBlockId: IdentityBlocksByChildIdentityChildIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByChildIdentityParentIdAndCreatedBlockId: IdentityBlocksByChildIdentityParentIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByChildIdentityParentIdAndUpdatedBlockId: IdentityBlocksByChildIdentityParentIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByClaimIssuerIdAndCreatedBlockId: IdentityBlocksByClaimIssuerIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByClaimIssuerIdAndUpdatedBlockId: IdentityBlocksByClaimIssuerIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByClaimTargetIdAndCreatedBlockId: IdentityBlocksByClaimTargetIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByClaimTargetIdAndUpdatedBlockId: IdentityBlocksByClaimTargetIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByDistributionIdentityIdAndCreatedBlockId: IdentityBlocksByDistributionIdentityIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByDistributionIdentityIdAndUpdatedBlockId: IdentityBlocksByDistributionIdentityIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByDistributionPaymentTargetIdAndCreatedBlockId: IdentityBlocksByDistributionPaymentTargetIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByDistributionPaymentTargetIdAndUpdatedBlockId: IdentityBlocksByDistributionPaymentTargetIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByInvestmentInvestorIdAndCreatedBlockId: IdentityBlocksByInvestmentInvestorIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByInvestmentInvestorIdAndUpdatedBlockId: IdentityBlocksByInvestmentInvestorIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByPortfolioCustodianIdAndCreatedBlockId: IdentityBlocksByPortfolioCustodianIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByPortfolioCustodianIdAndUpdatedBlockId: IdentityBlocksByPortfolioCustodianIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByPortfolioIdentityIdAndCreatedBlockId: IdentityBlocksByPortfolioIdentityIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByPortfolioIdentityIdAndUpdatedBlockId: IdentityBlocksByPortfolioIdentityIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByProposalOwnerIdAndCreatedBlockId: IdentityBlocksByProposalOwnerIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByProposalOwnerIdAndUpdatedBlockId: IdentityBlocksByProposalOwnerIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByStakingEventIdentityIdAndCreatedBlockId: IdentityBlocksByStakingEventIdentityIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByStakingEventIdentityIdAndUpdatedBlockId: IdentityBlocksByStakingEventIdentityIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByStatTypeClaimIssuerIdAndCreatedBlockId: IdentityBlocksByStatTypeClaimIssuerIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByStatTypeClaimIssuerIdAndUpdatedBlockId: IdentityBlocksByStatTypeClaimIssuerIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByStoCreatorIdAndCreatedBlockId: IdentityBlocksByStoCreatorIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByStoCreatorIdAndUpdatedBlockId: IdentityBlocksByStoCreatorIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTickerExternalAgentActionCallerIdAndCreatedBlockId: IdentityBlocksByTickerExternalAgentActionCallerIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTickerExternalAgentActionCallerIdAndUpdatedBlockId: IdentityBlocksByTickerExternalAgentActionCallerIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTickerExternalAgentCallerIdAndCreatedBlockId: IdentityBlocksByTickerExternalAgentCallerIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTickerExternalAgentCallerIdAndUpdatedBlockId: IdentityBlocksByTickerExternalAgentCallerIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTickerExternalAgentHistoryIdentityIdAndCreatedBlockId: IdentityBlocksByTickerExternalAgentHistoryIdentityIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTickerExternalAgentHistoryIdentityIdAndUpdatedBlockId: IdentityBlocksByTickerExternalAgentHistoryIdentityIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTransferComplianceClaimIssuerIdAndCreatedBlockId: IdentityBlocksByTransferComplianceClaimIssuerIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTransferComplianceClaimIssuerIdAndUpdatedBlockId: IdentityBlocksByTransferComplianceClaimIssuerIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByVenueOwnerIdAndCreatedBlockId: IdentityBlocksByVenueOwnerIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByVenueOwnerIdAndUpdatedBlockId: IdentityBlocksByVenueOwnerIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `BridgeEvent`. */
  bridgeEvents: BridgeEventsConnection;
  /** Reads and enables pagination through a set of `ChildIdentity`. */
  children: ChildIdentitiesConnection;
  /** Reads and enables pagination through a set of `Claim`. */
  claimsByIssuerId: ClaimsConnection;
  /** Reads and enables pagination through a set of `Claim`. */
  claimsByTargetId: ClaimsConnection;
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `Identity`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  datetime: Scalars['Datetime']['output'];
  did: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `DistributionPayment`. */
  distributionPaymentsByTargetId: DistributionPaymentsConnection;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributions: DistributionsConnection;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributionsByDistributionPaymentTargetIdAndDistributionId: IdentityDistributionsByDistributionPaymentTargetIdAndDistributionIdManyToManyConnection;
  eventId: EventIdEnum;
  /** Reads and enables pagination through a set of `AssetHolder`. */
  heldAssets: AssetHoldersConnection;
  id: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByChildIdentityChildIdAndParentId: IdentityIdentitiesByChildIdentityChildIdAndParentIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByChildIdentityParentIdAndChildId: IdentityIdentitiesByChildIdentityParentIdAndChildIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByClaimIssuerIdAndTargetId: IdentityIdentitiesByClaimIssuerIdAndTargetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByClaimTargetIdAndIssuerId: IdentityIdentitiesByClaimTargetIdAndIssuerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByPortfolioCustodianIdAndIdentityId: IdentityIdentitiesByPortfolioCustodianIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByPortfolioIdentityIdAndCustodianId: IdentityIdentitiesByPortfolioIdentityIdAndCustodianIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Investment`. */
  investmentsByInvestorId: InvestmentsConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `ChildIdentity`. */
  parentChildIdentities: ChildIdentitiesConnection;
  /** Reads and enables pagination through a set of `Permission`. */
  permissionsByAccountIdentityIdAndPermissionsId: IdentityPermissionsByAccountIdentityIdAndPermissionsIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfolios: PortfoliosConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByCustodianId: PortfoliosConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByDistributionIdentityIdAndPortfolioId: IdentityPortfoliosByDistributionIdentityIdAndPortfolioIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByStoCreatorIdAndOfferingPortfolioId: IdentityPortfoliosByStoCreatorIdAndOfferingPortfolioIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByStoCreatorIdAndRaisingPortfolioId: IdentityPortfoliosByStoCreatorIdAndRaisingPortfolioIdManyToManyConnection;
  primaryAccount: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `Proposal`. */
  proposalsByOwnerId: ProposalsConnection;
  /** Reads and enables pagination through a set of `Account`. */
  secondaryAccounts: AccountsConnection;
  secondaryKeysFrozen: Scalars['Boolean']['output'];
  /** Reads and enables pagination through a set of `StakingEvent`. */
  stakingEvents: StakingEventsConnection;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypesByClaimIssuerId: StatTypesConnection;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypesByTransferComplianceClaimIssuerIdAndStatTypeId: IdentityStatTypesByTransferComplianceClaimIssuerIdAndStatTypeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByCreatorId: StosConnection;
  /** Reads and enables pagination through a set of `TickerExternalAgentAction`. */
  tickerExternalAgentActionsByCallerId: TickerExternalAgentActionsConnection;
  /** Reads and enables pagination through a set of `TickerExternalAgentHistory`. */
  tickerExternalAgentHistories: TickerExternalAgentHistoriesConnection;
  /** Reads and enables pagination through a set of `TickerExternalAgent`. */
  tickerExternalAgentsByCallerId: TickerExternalAgentsConnection;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliancesByClaimIssuerId: TransferCompliancesConnection;
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `Identity`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `Venue`. */
  venuesByOwnerId: VenuesConnection;
  /** Reads and enables pagination through a set of `Venue`. */
  venuesByStoCreatorIdAndVenueId: IdentityVenuesByStoCreatorIdAndVenueIdManyToManyConnection;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityAssetsByAssetHolderIdentityIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityAssetsByDistributionIdentityIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityAssetsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityAssetsByStatTypeClaimIssuerIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityAssetsByStoCreatorIdAndOfferingAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityAssetsByTickerExternalAgentActionCallerIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityAssetsByTickerExternalAgentCallerIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityAssetsByTickerExternalAgentHistoryIdentityIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityAssetsByTransferComplianceClaimIssuerIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityAuthorizationsByFromIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AuthorizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AuthorizationsOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByAccountIdentityIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByAccountIdentityIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByAssetHolderIdentityIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByAssetHolderIdentityIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByAssetOwnerIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByAssetOwnerIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByAuthorizationFromIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByAuthorizationFromIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByBridgeEventIdentityIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByBridgeEventIdentityIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByChildIdentityChildIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByChildIdentityChildIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByChildIdentityParentIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByChildIdentityParentIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByClaimIssuerIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByClaimIssuerIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByClaimTargetIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByClaimTargetIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByDistributionIdentityIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByDistributionIdentityIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByDistributionPaymentTargetIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByDistributionPaymentTargetIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByInvestmentInvestorIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByInvestmentInvestorIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByPortfolioCustodianIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByPortfolioCustodianIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByPortfolioIdentityIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByPortfolioIdentityIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByProposalOwnerIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByProposalOwnerIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByStakingEventIdentityIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByStakingEventIdentityIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByStatTypeClaimIssuerIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByStatTypeClaimIssuerIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByStoCreatorIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByStoCreatorIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByTickerExternalAgentActionCallerIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByTickerExternalAgentActionCallerIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByTickerExternalAgentCallerIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByTickerExternalAgentCallerIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByTickerExternalAgentHistoryIdentityIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByTickerExternalAgentHistoryIdentityIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByTransferComplianceClaimIssuerIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByTransferComplianceClaimIssuerIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByVenueOwnerIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBlocksByVenueOwnerIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityBridgeEventsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BridgeEventFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BridgeEventsOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityChildrenArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ChildIdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ChildIdentitiesOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityClaimsByIssuerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ClaimFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClaimsOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityClaimsByTargetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ClaimFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClaimsOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityDistributionPaymentsByTargetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<DistributionPaymentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DistributionPaymentsOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityDistributionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<DistributionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DistributionsOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityDistributionsByDistributionPaymentTargetIdAndDistributionIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<DistributionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DistributionsOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityHeldAssetsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetHolderFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetHoldersOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityIdentitiesByChildIdentityChildIdAndParentIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityIdentitiesByChildIdentityParentIdAndChildIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityIdentitiesByClaimIssuerIdAndTargetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityIdentitiesByClaimTargetIdAndIssuerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityIdentitiesByPortfolioCustodianIdAndIdentityIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityIdentitiesByPortfolioIdentityIdAndCustodianIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityInvestmentsByInvestorIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<InvestmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InvestmentsOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityParentChildIdentitiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ChildIdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ChildIdentitiesOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityPermissionsByAccountIdentityIdAndPermissionsIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PermissionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityPortfoliosArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityPortfoliosByCustodianIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityPortfoliosByDistributionIdentityIdAndPortfolioIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityPortfoliosByStoCreatorIdAndOfferingPortfolioIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityPortfoliosByStoCreatorIdAndRaisingPortfolioIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityProposalsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ProposalFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProposalsOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentitySecondaryAccountsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AccountFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountsOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityStakingEventsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StakingEventFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StakingEventsOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityStatTypesByClaimIssuerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StatTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StatTypesOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityStatTypesByTransferComplianceClaimIssuerIdAndStatTypeIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StatTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StatTypesOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityStosByCreatorIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StoFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StosOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityTickerExternalAgentActionsByCallerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<TickerExternalAgentActionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TickerExternalAgentActionsOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityTickerExternalAgentHistoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<TickerExternalAgentHistoryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TickerExternalAgentHistoriesOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityTickerExternalAgentsByCallerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<TickerExternalAgentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TickerExternalAgentsOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityTransferCompliancesByClaimIssuerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<TransferComplianceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TransferCompliancesOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityVenuesByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<VenueFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VenuesOrderBy>>;
};

/**
 * Represents a person or business on chain. All Polymesh assets belong to an Identity. A single Identity can have many accounts (i.e. "keys")
 *
 * An Identity needs a valid CDD claim from at least one KYC/KYB provider to perform most actions on chain
 */
export type IdentityVenuesByStoCreatorIdAndVenueIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<VenueFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VenuesOrderBy>>;
};

export type IdentityAggregates = {
  __typename?: 'IdentityAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A connection to a list of `Asset` values, with data from `AssetHolder`. */
export type IdentityAssetsByAssetHolderIdentityIdAndAssetIdManyToManyConnection = {
  __typename?: 'IdentityAssetsByAssetHolderIdentityIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `AssetHolder`, and the cursor to aid in pagination. */
  edges: Array<IdentityAssetsByAssetHolderIdentityIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `AssetHolder`. */
export type IdentityAssetsByAssetHolderIdentityIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `AssetHolder`. */
export type IdentityAssetsByAssetHolderIdentityIdAndAssetIdManyToManyEdge = {
  __typename?: 'IdentityAssetsByAssetHolderIdentityIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `AssetHolder`. */
  holders: AssetHoldersConnection;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
};

/** A `Asset` edge in the connection, with data from `AssetHolder`. */
export type IdentityAssetsByAssetHolderIdentityIdAndAssetIdManyToManyEdgeHoldersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetHolderFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetHoldersOrderBy>>;
};

/** A connection to a list of `Asset` values, with data from `Distribution`. */
export type IdentityAssetsByDistributionIdentityIdAndAssetIdManyToManyConnection = {
  __typename?: 'IdentityAssetsByDistributionIdentityIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<IdentityAssetsByDistributionIdentityIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `Distribution`. */
export type IdentityAssetsByDistributionIdentityIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `Distribution`. */
export type IdentityAssetsByDistributionIdentityIdAndAssetIdManyToManyEdge = {
  __typename?: 'IdentityAssetsByDistributionIdentityIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributions: DistributionsConnection;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
};

/** A `Asset` edge in the connection, with data from `Distribution`. */
export type IdentityAssetsByDistributionIdentityIdAndAssetIdManyToManyEdgeDistributionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<DistributionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DistributionsOrderBy>>;
};

/** A connection to a list of `Asset` values, with data from `StatType`. */
export type IdentityAssetsByStatTypeClaimIssuerIdAndAssetIdManyToManyConnection = {
  __typename?: 'IdentityAssetsByStatTypeClaimIssuerIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `StatType`, and the cursor to aid in pagination. */
  edges: Array<IdentityAssetsByStatTypeClaimIssuerIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `StatType`. */
export type IdentityAssetsByStatTypeClaimIssuerIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `StatType`. */
export type IdentityAssetsByStatTypeClaimIssuerIdAndAssetIdManyToManyEdge = {
  __typename?: 'IdentityAssetsByStatTypeClaimIssuerIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypes: StatTypesConnection;
};

/** A `Asset` edge in the connection, with data from `StatType`. */
export type IdentityAssetsByStatTypeClaimIssuerIdAndAssetIdManyToManyEdgeStatTypesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StatTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StatTypesOrderBy>>;
};

/** A connection to a list of `Asset` values, with data from `Sto`. */
export type IdentityAssetsByStoCreatorIdAndOfferingAssetIdManyToManyConnection = {
  __typename?: 'IdentityAssetsByStoCreatorIdAndOfferingAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<IdentityAssetsByStoCreatorIdAndOfferingAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `Sto`. */
export type IdentityAssetsByStoCreatorIdAndOfferingAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `Sto`. */
export type IdentityAssetsByStoCreatorIdAndOfferingAssetIdManyToManyEdge = {
  __typename?: 'IdentityAssetsByStoCreatorIdAndOfferingAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByOfferingAssetId: StosConnection;
};

/** A `Asset` edge in the connection, with data from `Sto`. */
export type IdentityAssetsByStoCreatorIdAndOfferingAssetIdManyToManyEdgeStosByOfferingAssetIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StoFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StosOrderBy>>;
  };

/** A connection to a list of `Asset` values, with data from `TickerExternalAgentAction`. */
export type IdentityAssetsByTickerExternalAgentActionCallerIdAndAssetIdManyToManyConnection = {
  __typename?: 'IdentityAssetsByTickerExternalAgentActionCallerIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `TickerExternalAgentAction`, and the cursor to aid in pagination. */
  edges: Array<IdentityAssetsByTickerExternalAgentActionCallerIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `TickerExternalAgentAction`. */
export type IdentityAssetsByTickerExternalAgentActionCallerIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TickerExternalAgentAction`. */
export type IdentityAssetsByTickerExternalAgentActionCallerIdAndAssetIdManyToManyEdge = {
  __typename?: 'IdentityAssetsByTickerExternalAgentActionCallerIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TickerExternalAgentAction`. */
  tickerExternalAgentActions: TickerExternalAgentActionsConnection;
};

/** A `Asset` edge in the connection, with data from `TickerExternalAgentAction`. */
export type IdentityAssetsByTickerExternalAgentActionCallerIdAndAssetIdManyToManyEdgeTickerExternalAgentActionsArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TickerExternalAgentActionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TickerExternalAgentActionsOrderBy>>;
  };

/** A connection to a list of `Asset` values, with data from `TickerExternalAgent`. */
export type IdentityAssetsByTickerExternalAgentCallerIdAndAssetIdManyToManyConnection = {
  __typename?: 'IdentityAssetsByTickerExternalAgentCallerIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `TickerExternalAgent`, and the cursor to aid in pagination. */
  edges: Array<IdentityAssetsByTickerExternalAgentCallerIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `TickerExternalAgent`. */
export type IdentityAssetsByTickerExternalAgentCallerIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TickerExternalAgent`. */
export type IdentityAssetsByTickerExternalAgentCallerIdAndAssetIdManyToManyEdge = {
  __typename?: 'IdentityAssetsByTickerExternalAgentCallerIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TickerExternalAgent`. */
  tickerExternalAgents: TickerExternalAgentsConnection;
};

/** A `Asset` edge in the connection, with data from `TickerExternalAgent`. */
export type IdentityAssetsByTickerExternalAgentCallerIdAndAssetIdManyToManyEdgeTickerExternalAgentsArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TickerExternalAgentFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TickerExternalAgentsOrderBy>>;
  };

/** A connection to a list of `Asset` values, with data from `TickerExternalAgentHistory`. */
export type IdentityAssetsByTickerExternalAgentHistoryIdentityIdAndAssetIdManyToManyConnection = {
  __typename?: 'IdentityAssetsByTickerExternalAgentHistoryIdentityIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `TickerExternalAgentHistory`, and the cursor to aid in pagination. */
  edges: Array<IdentityAssetsByTickerExternalAgentHistoryIdentityIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `TickerExternalAgentHistory`. */
export type IdentityAssetsByTickerExternalAgentHistoryIdentityIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type IdentityAssetsByTickerExternalAgentHistoryIdentityIdAndAssetIdManyToManyEdge = {
  __typename?: 'IdentityAssetsByTickerExternalAgentHistoryIdentityIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TickerExternalAgentHistory`. */
  tickerExternalAgentHistories: TickerExternalAgentHistoriesConnection;
};

/** A `Asset` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type IdentityAssetsByTickerExternalAgentHistoryIdentityIdAndAssetIdManyToManyEdgeTickerExternalAgentHistoriesArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TickerExternalAgentHistoryFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TickerExternalAgentHistoriesOrderBy>>;
  };

/** A connection to a list of `Asset` values, with data from `TransferCompliance`. */
export type IdentityAssetsByTransferComplianceClaimIssuerIdAndAssetIdManyToManyConnection = {
  __typename?: 'IdentityAssetsByTransferComplianceClaimIssuerIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
  edges: Array<IdentityAssetsByTransferComplianceClaimIssuerIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `TransferCompliance`. */
export type IdentityAssetsByTransferComplianceClaimIssuerIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TransferCompliance`. */
export type IdentityAssetsByTransferComplianceClaimIssuerIdAndAssetIdManyToManyEdge = {
  __typename?: 'IdentityAssetsByTransferComplianceClaimIssuerIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliances: TransferCompliancesConnection;
};

/** A `Asset` edge in the connection, with data from `TransferCompliance`. */
export type IdentityAssetsByTransferComplianceClaimIssuerIdAndAssetIdManyToManyEdgeTransferCompliancesArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TransferComplianceFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TransferCompliancesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Account`. */
export type IdentityBlocksByAccountIdentityIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByAccountIdentityIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Account`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByAccountIdentityIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Account`. */
export type IdentityBlocksByAccountIdentityIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Account`. */
export type IdentityBlocksByAccountIdentityIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByAccountIdentityIdAndCreatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Account`. */
  accountsByCreatedBlockId: AccountsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Account`. */
export type IdentityBlocksByAccountIdentityIdAndCreatedBlockIdManyToManyEdgeAccountsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AccountFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AccountsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Account`. */
export type IdentityBlocksByAccountIdentityIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByAccountIdentityIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Account`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByAccountIdentityIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Account`. */
export type IdentityBlocksByAccountIdentityIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Account`. */
export type IdentityBlocksByAccountIdentityIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByAccountIdentityIdAndUpdatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Account`. */
  accountsByUpdatedBlockId: AccountsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Account`. */
export type IdentityBlocksByAccountIdentityIdAndUpdatedBlockIdManyToManyEdgeAccountsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AccountFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AccountsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `AssetHolder`. */
export type IdentityBlocksByAssetHolderIdentityIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByAssetHolderIdentityIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `AssetHolder`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByAssetHolderIdentityIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `AssetHolder`. */
export type IdentityBlocksByAssetHolderIdentityIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AssetHolder`. */
export type IdentityBlocksByAssetHolderIdentityIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByAssetHolderIdentityIdAndCreatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AssetHolder`. */
  assetHoldersByCreatedBlockId: AssetHoldersConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `AssetHolder`. */
export type IdentityBlocksByAssetHolderIdentityIdAndCreatedBlockIdManyToManyEdgeAssetHoldersByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AssetHolderFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AssetHoldersOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `AssetHolder`. */
export type IdentityBlocksByAssetHolderIdentityIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByAssetHolderIdentityIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `AssetHolder`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByAssetHolderIdentityIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `AssetHolder`. */
export type IdentityBlocksByAssetHolderIdentityIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AssetHolder`. */
export type IdentityBlocksByAssetHolderIdentityIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByAssetHolderIdentityIdAndUpdatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AssetHolder`. */
  assetHoldersByUpdatedBlockId: AssetHoldersConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `AssetHolder`. */
export type IdentityBlocksByAssetHolderIdentityIdAndUpdatedBlockIdManyToManyEdgeAssetHoldersByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AssetHolderFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AssetHoldersOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Asset`. */
export type IdentityBlocksByAssetOwnerIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByAssetOwnerIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Asset`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByAssetOwnerIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Asset`. */
export type IdentityBlocksByAssetOwnerIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Asset`. */
export type IdentityBlocksByAssetOwnerIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByAssetOwnerIdAndCreatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByCreatedBlockId: AssetsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Asset`. */
export type IdentityBlocksByAssetOwnerIdAndCreatedBlockIdManyToManyEdgeAssetsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AssetFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AssetsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Asset`. */
export type IdentityBlocksByAssetOwnerIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByAssetOwnerIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Asset`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByAssetOwnerIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Asset`. */
export type IdentityBlocksByAssetOwnerIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Asset`. */
export type IdentityBlocksByAssetOwnerIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByAssetOwnerIdAndUpdatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByUpdatedBlockId: AssetsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Asset`. */
export type IdentityBlocksByAssetOwnerIdAndUpdatedBlockIdManyToManyEdgeAssetsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AssetFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AssetsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Authorization`. */
export type IdentityBlocksByAuthorizationFromIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByAuthorizationFromIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Authorization`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByAuthorizationFromIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Authorization`. */
export type IdentityBlocksByAuthorizationFromIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Authorization`. */
export type IdentityBlocksByAuthorizationFromIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByAuthorizationFromIdAndCreatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Authorization`. */
  authorizationsByCreatedBlockId: AuthorizationsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Authorization`. */
export type IdentityBlocksByAuthorizationFromIdAndCreatedBlockIdManyToManyEdgeAuthorizationsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AuthorizationFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AuthorizationsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Authorization`. */
export type IdentityBlocksByAuthorizationFromIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByAuthorizationFromIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Authorization`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByAuthorizationFromIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Authorization`. */
export type IdentityBlocksByAuthorizationFromIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Authorization`. */
export type IdentityBlocksByAuthorizationFromIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByAuthorizationFromIdAndUpdatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Authorization`. */
  authorizationsByUpdatedBlockId: AuthorizationsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Authorization`. */
export type IdentityBlocksByAuthorizationFromIdAndUpdatedBlockIdManyToManyEdgeAuthorizationsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AuthorizationFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AuthorizationsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `BridgeEvent`. */
export type IdentityBlocksByBridgeEventIdentityIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByBridgeEventIdentityIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `BridgeEvent`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByBridgeEventIdentityIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `BridgeEvent`. */
export type IdentityBlocksByBridgeEventIdentityIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `BridgeEvent`. */
export type IdentityBlocksByBridgeEventIdentityIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByBridgeEventIdentityIdAndCreatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `BridgeEvent`. */
  bridgeEventsByCreatedBlockId: BridgeEventsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `BridgeEvent`. */
export type IdentityBlocksByBridgeEventIdentityIdAndCreatedBlockIdManyToManyEdgeBridgeEventsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<BridgeEventFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<BridgeEventsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `BridgeEvent`. */
export type IdentityBlocksByBridgeEventIdentityIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByBridgeEventIdentityIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `BridgeEvent`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByBridgeEventIdentityIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `BridgeEvent`. */
export type IdentityBlocksByBridgeEventIdentityIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `BridgeEvent`. */
export type IdentityBlocksByBridgeEventIdentityIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByBridgeEventIdentityIdAndUpdatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `BridgeEvent`. */
  bridgeEventsByUpdatedBlockId: BridgeEventsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `BridgeEvent`. */
export type IdentityBlocksByBridgeEventIdentityIdAndUpdatedBlockIdManyToManyEdgeBridgeEventsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<BridgeEventFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<BridgeEventsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `ChildIdentity`. */
export type IdentityBlocksByChildIdentityChildIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByChildIdentityChildIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `ChildIdentity`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByChildIdentityChildIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `ChildIdentity`. */
export type IdentityBlocksByChildIdentityChildIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `ChildIdentity`. */
export type IdentityBlocksByChildIdentityChildIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByChildIdentityChildIdAndCreatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `ChildIdentity`. */
  childIdentitiesByCreatedBlockId: ChildIdentitiesConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `ChildIdentity`. */
export type IdentityBlocksByChildIdentityChildIdAndCreatedBlockIdManyToManyEdgeChildIdentitiesByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<ChildIdentityFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<ChildIdentitiesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `ChildIdentity`. */
export type IdentityBlocksByChildIdentityChildIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByChildIdentityChildIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `ChildIdentity`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByChildIdentityChildIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `ChildIdentity`. */
export type IdentityBlocksByChildIdentityChildIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `ChildIdentity`. */
export type IdentityBlocksByChildIdentityChildIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByChildIdentityChildIdAndUpdatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `ChildIdentity`. */
  childIdentitiesByUpdatedBlockId: ChildIdentitiesConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `ChildIdentity`. */
export type IdentityBlocksByChildIdentityChildIdAndUpdatedBlockIdManyToManyEdgeChildIdentitiesByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<ChildIdentityFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<ChildIdentitiesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `ChildIdentity`. */
export type IdentityBlocksByChildIdentityParentIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByChildIdentityParentIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `ChildIdentity`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByChildIdentityParentIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `ChildIdentity`. */
export type IdentityBlocksByChildIdentityParentIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `ChildIdentity`. */
export type IdentityBlocksByChildIdentityParentIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByChildIdentityParentIdAndCreatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `ChildIdentity`. */
  childIdentitiesByCreatedBlockId: ChildIdentitiesConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `ChildIdentity`. */
export type IdentityBlocksByChildIdentityParentIdAndCreatedBlockIdManyToManyEdgeChildIdentitiesByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<ChildIdentityFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<ChildIdentitiesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `ChildIdentity`. */
export type IdentityBlocksByChildIdentityParentIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByChildIdentityParentIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `ChildIdentity`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByChildIdentityParentIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `ChildIdentity`. */
export type IdentityBlocksByChildIdentityParentIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `ChildIdentity`. */
export type IdentityBlocksByChildIdentityParentIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByChildIdentityParentIdAndUpdatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `ChildIdentity`. */
  childIdentitiesByUpdatedBlockId: ChildIdentitiesConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `ChildIdentity`. */
export type IdentityBlocksByChildIdentityParentIdAndUpdatedBlockIdManyToManyEdgeChildIdentitiesByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<ChildIdentityFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<ChildIdentitiesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Claim`. */
export type IdentityBlocksByClaimIssuerIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByClaimIssuerIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Claim`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByClaimIssuerIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Claim`. */
export type IdentityBlocksByClaimIssuerIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Claim`. */
export type IdentityBlocksByClaimIssuerIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByClaimIssuerIdAndCreatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Claim`. */
  claimsByCreatedBlockId: ClaimsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Claim`. */
export type IdentityBlocksByClaimIssuerIdAndCreatedBlockIdManyToManyEdgeClaimsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<ClaimFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<ClaimsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Claim`. */
export type IdentityBlocksByClaimIssuerIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByClaimIssuerIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Claim`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByClaimIssuerIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Claim`. */
export type IdentityBlocksByClaimIssuerIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Claim`. */
export type IdentityBlocksByClaimIssuerIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByClaimIssuerIdAndUpdatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Claim`. */
  claimsByUpdatedBlockId: ClaimsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Claim`. */
export type IdentityBlocksByClaimIssuerIdAndUpdatedBlockIdManyToManyEdgeClaimsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<ClaimFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<ClaimsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Claim`. */
export type IdentityBlocksByClaimTargetIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByClaimTargetIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Claim`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByClaimTargetIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Claim`. */
export type IdentityBlocksByClaimTargetIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Claim`. */
export type IdentityBlocksByClaimTargetIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByClaimTargetIdAndCreatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Claim`. */
  claimsByCreatedBlockId: ClaimsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Claim`. */
export type IdentityBlocksByClaimTargetIdAndCreatedBlockIdManyToManyEdgeClaimsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<ClaimFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<ClaimsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Claim`. */
export type IdentityBlocksByClaimTargetIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByClaimTargetIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Claim`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByClaimTargetIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Claim`. */
export type IdentityBlocksByClaimTargetIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Claim`. */
export type IdentityBlocksByClaimTargetIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByClaimTargetIdAndUpdatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Claim`. */
  claimsByUpdatedBlockId: ClaimsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Claim`. */
export type IdentityBlocksByClaimTargetIdAndUpdatedBlockIdManyToManyEdgeClaimsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<ClaimFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<ClaimsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Distribution`. */
export type IdentityBlocksByDistributionIdentityIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByDistributionIdentityIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByDistributionIdentityIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Distribution`. */
export type IdentityBlocksByDistributionIdentityIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Distribution`. */
export type IdentityBlocksByDistributionIdentityIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByDistributionIdentityIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributionsByCreatedBlockId: DistributionsConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Distribution`. */
export type IdentityBlocksByDistributionIdentityIdAndCreatedBlockIdManyToManyEdgeDistributionsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<DistributionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<DistributionsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Distribution`. */
export type IdentityBlocksByDistributionIdentityIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByDistributionIdentityIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByDistributionIdentityIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Distribution`. */
export type IdentityBlocksByDistributionIdentityIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Distribution`. */
export type IdentityBlocksByDistributionIdentityIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByDistributionIdentityIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributionsByUpdatedBlockId: DistributionsConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Distribution`. */
export type IdentityBlocksByDistributionIdentityIdAndUpdatedBlockIdManyToManyEdgeDistributionsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<DistributionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<DistributionsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `DistributionPayment`. */
export type IdentityBlocksByDistributionPaymentTargetIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByDistributionPaymentTargetIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `DistributionPayment`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByDistributionPaymentTargetIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `DistributionPayment`. */
export type IdentityBlocksByDistributionPaymentTargetIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `DistributionPayment`. */
export type IdentityBlocksByDistributionPaymentTargetIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByDistributionPaymentTargetIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `DistributionPayment`. */
  distributionPaymentsByCreatedBlockId: DistributionPaymentsConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `DistributionPayment`. */
export type IdentityBlocksByDistributionPaymentTargetIdAndCreatedBlockIdManyToManyEdgeDistributionPaymentsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<DistributionPaymentFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<DistributionPaymentsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `DistributionPayment`. */
export type IdentityBlocksByDistributionPaymentTargetIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByDistributionPaymentTargetIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `DistributionPayment`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByDistributionPaymentTargetIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `DistributionPayment`. */
export type IdentityBlocksByDistributionPaymentTargetIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `DistributionPayment`. */
export type IdentityBlocksByDistributionPaymentTargetIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByDistributionPaymentTargetIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `DistributionPayment`. */
  distributionPaymentsByUpdatedBlockId: DistributionPaymentsConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `DistributionPayment`. */
export type IdentityBlocksByDistributionPaymentTargetIdAndUpdatedBlockIdManyToManyEdgeDistributionPaymentsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<DistributionPaymentFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<DistributionPaymentsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Investment`. */
export type IdentityBlocksByInvestmentInvestorIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByInvestmentInvestorIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Investment`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByInvestmentInvestorIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Investment`. */
export type IdentityBlocksByInvestmentInvestorIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Investment`. */
export type IdentityBlocksByInvestmentInvestorIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByInvestmentInvestorIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Investment`. */
  investmentsByCreatedBlockId: InvestmentsConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Investment`. */
export type IdentityBlocksByInvestmentInvestorIdAndCreatedBlockIdManyToManyEdgeInvestmentsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<InvestmentFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<InvestmentsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Investment`. */
export type IdentityBlocksByInvestmentInvestorIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByInvestmentInvestorIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Investment`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByInvestmentInvestorIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Investment`. */
export type IdentityBlocksByInvestmentInvestorIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Investment`. */
export type IdentityBlocksByInvestmentInvestorIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByInvestmentInvestorIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Investment`. */
  investmentsByUpdatedBlockId: InvestmentsConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Investment`. */
export type IdentityBlocksByInvestmentInvestorIdAndUpdatedBlockIdManyToManyEdgeInvestmentsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<InvestmentFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<InvestmentsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Portfolio`. */
export type IdentityBlocksByPortfolioCustodianIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByPortfolioCustodianIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Portfolio`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByPortfolioCustodianIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Portfolio`. */
export type IdentityBlocksByPortfolioCustodianIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Portfolio`. */
export type IdentityBlocksByPortfolioCustodianIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByPortfolioCustodianIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByCreatedBlockId: PortfoliosConnection;
};

/** A `Block` edge in the connection, with data from `Portfolio`. */
export type IdentityBlocksByPortfolioCustodianIdAndCreatedBlockIdManyToManyEdgePortfoliosByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<PortfolioFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Portfolio`. */
export type IdentityBlocksByPortfolioCustodianIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByPortfolioCustodianIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Portfolio`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByPortfolioCustodianIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Portfolio`. */
export type IdentityBlocksByPortfolioCustodianIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Portfolio`. */
export type IdentityBlocksByPortfolioCustodianIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByPortfolioCustodianIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByUpdatedBlockId: PortfoliosConnection;
};

/** A `Block` edge in the connection, with data from `Portfolio`. */
export type IdentityBlocksByPortfolioCustodianIdAndUpdatedBlockIdManyToManyEdgePortfoliosByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<PortfolioFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Portfolio`. */
export type IdentityBlocksByPortfolioIdentityIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByPortfolioIdentityIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Portfolio`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByPortfolioIdentityIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Portfolio`. */
export type IdentityBlocksByPortfolioIdentityIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Portfolio`. */
export type IdentityBlocksByPortfolioIdentityIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByPortfolioIdentityIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByCreatedBlockId: PortfoliosConnection;
};

/** A `Block` edge in the connection, with data from `Portfolio`. */
export type IdentityBlocksByPortfolioIdentityIdAndCreatedBlockIdManyToManyEdgePortfoliosByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<PortfolioFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Portfolio`. */
export type IdentityBlocksByPortfolioIdentityIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByPortfolioIdentityIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Portfolio`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByPortfolioIdentityIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Portfolio`. */
export type IdentityBlocksByPortfolioIdentityIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Portfolio`. */
export type IdentityBlocksByPortfolioIdentityIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByPortfolioIdentityIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByUpdatedBlockId: PortfoliosConnection;
};

/** A `Block` edge in the connection, with data from `Portfolio`. */
export type IdentityBlocksByPortfolioIdentityIdAndUpdatedBlockIdManyToManyEdgePortfoliosByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<PortfolioFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Proposal`. */
export type IdentityBlocksByProposalOwnerIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByProposalOwnerIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Proposal`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByProposalOwnerIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Proposal`. */
export type IdentityBlocksByProposalOwnerIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Proposal`. */
export type IdentityBlocksByProposalOwnerIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByProposalOwnerIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Proposal`. */
  proposalsByCreatedBlockId: ProposalsConnection;
};

/** A `Block` edge in the connection, with data from `Proposal`. */
export type IdentityBlocksByProposalOwnerIdAndCreatedBlockIdManyToManyEdgeProposalsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<ProposalFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<ProposalsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Proposal`. */
export type IdentityBlocksByProposalOwnerIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByProposalOwnerIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Proposal`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByProposalOwnerIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Proposal`. */
export type IdentityBlocksByProposalOwnerIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Proposal`. */
export type IdentityBlocksByProposalOwnerIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByProposalOwnerIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Proposal`. */
  proposalsByUpdatedBlockId: ProposalsConnection;
};

/** A `Block` edge in the connection, with data from `Proposal`. */
export type IdentityBlocksByProposalOwnerIdAndUpdatedBlockIdManyToManyEdgeProposalsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<ProposalFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<ProposalsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `StakingEvent`. */
export type IdentityBlocksByStakingEventIdentityIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByStakingEventIdentityIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `StakingEvent`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByStakingEventIdentityIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `StakingEvent`. */
export type IdentityBlocksByStakingEventIdentityIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `StakingEvent`. */
export type IdentityBlocksByStakingEventIdentityIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByStakingEventIdentityIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `StakingEvent`. */
  stakingEventsByCreatedBlockId: StakingEventsConnection;
};

/** A `Block` edge in the connection, with data from `StakingEvent`. */
export type IdentityBlocksByStakingEventIdentityIdAndCreatedBlockIdManyToManyEdgeStakingEventsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StakingEventFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StakingEventsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `StakingEvent`. */
export type IdentityBlocksByStakingEventIdentityIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByStakingEventIdentityIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `StakingEvent`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByStakingEventIdentityIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `StakingEvent`. */
export type IdentityBlocksByStakingEventIdentityIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `StakingEvent`. */
export type IdentityBlocksByStakingEventIdentityIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByStakingEventIdentityIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `StakingEvent`. */
  stakingEventsByUpdatedBlockId: StakingEventsConnection;
};

/** A `Block` edge in the connection, with data from `StakingEvent`. */
export type IdentityBlocksByStakingEventIdentityIdAndUpdatedBlockIdManyToManyEdgeStakingEventsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StakingEventFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StakingEventsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `StatType`. */
export type IdentityBlocksByStatTypeClaimIssuerIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByStatTypeClaimIssuerIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `StatType`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByStatTypeClaimIssuerIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `StatType`. */
export type IdentityBlocksByStatTypeClaimIssuerIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `StatType`. */
export type IdentityBlocksByStatTypeClaimIssuerIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByStatTypeClaimIssuerIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypesByCreatedBlockId: StatTypesConnection;
};

/** A `Block` edge in the connection, with data from `StatType`. */
export type IdentityBlocksByStatTypeClaimIssuerIdAndCreatedBlockIdManyToManyEdgeStatTypesByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StatTypeFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StatTypesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `StatType`. */
export type IdentityBlocksByStatTypeClaimIssuerIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByStatTypeClaimIssuerIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `StatType`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByStatTypeClaimIssuerIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `StatType`. */
export type IdentityBlocksByStatTypeClaimIssuerIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `StatType`. */
export type IdentityBlocksByStatTypeClaimIssuerIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByStatTypeClaimIssuerIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypesByUpdatedBlockId: StatTypesConnection;
};

/** A `Block` edge in the connection, with data from `StatType`. */
export type IdentityBlocksByStatTypeClaimIssuerIdAndUpdatedBlockIdManyToManyEdgeStatTypesByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StatTypeFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StatTypesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Sto`. */
export type IdentityBlocksByStoCreatorIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByStoCreatorIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByStoCreatorIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Sto`. */
export type IdentityBlocksByStoCreatorIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Sto`. */
export type IdentityBlocksByStoCreatorIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByStoCreatorIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByCreatedBlockId: StosConnection;
};

/** A `Block` edge in the connection, with data from `Sto`. */
export type IdentityBlocksByStoCreatorIdAndCreatedBlockIdManyToManyEdgeStosByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StoFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StosOrderBy>>;
};

/** A connection to a list of `Block` values, with data from `Sto`. */
export type IdentityBlocksByStoCreatorIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByStoCreatorIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByStoCreatorIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Sto`. */
export type IdentityBlocksByStoCreatorIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Sto`. */
export type IdentityBlocksByStoCreatorIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByStoCreatorIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByUpdatedBlockId: StosConnection;
};

/** A `Block` edge in the connection, with data from `Sto`. */
export type IdentityBlocksByStoCreatorIdAndUpdatedBlockIdManyToManyEdgeStosByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StoFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StosOrderBy>>;
};

/** A connection to a list of `Block` values, with data from `TickerExternalAgentAction`. */
export type IdentityBlocksByTickerExternalAgentActionCallerIdAndCreatedBlockIdManyToManyConnection =
  {
    __typename?: 'IdentityBlocksByTickerExternalAgentActionCallerIdAndCreatedBlockIdManyToManyConnection';
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<BlockAggregates>;
    /** A list of edges which contains the `Block`, info from the `TickerExternalAgentAction`, and the cursor to aid in pagination. */
    edges: Array<IdentityBlocksByTickerExternalAgentActionCallerIdAndCreatedBlockIdManyToManyEdge>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<BlockAggregates>>;
    /** A list of `Block` objects. */
    nodes: Array<Maybe<Block>>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Block` you could get from the connection. */
    totalCount: Scalars['Int']['output'];
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentAction`. */
export type IdentityBlocksByTickerExternalAgentActionCallerIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TickerExternalAgentAction`. */
export type IdentityBlocksByTickerExternalAgentActionCallerIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByTickerExternalAgentActionCallerIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TickerExternalAgentAction`. */
  tickerExternalAgentActionsByCreatedBlockId: TickerExternalAgentActionsConnection;
};

/** A `Block` edge in the connection, with data from `TickerExternalAgentAction`. */
export type IdentityBlocksByTickerExternalAgentActionCallerIdAndCreatedBlockIdManyToManyEdgeTickerExternalAgentActionsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TickerExternalAgentActionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TickerExternalAgentActionsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentAction`. */
export type IdentityBlocksByTickerExternalAgentActionCallerIdAndUpdatedBlockIdManyToManyConnection =
  {
    __typename?: 'IdentityBlocksByTickerExternalAgentActionCallerIdAndUpdatedBlockIdManyToManyConnection';
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<BlockAggregates>;
    /** A list of edges which contains the `Block`, info from the `TickerExternalAgentAction`, and the cursor to aid in pagination. */
    edges: Array<IdentityBlocksByTickerExternalAgentActionCallerIdAndUpdatedBlockIdManyToManyEdge>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<BlockAggregates>>;
    /** A list of `Block` objects. */
    nodes: Array<Maybe<Block>>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Block` you could get from the connection. */
    totalCount: Scalars['Int']['output'];
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentAction`. */
export type IdentityBlocksByTickerExternalAgentActionCallerIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TickerExternalAgentAction`. */
export type IdentityBlocksByTickerExternalAgentActionCallerIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByTickerExternalAgentActionCallerIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TickerExternalAgentAction`. */
  tickerExternalAgentActionsByUpdatedBlockId: TickerExternalAgentActionsConnection;
};

/** A `Block` edge in the connection, with data from `TickerExternalAgentAction`. */
export type IdentityBlocksByTickerExternalAgentActionCallerIdAndUpdatedBlockIdManyToManyEdgeTickerExternalAgentActionsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TickerExternalAgentActionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TickerExternalAgentActionsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgent`. */
export type IdentityBlocksByTickerExternalAgentCallerIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByTickerExternalAgentCallerIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `TickerExternalAgent`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByTickerExternalAgentCallerIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `TickerExternalAgent`. */
export type IdentityBlocksByTickerExternalAgentCallerIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TickerExternalAgent`. */
export type IdentityBlocksByTickerExternalAgentCallerIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByTickerExternalAgentCallerIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TickerExternalAgent`. */
  tickerExternalAgentsByCreatedBlockId: TickerExternalAgentsConnection;
};

/** A `Block` edge in the connection, with data from `TickerExternalAgent`. */
export type IdentityBlocksByTickerExternalAgentCallerIdAndCreatedBlockIdManyToManyEdgeTickerExternalAgentsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TickerExternalAgentFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TickerExternalAgentsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgent`. */
export type IdentityBlocksByTickerExternalAgentCallerIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByTickerExternalAgentCallerIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `TickerExternalAgent`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByTickerExternalAgentCallerIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `TickerExternalAgent`. */
export type IdentityBlocksByTickerExternalAgentCallerIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TickerExternalAgent`. */
export type IdentityBlocksByTickerExternalAgentCallerIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByTickerExternalAgentCallerIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TickerExternalAgent`. */
  tickerExternalAgentsByUpdatedBlockId: TickerExternalAgentsConnection;
};

/** A `Block` edge in the connection, with data from `TickerExternalAgent`. */
export type IdentityBlocksByTickerExternalAgentCallerIdAndUpdatedBlockIdManyToManyEdgeTickerExternalAgentsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TickerExternalAgentFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TickerExternalAgentsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentHistory`. */
export type IdentityBlocksByTickerExternalAgentHistoryIdentityIdAndCreatedBlockIdManyToManyConnection =
  {
    __typename?: 'IdentityBlocksByTickerExternalAgentHistoryIdentityIdAndCreatedBlockIdManyToManyConnection';
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<BlockAggregates>;
    /** A list of edges which contains the `Block`, info from the `TickerExternalAgentHistory`, and the cursor to aid in pagination. */
    edges: Array<IdentityBlocksByTickerExternalAgentHistoryIdentityIdAndCreatedBlockIdManyToManyEdge>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<BlockAggregates>>;
    /** A list of `Block` objects. */
    nodes: Array<Maybe<Block>>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Block` you could get from the connection. */
    totalCount: Scalars['Int']['output'];
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentHistory`. */
export type IdentityBlocksByTickerExternalAgentHistoryIdentityIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type IdentityBlocksByTickerExternalAgentHistoryIdentityIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByTickerExternalAgentHistoryIdentityIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TickerExternalAgentHistory`. */
  tickerExternalAgentHistoriesByCreatedBlockId: TickerExternalAgentHistoriesConnection;
};

/** A `Block` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type IdentityBlocksByTickerExternalAgentHistoryIdentityIdAndCreatedBlockIdManyToManyEdgeTickerExternalAgentHistoriesByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TickerExternalAgentHistoryFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TickerExternalAgentHistoriesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentHistory`. */
export type IdentityBlocksByTickerExternalAgentHistoryIdentityIdAndUpdatedBlockIdManyToManyConnection =
  {
    __typename?: 'IdentityBlocksByTickerExternalAgentHistoryIdentityIdAndUpdatedBlockIdManyToManyConnection';
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<BlockAggregates>;
    /** A list of edges which contains the `Block`, info from the `TickerExternalAgentHistory`, and the cursor to aid in pagination. */
    edges: Array<IdentityBlocksByTickerExternalAgentHistoryIdentityIdAndUpdatedBlockIdManyToManyEdge>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<BlockAggregates>>;
    /** A list of `Block` objects. */
    nodes: Array<Maybe<Block>>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Block` you could get from the connection. */
    totalCount: Scalars['Int']['output'];
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentHistory`. */
export type IdentityBlocksByTickerExternalAgentHistoryIdentityIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type IdentityBlocksByTickerExternalAgentHistoryIdentityIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByTickerExternalAgentHistoryIdentityIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TickerExternalAgentHistory`. */
  tickerExternalAgentHistoriesByUpdatedBlockId: TickerExternalAgentHistoriesConnection;
};

/** A `Block` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type IdentityBlocksByTickerExternalAgentHistoryIdentityIdAndUpdatedBlockIdManyToManyEdgeTickerExternalAgentHistoriesByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TickerExternalAgentHistoryFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TickerExternalAgentHistoriesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `TransferCompliance`. */
export type IdentityBlocksByTransferComplianceClaimIssuerIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByTransferComplianceClaimIssuerIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByTransferComplianceClaimIssuerIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `TransferCompliance`. */
export type IdentityBlocksByTransferComplianceClaimIssuerIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TransferCompliance`. */
export type IdentityBlocksByTransferComplianceClaimIssuerIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByTransferComplianceClaimIssuerIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliancesByCreatedBlockId: TransferCompliancesConnection;
};

/** A `Block` edge in the connection, with data from `TransferCompliance`. */
export type IdentityBlocksByTransferComplianceClaimIssuerIdAndCreatedBlockIdManyToManyEdgeTransferCompliancesByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TransferComplianceFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TransferCompliancesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `TransferCompliance`. */
export type IdentityBlocksByTransferComplianceClaimIssuerIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByTransferComplianceClaimIssuerIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByTransferComplianceClaimIssuerIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `TransferCompliance`. */
export type IdentityBlocksByTransferComplianceClaimIssuerIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TransferCompliance`. */
export type IdentityBlocksByTransferComplianceClaimIssuerIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByTransferComplianceClaimIssuerIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliancesByUpdatedBlockId: TransferCompliancesConnection;
};

/** A `Block` edge in the connection, with data from `TransferCompliance`. */
export type IdentityBlocksByTransferComplianceClaimIssuerIdAndUpdatedBlockIdManyToManyEdgeTransferCompliancesByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TransferComplianceFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TransferCompliancesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Venue`. */
export type IdentityBlocksByVenueOwnerIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByVenueOwnerIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Venue`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByVenueOwnerIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Venue`. */
export type IdentityBlocksByVenueOwnerIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Venue`. */
export type IdentityBlocksByVenueOwnerIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByVenueOwnerIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Venue`. */
  venuesByCreatedBlockId: VenuesConnection;
};

/** A `Block` edge in the connection, with data from `Venue`. */
export type IdentityBlocksByVenueOwnerIdAndCreatedBlockIdManyToManyEdgeVenuesByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<VenueFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<VenuesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Venue`. */
export type IdentityBlocksByVenueOwnerIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByVenueOwnerIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Venue`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByVenueOwnerIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Venue`. */
export type IdentityBlocksByVenueOwnerIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Venue`. */
export type IdentityBlocksByVenueOwnerIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByVenueOwnerIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Venue`. */
  venuesByUpdatedBlockId: VenuesConnection;
};

/** A `Block` edge in the connection, with data from `Venue`. */
export type IdentityBlocksByVenueOwnerIdAndUpdatedBlockIdManyToManyEdgeVenuesByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<VenueFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<VenuesOrderBy>>;
  };

/** A connection to a list of `Distribution` values, with data from `DistributionPayment`. */
export type IdentityDistributionsByDistributionPaymentTargetIdAndDistributionIdManyToManyConnection =
  {
    __typename?: 'IdentityDistributionsByDistributionPaymentTargetIdAndDistributionIdManyToManyConnection';
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<DistributionAggregates>;
    /** A list of edges which contains the `Distribution`, info from the `DistributionPayment`, and the cursor to aid in pagination. */
    edges: Array<IdentityDistributionsByDistributionPaymentTargetIdAndDistributionIdManyToManyEdge>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<DistributionAggregates>>;
    /** A list of `Distribution` objects. */
    nodes: Array<Maybe<Distribution>>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Distribution` you could get from the connection. */
    totalCount: Scalars['Int']['output'];
  };

/** A connection to a list of `Distribution` values, with data from `DistributionPayment`. */
export type IdentityDistributionsByDistributionPaymentTargetIdAndDistributionIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<DistributionsGroupBy>;
    having?: InputMaybe<DistributionsHavingInput>;
  };

/** A `Distribution` edge in the connection, with data from `DistributionPayment`. */
export type IdentityDistributionsByDistributionPaymentTargetIdAndDistributionIdManyToManyEdge = {
  __typename?: 'IdentityDistributionsByDistributionPaymentTargetIdAndDistributionIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `DistributionPayment`. */
  distributionPayments: DistributionPaymentsConnection;
  /** The `Distribution` at the end of the edge. */
  node?: Maybe<Distribution>;
};

/** A `Distribution` edge in the connection, with data from `DistributionPayment`. */
export type IdentityDistributionsByDistributionPaymentTargetIdAndDistributionIdManyToManyEdgeDistributionPaymentsArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<DistributionPaymentFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<DistributionPaymentsOrderBy>>;
  };

/** A filter to be used against `Identity` object types. All fields are combined with a logical ‘and.’ */
export type IdentityFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<IdentityFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `datetime` field. */
  datetime?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `did` field. */
  did?: InputMaybe<StringFilter>;
  /** Filter by the object’s `eventId` field. */
  eventId?: InputMaybe<EventIdEnumFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<IdentityFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<IdentityFilter>>;
  /** Filter by the object’s `primaryAccount` field. */
  primaryAccount?: InputMaybe<StringFilter>;
  /** Filter by the object’s `secondaryKeysFrozen` field. */
  secondaryKeysFrozen?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
};

/** A connection to a list of `Identity` values, with data from `ChildIdentity`. */
export type IdentityIdentitiesByChildIdentityChildIdAndParentIdManyToManyConnection = {
  __typename?: 'IdentityIdentitiesByChildIdentityChildIdAndParentIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `ChildIdentity`, and the cursor to aid in pagination. */
  edges: Array<IdentityIdentitiesByChildIdentityChildIdAndParentIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `ChildIdentity`. */
export type IdentityIdentitiesByChildIdentityChildIdAndParentIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `ChildIdentity`. */
export type IdentityIdentitiesByChildIdentityChildIdAndParentIdManyToManyEdge = {
  __typename?: 'IdentityIdentitiesByChildIdentityChildIdAndParentIdManyToManyEdge';
  /** Reads and enables pagination through a set of `ChildIdentity`. */
  children: ChildIdentitiesConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
};

/** A `Identity` edge in the connection, with data from `ChildIdentity`. */
export type IdentityIdentitiesByChildIdentityChildIdAndParentIdManyToManyEdgeChildrenArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ChildIdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ChildIdentitiesOrderBy>>;
};

/** A connection to a list of `Identity` values, with data from `ChildIdentity`. */
export type IdentityIdentitiesByChildIdentityParentIdAndChildIdManyToManyConnection = {
  __typename?: 'IdentityIdentitiesByChildIdentityParentIdAndChildIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `ChildIdentity`, and the cursor to aid in pagination. */
  edges: Array<IdentityIdentitiesByChildIdentityParentIdAndChildIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `ChildIdentity`. */
export type IdentityIdentitiesByChildIdentityParentIdAndChildIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `ChildIdentity`. */
export type IdentityIdentitiesByChildIdentityParentIdAndChildIdManyToManyEdge = {
  __typename?: 'IdentityIdentitiesByChildIdentityParentIdAndChildIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `ChildIdentity`. */
  parentChildIdentities: ChildIdentitiesConnection;
};

/** A `Identity` edge in the connection, with data from `ChildIdentity`. */
export type IdentityIdentitiesByChildIdentityParentIdAndChildIdManyToManyEdgeParentChildIdentitiesArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<ChildIdentityFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<ChildIdentitiesOrderBy>>;
  };

/** A connection to a list of `Identity` values, with data from `Claim`. */
export type IdentityIdentitiesByClaimIssuerIdAndTargetIdManyToManyConnection = {
  __typename?: 'IdentityIdentitiesByClaimIssuerIdAndTargetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `Claim`, and the cursor to aid in pagination. */
  edges: Array<IdentityIdentitiesByClaimIssuerIdAndTargetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `Claim`. */
export type IdentityIdentitiesByClaimIssuerIdAndTargetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Claim`. */
export type IdentityIdentitiesByClaimIssuerIdAndTargetIdManyToManyEdge = {
  __typename?: 'IdentityIdentitiesByClaimIssuerIdAndTargetIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Claim`. */
  claimsByTargetId: ClaimsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
};

/** A `Identity` edge in the connection, with data from `Claim`. */
export type IdentityIdentitiesByClaimIssuerIdAndTargetIdManyToManyEdgeClaimsByTargetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ClaimFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClaimsOrderBy>>;
};

/** A connection to a list of `Identity` values, with data from `Claim`. */
export type IdentityIdentitiesByClaimTargetIdAndIssuerIdManyToManyConnection = {
  __typename?: 'IdentityIdentitiesByClaimTargetIdAndIssuerIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `Claim`, and the cursor to aid in pagination. */
  edges: Array<IdentityIdentitiesByClaimTargetIdAndIssuerIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `Claim`. */
export type IdentityIdentitiesByClaimTargetIdAndIssuerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Claim`. */
export type IdentityIdentitiesByClaimTargetIdAndIssuerIdManyToManyEdge = {
  __typename?: 'IdentityIdentitiesByClaimTargetIdAndIssuerIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Claim`. */
  claimsByIssuerId: ClaimsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
};

/** A `Identity` edge in the connection, with data from `Claim`. */
export type IdentityIdentitiesByClaimTargetIdAndIssuerIdManyToManyEdgeClaimsByIssuerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ClaimFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClaimsOrderBy>>;
};

/** A connection to a list of `Identity` values, with data from `Portfolio`. */
export type IdentityIdentitiesByPortfolioCustodianIdAndIdentityIdManyToManyConnection = {
  __typename?: 'IdentityIdentitiesByPortfolioCustodianIdAndIdentityIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `Portfolio`, and the cursor to aid in pagination. */
  edges: Array<IdentityIdentitiesByPortfolioCustodianIdAndIdentityIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `Portfolio`. */
export type IdentityIdentitiesByPortfolioCustodianIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Portfolio`. */
export type IdentityIdentitiesByPortfolioCustodianIdAndIdentityIdManyToManyEdge = {
  __typename?: 'IdentityIdentitiesByPortfolioCustodianIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfolios: PortfoliosConnection;
};

/** A `Identity` edge in the connection, with data from `Portfolio`. */
export type IdentityIdentitiesByPortfolioCustodianIdAndIdentityIdManyToManyEdgePortfoliosArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/** A connection to a list of `Identity` values, with data from `Portfolio`. */
export type IdentityIdentitiesByPortfolioIdentityIdAndCustodianIdManyToManyConnection = {
  __typename?: 'IdentityIdentitiesByPortfolioIdentityIdAndCustodianIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `Portfolio`, and the cursor to aid in pagination. */
  edges: Array<IdentityIdentitiesByPortfolioIdentityIdAndCustodianIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `Portfolio`. */
export type IdentityIdentitiesByPortfolioIdentityIdAndCustodianIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Portfolio`. */
export type IdentityIdentitiesByPortfolioIdentityIdAndCustodianIdManyToManyEdge = {
  __typename?: 'IdentityIdentitiesByPortfolioIdentityIdAndCustodianIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByCustodianId: PortfoliosConnection;
};

/** A `Identity` edge in the connection, with data from `Portfolio`. */
export type IdentityIdentitiesByPortfolioIdentityIdAndCustodianIdManyToManyEdgePortfoliosByCustodianIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<PortfolioFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
  };

/** A connection to a list of `Permission` values, with data from `Account`. */
export type IdentityPermissionsByAccountIdentityIdAndPermissionsIdManyToManyConnection = {
  __typename?: 'IdentityPermissionsByAccountIdentityIdAndPermissionsIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PermissionAggregates>;
  /** A list of edges which contains the `Permission`, info from the `Account`, and the cursor to aid in pagination. */
  edges: Array<IdentityPermissionsByAccountIdentityIdAndPermissionsIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PermissionAggregates>>;
  /** A list of `Permission` objects. */
  nodes: Array<Maybe<Permission>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Permission` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Permission` values, with data from `Account`. */
export type IdentityPermissionsByAccountIdentityIdAndPermissionsIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PermissionsGroupBy>;
    having?: InputMaybe<PermissionsHavingInput>;
  };

/** A `Permission` edge in the connection, with data from `Account`. */
export type IdentityPermissionsByAccountIdentityIdAndPermissionsIdManyToManyEdge = {
  __typename?: 'IdentityPermissionsByAccountIdentityIdAndPermissionsIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Account`. */
  accountsByPermissionsId: AccountsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Permission` at the end of the edge. */
  node?: Maybe<Permission>;
};

/** A `Permission` edge in the connection, with data from `Account`. */
export type IdentityPermissionsByAccountIdentityIdAndPermissionsIdManyToManyEdgeAccountsByPermissionsIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AccountFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AccountsOrderBy>>;
  };

/** A connection to a list of `Portfolio` values, with data from `Distribution`. */
export type IdentityPortfoliosByDistributionIdentityIdAndPortfolioIdManyToManyConnection = {
  __typename?: 'IdentityPortfoliosByDistributionIdentityIdAndPortfolioIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<IdentityPortfoliosByDistributionIdentityIdAndPortfolioIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `Distribution`. */
export type IdentityPortfoliosByDistributionIdentityIdAndPortfolioIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: InputMaybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `Distribution`. */
export type IdentityPortfoliosByDistributionIdentityIdAndPortfolioIdManyToManyEdge = {
  __typename?: 'IdentityPortfoliosByDistributionIdentityIdAndPortfolioIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributions: DistributionsConnection;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
};

/** A `Portfolio` edge in the connection, with data from `Distribution`. */
export type IdentityPortfoliosByDistributionIdentityIdAndPortfolioIdManyToManyEdgeDistributionsArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<DistributionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<DistributionsOrderBy>>;
  };

/** A connection to a list of `Portfolio` values, with data from `Sto`. */
export type IdentityPortfoliosByStoCreatorIdAndOfferingPortfolioIdManyToManyConnection = {
  __typename?: 'IdentityPortfoliosByStoCreatorIdAndOfferingPortfolioIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<IdentityPortfoliosByStoCreatorIdAndOfferingPortfolioIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `Sto`. */
export type IdentityPortfoliosByStoCreatorIdAndOfferingPortfolioIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: InputMaybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `Sto`. */
export type IdentityPortfoliosByStoCreatorIdAndOfferingPortfolioIdManyToManyEdge = {
  __typename?: 'IdentityPortfoliosByStoCreatorIdAndOfferingPortfolioIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByOfferingPortfolioId: StosConnection;
};

/** A `Portfolio` edge in the connection, with data from `Sto`. */
export type IdentityPortfoliosByStoCreatorIdAndOfferingPortfolioIdManyToManyEdgeStosByOfferingPortfolioIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StoFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StosOrderBy>>;
  };

/** A connection to a list of `Portfolio` values, with data from `Sto`. */
export type IdentityPortfoliosByStoCreatorIdAndRaisingPortfolioIdManyToManyConnection = {
  __typename?: 'IdentityPortfoliosByStoCreatorIdAndRaisingPortfolioIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<IdentityPortfoliosByStoCreatorIdAndRaisingPortfolioIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `Sto`. */
export type IdentityPortfoliosByStoCreatorIdAndRaisingPortfolioIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: InputMaybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `Sto`. */
export type IdentityPortfoliosByStoCreatorIdAndRaisingPortfolioIdManyToManyEdge = {
  __typename?: 'IdentityPortfoliosByStoCreatorIdAndRaisingPortfolioIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByRaisingPortfolioId: StosConnection;
};

/** A `Portfolio` edge in the connection, with data from `Sto`. */
export type IdentityPortfoliosByStoCreatorIdAndRaisingPortfolioIdManyToManyEdgeStosByRaisingPortfolioIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StoFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StosOrderBy>>;
  };

/** A connection to a list of `StatType` values, with data from `TransferCompliance`. */
export type IdentityStatTypesByTransferComplianceClaimIssuerIdAndStatTypeIdManyToManyConnection = {
  __typename?: 'IdentityStatTypesByTransferComplianceClaimIssuerIdAndStatTypeIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<StatTypeAggregates>;
  /** A list of edges which contains the `StatType`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
  edges: Array<IdentityStatTypesByTransferComplianceClaimIssuerIdAndStatTypeIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<StatTypeAggregates>>;
  /** A list of `StatType` objects. */
  nodes: Array<Maybe<StatType>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `StatType` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `StatType` values, with data from `TransferCompliance`. */
export type IdentityStatTypesByTransferComplianceClaimIssuerIdAndStatTypeIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<StatTypesGroupBy>;
    having?: InputMaybe<StatTypesHavingInput>;
  };

/** A `StatType` edge in the connection, with data from `TransferCompliance`. */
export type IdentityStatTypesByTransferComplianceClaimIssuerIdAndStatTypeIdManyToManyEdge = {
  __typename?: 'IdentityStatTypesByTransferComplianceClaimIssuerIdAndStatTypeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `StatType` at the end of the edge. */
  node?: Maybe<StatType>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliances: TransferCompliancesConnection;
};

/** A `StatType` edge in the connection, with data from `TransferCompliance`. */
export type IdentityStatTypesByTransferComplianceClaimIssuerIdAndStatTypeIdManyToManyEdgeTransferCompliancesArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TransferComplianceFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TransferCompliancesOrderBy>>;
  };

/** A connection to a list of `Venue` values, with data from `Sto`. */
export type IdentityVenuesByStoCreatorIdAndVenueIdManyToManyConnection = {
  __typename?: 'IdentityVenuesByStoCreatorIdAndVenueIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<VenueAggregates>;
  /** A list of edges which contains the `Venue`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<IdentityVenuesByStoCreatorIdAndVenueIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<VenueAggregates>>;
  /** A list of `Venue` objects. */
  nodes: Array<Maybe<Venue>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Venue` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Venue` values, with data from `Sto`. */
export type IdentityVenuesByStoCreatorIdAndVenueIdManyToManyConnectionGroupedAggregatesArgs = {
  groupBy: Array<VenuesGroupBy>;
  having?: InputMaybe<VenuesHavingInput>;
};

/** A `Venue` edge in the connection, with data from `Sto`. */
export type IdentityVenuesByStoCreatorIdAndVenueIdManyToManyEdge = {
  __typename?: 'IdentityVenuesByStoCreatorIdAndVenueIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Venue` at the end of the edge. */
  node?: Maybe<Venue>;
  /** Reads and enables pagination through a set of `Sto`. */
  stos: StosConnection;
};

/** A `Venue` edge in the connection, with data from `Sto`. */
export type IdentityVenuesByStoCreatorIdAndVenueIdManyToManyEdgeStosArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StoFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StosOrderBy>>;
};

/**
 * Represents a request to exchange Assets between parties.
 *
 * Before an Instruction is executed all involved parties must sign and submit an affirmation. Once an Instruction is affirmed it will then be attempted to be executed. If any party fails to satisfy any compliance or transfer restriction the Instruction will fail, and no movement of assets will occur.
 */
export type Instruction = Node & {
  __typename?: 'Instruction';
  /** Reads and enables pagination through a set of `Block`. */
  blocksByLegInstructionIdAndCreatedBlockId: InstructionBlocksByLegInstructionIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByLegInstructionIdAndUpdatedBlockId: InstructionBlocksByLegInstructionIdAndUpdatedBlockIdManyToManyConnection;
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `Instruction`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  endBlock?: Maybe<Scalars['Int']['output']>;
  eventId: EventIdEnum;
  eventIdx: Scalars['Int']['output'];
  id: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `Leg`. */
  legs: LegsConnection;
  memo?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByLegInstructionIdAndFromId: InstructionPortfoliosByLegInstructionIdAndFromIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByLegInstructionIdAndToId: InstructionPortfoliosByLegInstructionIdAndToIdManyToManyConnection;
  settlementType: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `Settlement`. */
  settlementsByLegInstructionIdAndSettlementId: InstructionSettlementsByLegInstructionIdAndSettlementIdManyToManyConnection;
  status: InstructionStatusEnum;
  tradeDate?: Maybe<Scalars['Datetime']['output']>;
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `Instruction`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
  valueDate?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `Venue` that is related to this `Instruction`. */
  venue?: Maybe<Venue>;
  venueId: Scalars['String']['output'];
};

/**
 * Represents a request to exchange Assets between parties.
 *
 * Before an Instruction is executed all involved parties must sign and submit an affirmation. Once an Instruction is affirmed it will then be attempted to be executed. If any party fails to satisfy any compliance or transfer restriction the Instruction will fail, and no movement of assets will occur.
 */
export type InstructionBlocksByLegInstructionIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a request to exchange Assets between parties.
 *
 * Before an Instruction is executed all involved parties must sign and submit an affirmation. Once an Instruction is affirmed it will then be attempted to be executed. If any party fails to satisfy any compliance or transfer restriction the Instruction will fail, and no movement of assets will occur.
 */
export type InstructionBlocksByLegInstructionIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a request to exchange Assets between parties.
 *
 * Before an Instruction is executed all involved parties must sign and submit an affirmation. Once an Instruction is affirmed it will then be attempted to be executed. If any party fails to satisfy any compliance or transfer restriction the Instruction will fail, and no movement of assets will occur.
 */
export type InstructionLegsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<LegFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LegsOrderBy>>;
};

/**
 * Represents a request to exchange Assets between parties.
 *
 * Before an Instruction is executed all involved parties must sign and submit an affirmation. Once an Instruction is affirmed it will then be attempted to be executed. If any party fails to satisfy any compliance or transfer restriction the Instruction will fail, and no movement of assets will occur.
 */
export type InstructionPortfoliosByLegInstructionIdAndFromIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/**
 * Represents a request to exchange Assets between parties.
 *
 * Before an Instruction is executed all involved parties must sign and submit an affirmation. Once an Instruction is affirmed it will then be attempted to be executed. If any party fails to satisfy any compliance or transfer restriction the Instruction will fail, and no movement of assets will occur.
 */
export type InstructionPortfoliosByLegInstructionIdAndToIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/**
 * Represents a request to exchange Assets between parties.
 *
 * Before an Instruction is executed all involved parties must sign and submit an affirmation. Once an Instruction is affirmed it will then be attempted to be executed. If any party fails to satisfy any compliance or transfer restriction the Instruction will fail, and no movement of assets will occur.
 */
export type InstructionSettlementsByLegInstructionIdAndSettlementIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<SettlementFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SettlementsOrderBy>>;
};

export type InstructionAggregates = {
  __typename?: 'InstructionAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A connection to a list of `Block` values, with data from `Leg`. */
export type InstructionBlocksByLegInstructionIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'InstructionBlocksByLegInstructionIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<InstructionBlocksByLegInstructionIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Leg`. */
export type InstructionBlocksByLegInstructionIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Leg`. */
export type InstructionBlocksByLegInstructionIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'InstructionBlocksByLegInstructionIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByCreatedBlockId: LegsConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Leg`. */
export type InstructionBlocksByLegInstructionIdAndCreatedBlockIdManyToManyEdgeLegsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<LegFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<LegsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Leg`. */
export type InstructionBlocksByLegInstructionIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'InstructionBlocksByLegInstructionIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<InstructionBlocksByLegInstructionIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Leg`. */
export type InstructionBlocksByLegInstructionIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Leg`. */
export type InstructionBlocksByLegInstructionIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'InstructionBlocksByLegInstructionIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByUpdatedBlockId: LegsConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Leg`. */
export type InstructionBlocksByLegInstructionIdAndUpdatedBlockIdManyToManyEdgeLegsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<LegFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<LegsOrderBy>>;
  };

/** A filter to be used against `Instruction` object types. All fields are combined with a logical ‘and.’ */
export type InstructionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<InstructionFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `endBlock` field. */
  endBlock?: InputMaybe<IntFilter>;
  /** Filter by the object’s `eventId` field. */
  eventId?: InputMaybe<EventIdEnumFilter>;
  /** Filter by the object’s `eventIdx` field. */
  eventIdx?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `memo` field. */
  memo?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<InstructionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<InstructionFilter>>;
  /** Filter by the object’s `settlementType` field. */
  settlementType?: InputMaybe<StringFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<InstructionStatusEnumFilter>;
  /** Filter by the object’s `tradeDate` field. */
  tradeDate?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `valueDate` field. */
  valueDate?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `venueId` field. */
  venueId?: InputMaybe<StringFilter>;
};

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type InstructionPortfoliosByLegInstructionIdAndFromIdManyToManyConnection = {
  __typename?: 'InstructionPortfoliosByLegInstructionIdAndFromIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<InstructionPortfoliosByLegInstructionIdAndFromIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type InstructionPortfoliosByLegInstructionIdAndFromIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: InputMaybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type InstructionPortfoliosByLegInstructionIdAndFromIdManyToManyEdge = {
  __typename?: 'InstructionPortfoliosByLegInstructionIdAndFromIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByFromId: LegsConnection;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
};

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type InstructionPortfoliosByLegInstructionIdAndFromIdManyToManyEdgeLegsByFromIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<LegFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LegsOrderBy>>;
};

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type InstructionPortfoliosByLegInstructionIdAndToIdManyToManyConnection = {
  __typename?: 'InstructionPortfoliosByLegInstructionIdAndToIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<InstructionPortfoliosByLegInstructionIdAndToIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type InstructionPortfoliosByLegInstructionIdAndToIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: InputMaybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type InstructionPortfoliosByLegInstructionIdAndToIdManyToManyEdge = {
  __typename?: 'InstructionPortfoliosByLegInstructionIdAndToIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByToId: LegsConnection;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
};

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type InstructionPortfoliosByLegInstructionIdAndToIdManyToManyEdgeLegsByToIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<LegFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LegsOrderBy>>;
};

/** A connection to a list of `Settlement` values, with data from `Leg`. */
export type InstructionSettlementsByLegInstructionIdAndSettlementIdManyToManyConnection = {
  __typename?: 'InstructionSettlementsByLegInstructionIdAndSettlementIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<SettlementAggregates>;
  /** A list of edges which contains the `Settlement`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<InstructionSettlementsByLegInstructionIdAndSettlementIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<SettlementAggregates>>;
  /** A list of `Settlement` objects. */
  nodes: Array<Maybe<Settlement>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Settlement` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Settlement` values, with data from `Leg`. */
export type InstructionSettlementsByLegInstructionIdAndSettlementIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<SettlementsGroupBy>;
    having?: InputMaybe<SettlementsHavingInput>;
  };

/** A `Settlement` edge in the connection, with data from `Leg`. */
export type InstructionSettlementsByLegInstructionIdAndSettlementIdManyToManyEdge = {
  __typename?: 'InstructionSettlementsByLegInstructionIdAndSettlementIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Leg`. */
  legs: LegsConnection;
  /** The `Settlement` at the end of the edge. */
  node?: Maybe<Settlement>;
};

/** A `Settlement` edge in the connection, with data from `Leg`. */
export type InstructionSettlementsByLegInstructionIdAndSettlementIdManyToManyEdgeLegsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<LegFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LegsOrderBy>>;
};

/**  Represents all possible states of an Instruction */
export enum InstructionStatusEnum {
  Created = 'Created',
  Executed = 'Executed',
  Failed = 'Failed',
  Rejected = 'Rejected',
}

/** A filter to be used against InstructionStatusEnum fields. All fields are combined with a logical ‘and.’ */
export type InstructionStatusEnumFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<InstructionStatusEnum>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<InstructionStatusEnum>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<InstructionStatusEnum>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<InstructionStatusEnum>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<InstructionStatusEnum>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<InstructionStatusEnum>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<InstructionStatusEnum>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<InstructionStatusEnum>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<InstructionStatusEnum>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<InstructionStatusEnum>>;
};

/** A connection to a list of `Instruction` values. */
export type InstructionsConnection = {
  __typename?: 'InstructionsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<InstructionAggregates>;
  /** A list of edges which contains the `Instruction` and cursor to aid in pagination. */
  edges: Array<InstructionsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<InstructionAggregates>>;
  /** A list of `Instruction` objects. */
  nodes: Array<Maybe<Instruction>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Instruction` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Instruction` values. */
export type InstructionsConnectionGroupedAggregatesArgs = {
  groupBy: Array<InstructionsGroupBy>;
  having?: InputMaybe<InstructionsHavingInput>;
};

/** A `Instruction` edge in the connection. */
export type InstructionsEdge = {
  __typename?: 'InstructionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Instruction` at the end of the edge. */
  node?: Maybe<Instruction>;
};

/** Grouping methods for `Instruction` for usage during aggregation. */
export enum InstructionsGroupBy {
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  EndBlock = 'END_BLOCK',
  EventId = 'EVENT_ID',
  EventIdx = 'EVENT_IDX',
  Memo = 'MEMO',
  SettlementType = 'SETTLEMENT_TYPE',
  Status = 'STATUS',
  TradeDate = 'TRADE_DATE',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  ValueDate = 'VALUE_DATE',
  VenueId = 'VENUE_ID',
}

/** Conditions for `Instruction` aggregates. */
export type InstructionsHavingInput = {
  AND?: InputMaybe<Array<InstructionsHavingInput>>;
  OR?: InputMaybe<Array<InstructionsHavingInput>>;
};

/** Methods to use when ordering `Instruction`. */
export enum InstructionsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  EndBlockAsc = 'END_BLOCK_ASC',
  EndBlockDesc = 'END_BLOCK_DESC',
  EventIdxAsc = 'EVENT_IDX_ASC',
  EventIdxDesc = 'EVENT_IDX_DESC',
  EventIdAsc = 'EVENT_ID_ASC',
  EventIdDesc = 'EVENT_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LegsCountAsc = 'LEGS_COUNT_ASC',
  LegsCountDesc = 'LEGS_COUNT_DESC',
  MemoAsc = 'MEMO_ASC',
  MemoDesc = 'MEMO_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SettlementTypeAsc = 'SETTLEMENT_TYPE_ASC',
  SettlementTypeDesc = 'SETTLEMENT_TYPE_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  TradeDateAsc = 'TRADE_DATE_ASC',
  TradeDateDesc = 'TRADE_DATE_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  ValueDateAsc = 'VALUE_DATE_ASC',
  ValueDateDesc = 'VALUE_DATE_DESC',
  VenueIdAsc = 'VENUE_ID_ASC',
  VenueIdDesc = 'VENUE_ID_DESC',
}

/** A filter to be used against Int fields. All fields are combined with a logical ‘and.’ */
export type IntFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Int']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Int']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Int']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Int']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Int']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** Represents participation in an STO */
export type Investment = Node & {
  __typename?: 'Investment';
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `Investment`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  datetime: Scalars['Datetime']['output'];
  id: Scalars['String']['output'];
  /** Reads a single `Identity` that is related to this `Investment`. */
  investor?: Maybe<Identity>;
  investorId: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  offeringToken: Scalars['String']['output'];
  offeringTokenAmount: Scalars['BigFloat']['output'];
  raiseToken: Scalars['String']['output'];
  raiseTokenAmount: Scalars['BigFloat']['output'];
  stoId: Scalars['Int']['output'];
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `Investment`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
};

export type InvestmentAggregates = {
  __typename?: 'InvestmentAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A filter to be used against `Investment` object types. All fields are combined with a logical ‘and.’ */
export type InvestmentFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<InvestmentFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `datetime` field. */
  datetime?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `investorId` field. */
  investorId?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<InvestmentFilter>;
  /** Filter by the object’s `offeringToken` field. */
  offeringToken?: InputMaybe<StringFilter>;
  /** Filter by the object’s `offeringTokenAmount` field. */
  offeringTokenAmount?: InputMaybe<BigFloatFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<InvestmentFilter>>;
  /** Filter by the object’s `raiseToken` field. */
  raiseToken?: InputMaybe<StringFilter>;
  /** Filter by the object’s `raiseTokenAmount` field. */
  raiseTokenAmount?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `stoId` field. */
  stoId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
};

/** A connection to a list of `Investment` values. */
export type InvestmentsConnection = {
  __typename?: 'InvestmentsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<InvestmentAggregates>;
  /** A list of edges which contains the `Investment` and cursor to aid in pagination. */
  edges: Array<InvestmentsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<InvestmentAggregates>>;
  /** A list of `Investment` objects. */
  nodes: Array<Maybe<Investment>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Investment` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Investment` values. */
export type InvestmentsConnectionGroupedAggregatesArgs = {
  groupBy: Array<InvestmentsGroupBy>;
  having?: InputMaybe<InvestmentsHavingInput>;
};

/** A `Investment` edge in the connection. */
export type InvestmentsEdge = {
  __typename?: 'InvestmentsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Investment` at the end of the edge. */
  node?: Maybe<Investment>;
};

/** Grouping methods for `Investment` for usage during aggregation. */
export enum InvestmentsGroupBy {
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  Datetime = 'DATETIME',
  InvestorId = 'INVESTOR_ID',
  OfferingToken = 'OFFERING_TOKEN',
  OfferingTokenAmount = 'OFFERING_TOKEN_AMOUNT',
  RaiseToken = 'RAISE_TOKEN',
  RaiseTokenAmount = 'RAISE_TOKEN_AMOUNT',
  StoId = 'STO_ID',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
}

/** Conditions for `Investment` aggregates. */
export type InvestmentsHavingInput = {
  AND?: InputMaybe<Array<InvestmentsHavingInput>>;
  OR?: InputMaybe<Array<InvestmentsHavingInput>>;
};

/** Methods to use when ordering `Investment`. */
export enum InvestmentsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  DatetimeAsc = 'DATETIME_ASC',
  DatetimeDesc = 'DATETIME_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InvestorIdAsc = 'INVESTOR_ID_ASC',
  InvestorIdDesc = 'INVESTOR_ID_DESC',
  Natural = 'NATURAL',
  OfferingTokenAmountAsc = 'OFFERING_TOKEN_AMOUNT_ASC',
  OfferingTokenAmountDesc = 'OFFERING_TOKEN_AMOUNT_DESC',
  OfferingTokenAsc = 'OFFERING_TOKEN_ASC',
  OfferingTokenDesc = 'OFFERING_TOKEN_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RaiseTokenAmountAsc = 'RAISE_TOKEN_AMOUNT_ASC',
  RaiseTokenAmountDesc = 'RAISE_TOKEN_AMOUNT_DESC',
  RaiseTokenAsc = 'RAISE_TOKEN_ASC',
  RaiseTokenDesc = 'RAISE_TOKEN_DESC',
  StoIdAsc = 'STO_ID_ASC',
  StoIdDesc = 'STO_ID_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
}

/** A filter to be used against JSON fields. All fields are combined with a logical ‘and.’ */
export type JsonFilter = {
  /** Contained by the specified JSON. */
  containedBy?: InputMaybe<Scalars['JSON']['input']>;
  /** Contains the specified JSON. */
  contains?: InputMaybe<Scalars['JSON']['input']>;
  /** Contains all of the specified keys. */
  containsAllKeys?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Contains any of the specified keys. */
  containsAnyKeys?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Contains the specified key. */
  containsKey?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['JSON']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['JSON']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['JSON']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['JSON']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['JSON']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['JSON']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['JSON']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['JSON']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['JSON']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['JSON']['input']>>;
};

/** Represents the movement of a single Asset in a trade, e.g. Alice will give Bob 1 USDS */
export type Leg = Node & {
  __typename?: 'Leg';
  addresses: Scalars['JSON']['output'];
  /** `amount` can be null for non-fungible tokens */
  amount?: Maybe<Scalars['BigFloat']['output']>;
  assetId: Scalars['String']['output'];
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `Leg`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  /** Reads a single `Portfolio` that is related to this `Leg`. */
  from?: Maybe<Portfolio>;
  fromId: Scalars['String']['output'];
  id: Scalars['String']['output'];
  /** Reads a single `Instruction` that is related to this `Leg`. */
  instruction?: Maybe<Instruction>;
  instructionId?: Maybe<Scalars['String']['output']>;
  legType: LegTypeEnum;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Settlement` that is related to this `Leg`. */
  settlement?: Maybe<Settlement>;
  settlementId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Portfolio` that is related to this `Leg`. */
  to?: Maybe<Portfolio>;
  toId: Scalars['String']['output'];
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `Leg`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
};

export type LegAggregates = {
  __typename?: 'LegAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A filter to be used against `Leg` object types. All fields are combined with a logical ‘and.’ */
export type LegFilter = {
  /** Filter by the object’s `addresses` field. */
  addresses?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `amount` field. */
  amount?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<LegFilter>>;
  /** Filter by the object’s `assetId` field. */
  assetId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `fromId` field. */
  fromId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `instructionId` field. */
  instructionId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `legType` field. */
  legType?: InputMaybe<LegTypeEnumFilter>;
  /** Negates the expression. */
  not?: InputMaybe<LegFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<LegFilter>>;
  /** Filter by the object’s `settlementId` field. */
  settlementId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `toId` field. */
  toId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
};

/**  Represents all possible states of an Instruction */
export enum LegTypeEnum {
  Fungible = 'Fungible',
  NonFungible = 'NonFungible',
  OffChain = 'OffChain',
}

/** A filter to be used against LegTypeEnum fields. All fields are combined with a logical ‘and.’ */
export type LegTypeEnumFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<LegTypeEnum>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<LegTypeEnum>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<LegTypeEnum>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<LegTypeEnum>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<LegTypeEnum>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<LegTypeEnum>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<LegTypeEnum>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<LegTypeEnum>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<LegTypeEnum>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<LegTypeEnum>>;
};

/** A connection to a list of `Leg` values. */
export type LegsConnection = {
  __typename?: 'LegsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<LegAggregates>;
  /** A list of edges which contains the `Leg` and cursor to aid in pagination. */
  edges: Array<LegsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<LegAggregates>>;
  /** A list of `Leg` objects. */
  nodes: Array<Maybe<Leg>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Leg` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Leg` values. */
export type LegsConnectionGroupedAggregatesArgs = {
  groupBy: Array<LegsGroupBy>;
  having?: InputMaybe<LegsHavingInput>;
};

/** A `Leg` edge in the connection. */
export type LegsEdge = {
  __typename?: 'LegsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Leg` at the end of the edge. */
  node?: Maybe<Leg>;
};

/** Grouping methods for `Leg` for usage during aggregation. */
export enum LegsGroupBy {
  Addresses = 'ADDRESSES',
  Amount = 'AMOUNT',
  AssetId = 'ASSET_ID',
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  FromId = 'FROM_ID',
  InstructionId = 'INSTRUCTION_ID',
  LegType = 'LEG_TYPE',
  SettlementId = 'SETTLEMENT_ID',
  ToId = 'TO_ID',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
}

/** Conditions for `Leg` aggregates. */
export type LegsHavingInput = {
  AND?: InputMaybe<Array<LegsHavingInput>>;
  OR?: InputMaybe<Array<LegsHavingInput>>;
};

/** Methods to use when ordering `Leg`. */
export enum LegsOrderBy {
  AddressesAsc = 'ADDRESSES_ASC',
  AddressesDesc = 'ADDRESSES_DESC',
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  AssetIdAsc = 'ASSET_ID_ASC',
  AssetIdDesc = 'ASSET_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  FromIdAsc = 'FROM_ID_ASC',
  FromIdDesc = 'FROM_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InstructionIdAsc = 'INSTRUCTION_ID_ASC',
  InstructionIdDesc = 'INSTRUCTION_ID_DESC',
  LegTypeAsc = 'LEG_TYPE_ASC',
  LegTypeDesc = 'LEG_TYPE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SettlementIdAsc = 'SETTLEMENT_ID_ASC',
  SettlementIdDesc = 'SETTLEMENT_ID_DESC',
  ToIdAsc = 'TO_ID_ASC',
  ToIdDesc = 'TO_ID_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
}

/** Represents the list of migrations executed */
export type Migration = Node & {
  __typename?: 'Migration';
  createdAt: Scalars['Datetime']['output'];
  executed: Scalars['Boolean']['output'];
  id: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  number: Scalars['Int']['output'];
  processedBlock: Scalars['Int']['output'];
  updatedAt: Scalars['Datetime']['output'];
  version: Scalars['String']['output'];
};

export type MigrationAggregates = {
  __typename?: 'MigrationAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A filter to be used against `Migration` object types. All fields are combined with a logical ‘and.’ */
export type MigrationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MigrationFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `executed` field. */
  executed?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MigrationFilter>;
  /** Filter by the object’s `number` field. */
  number?: InputMaybe<IntFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MigrationFilter>>;
  /** Filter by the object’s `processedBlock` field. */
  processedBlock?: InputMaybe<IntFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `version` field. */
  version?: InputMaybe<StringFilter>;
};

/** A connection to a list of `Migration` values. */
export type MigrationsConnection = {
  __typename?: 'MigrationsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<MigrationAggregates>;
  /** A list of edges which contains the `Migration` and cursor to aid in pagination. */
  edges: Array<MigrationsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<MigrationAggregates>>;
  /** A list of `Migration` objects. */
  nodes: Array<Maybe<Migration>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Migration` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Migration` values. */
export type MigrationsConnectionGroupedAggregatesArgs = {
  groupBy: Array<MigrationsGroupBy>;
  having?: InputMaybe<MigrationsHavingInput>;
};

/** A `Migration` edge in the connection. */
export type MigrationsEdge = {
  __typename?: 'MigrationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Migration` at the end of the edge. */
  node?: Maybe<Migration>;
};

/** Grouping methods for `Migration` for usage during aggregation. */
export enum MigrationsGroupBy {
  CreatedAt = 'CREATED_AT',
  Executed = 'EXECUTED',
  Number = 'NUMBER',
  ProcessedBlock = 'PROCESSED_BLOCK',
  UpdatedAt = 'UPDATED_AT',
  Version = 'VERSION',
}

/** Conditions for `Migration` aggregates. */
export type MigrationsHavingInput = {
  AND?: InputMaybe<Array<MigrationsHavingInput>>;
  OR?: InputMaybe<Array<MigrationsHavingInput>>;
};

/** Methods to use when ordering `Migration`. */
export enum MigrationsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  ExecutedAsc = 'EXECUTED_ASC',
  ExecutedDesc = 'EXECUTED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  NumberAsc = 'NUMBER_ASC',
  NumberDesc = 'NUMBER_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ProcessedBlockAsc = 'PROCESSED_BLOCK_ASC',
  ProcessedBlockDesc = 'PROCESSED_BLOCK_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  VersionAsc = 'VERSION_ASC',
  VersionDesc = 'VERSION_DESC',
}

/**  Represents all known chain "pallets" */
export enum ModuleIdEnum {
  Asset = 'asset',
  Authoritydiscovery = 'authoritydiscovery',
  Authorship = 'authorship',
  Babe = 'babe',
  Balances = 'balances',
  Base = 'base',
  Bridge = 'bridge',
  Capitaldistribution = 'capitaldistribution',
  Cddserviceproviders = 'cddserviceproviders',
  Checkpoint = 'checkpoint',
  Committeemembership = 'committeemembership',
  Compliancemanager = 'compliancemanager',
  Confidential = 'confidential',
  Contracts = 'contracts',
  Corporateaction = 'corporateaction',
  Corporateballot = 'corporateballot',
  Dividend = 'dividend',
  Exemption = 'exemption',
  Externalagents = 'externalagents',
  Finalitytracker = 'finalitytracker',
  Grandpa = 'grandpa',
  Historical = 'historical',
  Identity = 'identity',
  Imonline = 'imonline',
  Indices = 'indices',
  Multisig = 'multisig',
  Nft = 'nft',
  Offences = 'offences',
  Permissions = 'permissions',
  Pips = 'pips',
  Polymeshcommittee = 'polymeshcommittee',
  Polymeshcontracts = 'polymeshcontracts',
  Portfolio = 'portfolio',
  Preimage = 'preimage',
  Protocolfee = 'protocolfee',
  Randomnesscollectiveflip = 'randomnesscollectiveflip',
  Relayer = 'relayer',
  Rewards = 'rewards',
  Scheduler = 'scheduler',
  Session = 'session',
  Settlement = 'settlement',
  Staking = 'staking',
  Statistics = 'statistics',
  Sto = 'sto',
  Stocapped = 'stocapped',
  Sudo = 'sudo',
  System = 'system',
  Technicalcommittee = 'technicalcommittee',
  Technicalcommitteemembership = 'technicalcommitteemembership',
  Testutils = 'testutils',
  Timestamp = 'timestamp',
  Transactionpayment = 'transactionpayment',
  Treasury = 'treasury',
  Upgradecommittee = 'upgradecommittee',
  Upgradecommitteemembership = 'upgradecommitteemembership',
  Utility = 'utility',
}

/** A filter to be used against ModuleIdEnum fields. All fields are combined with a logical ‘and.’ */
export type ModuleIdEnumFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<ModuleIdEnum>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<ModuleIdEnum>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<ModuleIdEnum>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<ModuleIdEnum>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<ModuleIdEnum>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<ModuleIdEnum>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<ModuleIdEnum>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<ModuleIdEnum>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<ModuleIdEnum>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<ModuleIdEnum>>;
};

/** An object with a globally unique `ID`. */
export type Node = {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']['output']>;
};

/** Represents an Account's permissions. The primary key for an Identity always has full permission */
export type Permission = Node & {
  __typename?: 'Permission';
  /** Reads and enables pagination through a set of `Account`. */
  accountsByPermissionsId: AccountsConnection;
  assets?: Maybe<Scalars['JSON']['output']>;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAccountPermissionsIdAndCreatedBlockId: PermissionBlocksByAccountPermissionsIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAccountPermissionsIdAndUpdatedBlockId: PermissionBlocksByAccountPermissionsIdAndUpdatedBlockIdManyToManyConnection;
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `Permission`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  datetime: Scalars['Datetime']['output'];
  id: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByAccountPermissionsIdAndIdentityId: PermissionIdentitiesByAccountPermissionsIdAndIdentityIdManyToManyConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  portfolios?: Maybe<Scalars['JSON']['output']>;
  transactionGroups: Scalars['JSON']['output'];
  transactions?: Maybe<Scalars['JSON']['output']>;
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `Permission`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
};

/** Represents an Account's permissions. The primary key for an Identity always has full permission */
export type PermissionAccountsByPermissionsIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AccountFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountsOrderBy>>;
};

/** Represents an Account's permissions. The primary key for an Identity always has full permission */
export type PermissionBlocksByAccountPermissionsIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents an Account's permissions. The primary key for an Identity always has full permission */
export type PermissionBlocksByAccountPermissionsIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents an Account's permissions. The primary key for an Identity always has full permission */
export type PermissionIdentitiesByAccountPermissionsIdAndIdentityIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

export type PermissionAggregates = {
  __typename?: 'PermissionAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A connection to a list of `Block` values, with data from `Account`. */
export type PermissionBlocksByAccountPermissionsIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'PermissionBlocksByAccountPermissionsIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Account`, and the cursor to aid in pagination. */
  edges: Array<PermissionBlocksByAccountPermissionsIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Account`. */
export type PermissionBlocksByAccountPermissionsIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Account`. */
export type PermissionBlocksByAccountPermissionsIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'PermissionBlocksByAccountPermissionsIdAndCreatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Account`. */
  accountsByCreatedBlockId: AccountsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Account`. */
export type PermissionBlocksByAccountPermissionsIdAndCreatedBlockIdManyToManyEdgeAccountsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AccountFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AccountsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Account`. */
export type PermissionBlocksByAccountPermissionsIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'PermissionBlocksByAccountPermissionsIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Account`, and the cursor to aid in pagination. */
  edges: Array<PermissionBlocksByAccountPermissionsIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Account`. */
export type PermissionBlocksByAccountPermissionsIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Account`. */
export type PermissionBlocksByAccountPermissionsIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'PermissionBlocksByAccountPermissionsIdAndUpdatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Account`. */
  accountsByUpdatedBlockId: AccountsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Account`. */
export type PermissionBlocksByAccountPermissionsIdAndUpdatedBlockIdManyToManyEdgeAccountsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AccountFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AccountsOrderBy>>;
  };

/** A filter to be used against `Permission` object types. All fields are combined with a logical ‘and.’ */
export type PermissionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PermissionFilter>>;
  /** Filter by the object’s `assets` field. */
  assets?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `datetime` field. */
  datetime?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<PermissionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PermissionFilter>>;
  /** Filter by the object’s `portfolios` field. */
  portfolios?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `transactionGroups` field. */
  transactionGroups?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `transactions` field. */
  transactions?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
};

/** A connection to a list of `Identity` values, with data from `Account`. */
export type PermissionIdentitiesByAccountPermissionsIdAndIdentityIdManyToManyConnection = {
  __typename?: 'PermissionIdentitiesByAccountPermissionsIdAndIdentityIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `Account`, and the cursor to aid in pagination. */
  edges: Array<PermissionIdentitiesByAccountPermissionsIdAndIdentityIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `Account`. */
export type PermissionIdentitiesByAccountPermissionsIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Account`. */
export type PermissionIdentitiesByAccountPermissionsIdAndIdentityIdManyToManyEdge = {
  __typename?: 'PermissionIdentitiesByAccountPermissionsIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Account`. */
  secondaryAccounts: AccountsConnection;
};

/** A `Identity` edge in the connection, with data from `Account`. */
export type PermissionIdentitiesByAccountPermissionsIdAndIdentityIdManyToManyEdgeSecondaryAccountsArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AccountFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AccountsOrderBy>>;
  };

/** A connection to a list of `Permission` values. */
export type PermissionsConnection = {
  __typename?: 'PermissionsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PermissionAggregates>;
  /** A list of edges which contains the `Permission` and cursor to aid in pagination. */
  edges: Array<PermissionsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PermissionAggregates>>;
  /** A list of `Permission` objects. */
  nodes: Array<Maybe<Permission>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Permission` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Permission` values. */
export type PermissionsConnectionGroupedAggregatesArgs = {
  groupBy: Array<PermissionsGroupBy>;
  having?: InputMaybe<PermissionsHavingInput>;
};

/** A `Permission` edge in the connection. */
export type PermissionsEdge = {
  __typename?: 'PermissionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Permission` at the end of the edge. */
  node?: Maybe<Permission>;
};

/** Grouping methods for `Permission` for usage during aggregation. */
export enum PermissionsGroupBy {
  Assets = 'ASSETS',
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  Datetime = 'DATETIME',
  Portfolios = 'PORTFOLIOS',
  Transactions = 'TRANSACTIONS',
  TransactionGroups = 'TRANSACTION_GROUPS',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
}

/** Conditions for `Permission` aggregates. */
export type PermissionsHavingInput = {
  AND?: InputMaybe<Array<PermissionsHavingInput>>;
  OR?: InputMaybe<Array<PermissionsHavingInput>>;
};

/** Methods to use when ordering `Permission`. */
export enum PermissionsOrderBy {
  AccountsByPermissionsIdCountAsc = 'ACCOUNTS_BY_PERMISSIONS_ID_COUNT_ASC',
  AccountsByPermissionsIdCountDesc = 'ACCOUNTS_BY_PERMISSIONS_ID_COUNT_DESC',
  AssetsAsc = 'ASSETS_ASC',
  AssetsDesc = 'ASSETS_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  DatetimeAsc = 'DATETIME_ASC',
  DatetimeDesc = 'DATETIME_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PortfoliosAsc = 'PORTFOLIOS_ASC',
  PortfoliosDesc = 'PORTFOLIOS_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TransactionsAsc = 'TRANSACTIONS_ASC',
  TransactionsDesc = 'TRANSACTIONS_DESC',
  TransactionGroupsAsc = 'TRANSACTION_GROUPS_ASC',
  TransactionGroupsDesc = 'TRANSACTION_GROUPS_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
}

/** Represents transactions involving POLYX */
export type PolyxTransaction = Node & {
  __typename?: 'PolyxTransaction';
  address?: Maybe<Scalars['String']['output']>;
  amount: Scalars['BigFloat']['output'];
  callId?: Maybe<CallIdEnum>;
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `PolyxTransaction`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  datetime: Scalars['Datetime']['output'];
  eventId?: Maybe<EventIdEnum>;
  eventIdx: Scalars['Int']['output'];
  /** Reads a single `Extrinsic` that is related to this `PolyxTransaction`. */
  extrinsic?: Maybe<Extrinsic>;
  extrinsicId?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  identityId?: Maybe<Scalars['String']['output']>;
  memo?: Maybe<Scalars['String']['output']>;
  moduleId?: Maybe<ModuleIdEnum>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  toAddress?: Maybe<Scalars['String']['output']>;
  toId?: Maybe<Scalars['String']['output']>;
  type: BalanceTypeEnum;
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `PolyxTransaction`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
};

export type PolyxTransactionAggregates = {
  __typename?: 'PolyxTransactionAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A filter to be used against `PolyxTransaction` object types. All fields are combined with a logical ‘and.’ */
export type PolyxTransactionFilter = {
  /** Filter by the object’s `address` field. */
  address?: InputMaybe<StringFilter>;
  /** Filter by the object’s `amount` field. */
  amount?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PolyxTransactionFilter>>;
  /** Filter by the object’s `callId` field. */
  callId?: InputMaybe<CallIdEnumFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `datetime` field. */
  datetime?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `eventId` field. */
  eventId?: InputMaybe<EventIdEnumFilter>;
  /** Filter by the object’s `eventIdx` field. */
  eventIdx?: InputMaybe<IntFilter>;
  /** Filter by the object’s `extrinsicId` field. */
  extrinsicId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `identityId` field. */
  identityId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `memo` field. */
  memo?: InputMaybe<StringFilter>;
  /** Filter by the object’s `moduleId` field. */
  moduleId?: InputMaybe<ModuleIdEnumFilter>;
  /** Negates the expression. */
  not?: InputMaybe<PolyxTransactionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PolyxTransactionFilter>>;
  /** Filter by the object’s `toAddress` field. */
  toAddress?: InputMaybe<StringFilter>;
  /** Filter by the object’s `toId` field. */
  toId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<BalanceTypeEnumFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
};

/** A connection to a list of `PolyxTransaction` values. */
export type PolyxTransactionsConnection = {
  __typename?: 'PolyxTransactionsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PolyxTransactionAggregates>;
  /** A list of edges which contains the `PolyxTransaction` and cursor to aid in pagination. */
  edges: Array<PolyxTransactionsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PolyxTransactionAggregates>>;
  /** A list of `PolyxTransaction` objects. */
  nodes: Array<Maybe<PolyxTransaction>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PolyxTransaction` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `PolyxTransaction` values. */
export type PolyxTransactionsConnectionGroupedAggregatesArgs = {
  groupBy: Array<PolyxTransactionsGroupBy>;
  having?: InputMaybe<PolyxTransactionsHavingInput>;
};

/** A `PolyxTransaction` edge in the connection. */
export type PolyxTransactionsEdge = {
  __typename?: 'PolyxTransactionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `PolyxTransaction` at the end of the edge. */
  node?: Maybe<PolyxTransaction>;
};

/** Grouping methods for `PolyxTransaction` for usage during aggregation. */
export enum PolyxTransactionsGroupBy {
  Address = 'ADDRESS',
  Amount = 'AMOUNT',
  CallId = 'CALL_ID',
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  Datetime = 'DATETIME',
  EventId = 'EVENT_ID',
  EventIdx = 'EVENT_IDX',
  ExtrinsicId = 'EXTRINSIC_ID',
  IdentityId = 'IDENTITY_ID',
  Memo = 'MEMO',
  ModuleId = 'MODULE_ID',
  ToAddress = 'TO_ADDRESS',
  ToId = 'TO_ID',
  Type = 'TYPE',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
}

/** Conditions for `PolyxTransaction` aggregates. */
export type PolyxTransactionsHavingInput = {
  AND?: InputMaybe<Array<PolyxTransactionsHavingInput>>;
  OR?: InputMaybe<Array<PolyxTransactionsHavingInput>>;
};

/** Methods to use when ordering `PolyxTransaction`. */
export enum PolyxTransactionsOrderBy {
  AddressAsc = 'ADDRESS_ASC',
  AddressDesc = 'ADDRESS_DESC',
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  CallIdAsc = 'CALL_ID_ASC',
  CallIdDesc = 'CALL_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  DatetimeAsc = 'DATETIME_ASC',
  DatetimeDesc = 'DATETIME_DESC',
  EventIdxAsc = 'EVENT_IDX_ASC',
  EventIdxDesc = 'EVENT_IDX_DESC',
  EventIdAsc = 'EVENT_ID_ASC',
  EventIdDesc = 'EVENT_ID_DESC',
  ExtrinsicIdAsc = 'EXTRINSIC_ID_ASC',
  ExtrinsicIdDesc = 'EXTRINSIC_ID_DESC',
  IdentityIdAsc = 'IDENTITY_ID_ASC',
  IdentityIdDesc = 'IDENTITY_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MemoAsc = 'MEMO_ASC',
  MemoDesc = 'MEMO_DESC',
  ModuleIdAsc = 'MODULE_ID_ASC',
  ModuleIdDesc = 'MODULE_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ToAddressAsc = 'TO_ADDRESS_ASC',
  ToAddressDesc = 'TO_ADDRESS_DESC',
  ToIdAsc = 'TO_ID_ASC',
  ToIdDesc = 'TO_ID_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
}

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type Portfolio = Node & {
  __typename?: 'Portfolio';
  /** Reads and enables pagination through a set of `AssetTransaction`. */
  assetTransactionsByFromPortfolioId: AssetTransactionsConnection;
  /** Reads and enables pagination through a set of `AssetTransaction`. */
  assetTransactionsByToPortfolioId: AssetTransactionsConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByAssetTransactionFromPortfolioIdAndAssetId: PortfolioAssetsByAssetTransactionFromPortfolioIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByAssetTransactionToPortfolioIdAndAssetId: PortfolioAssetsByAssetTransactionToPortfolioIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByDistributionPortfolioIdAndAssetId: PortfolioAssetsByDistributionPortfolioIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByPortfolioMovementFromIdAndAssetId: PortfolioAssetsByPortfolioMovementFromIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByPortfolioMovementToIdAndAssetId: PortfolioAssetsByPortfolioMovementToIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByStoOfferingPortfolioIdAndOfferingAssetId: PortfolioAssetsByStoOfferingPortfolioIdAndOfferingAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByStoRaisingPortfolioIdAndOfferingAssetId: PortfolioAssetsByStoRaisingPortfolioIdAndOfferingAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetTransactionFromPortfolioIdAndCreatedBlockId: PortfolioBlocksByAssetTransactionFromPortfolioIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetTransactionFromPortfolioIdAndUpdatedBlockId: PortfolioBlocksByAssetTransactionFromPortfolioIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetTransactionToPortfolioIdAndCreatedBlockId: PortfolioBlocksByAssetTransactionToPortfolioIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetTransactionToPortfolioIdAndUpdatedBlockId: PortfolioBlocksByAssetTransactionToPortfolioIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByDistributionPortfolioIdAndCreatedBlockId: PortfolioBlocksByDistributionPortfolioIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByDistributionPortfolioIdAndUpdatedBlockId: PortfolioBlocksByDistributionPortfolioIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByLegFromIdAndCreatedBlockId: PortfolioBlocksByLegFromIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByLegFromIdAndUpdatedBlockId: PortfolioBlocksByLegFromIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByLegToIdAndCreatedBlockId: PortfolioBlocksByLegToIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByLegToIdAndUpdatedBlockId: PortfolioBlocksByLegToIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByPortfolioMovementFromIdAndCreatedBlockId: PortfolioBlocksByPortfolioMovementFromIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByPortfolioMovementFromIdAndUpdatedBlockId: PortfolioBlocksByPortfolioMovementFromIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByPortfolioMovementToIdAndCreatedBlockId: PortfolioBlocksByPortfolioMovementToIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByPortfolioMovementToIdAndUpdatedBlockId: PortfolioBlocksByPortfolioMovementToIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByStoOfferingPortfolioIdAndCreatedBlockId: PortfolioBlocksByStoOfferingPortfolioIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByStoOfferingPortfolioIdAndUpdatedBlockId: PortfolioBlocksByStoOfferingPortfolioIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByStoRaisingPortfolioIdAndCreatedBlockId: PortfolioBlocksByStoRaisingPortfolioIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByStoRaisingPortfolioIdAndUpdatedBlockId: PortfolioBlocksByStoRaisingPortfolioIdAndUpdatedBlockIdManyToManyConnection;
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `Portfolio`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  /** Reads a single `Identity` that is related to this `Portfolio`. */
  custodian?: Maybe<Identity>;
  custodianId?: Maybe<Scalars['String']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributions: DistributionsConnection;
  eventIdx: Scalars['Int']['output'];
  id: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByDistributionPortfolioIdAndIdentityId: PortfolioIdentitiesByDistributionPortfolioIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByStoOfferingPortfolioIdAndCreatorId: PortfolioIdentitiesByStoOfferingPortfolioIdAndCreatorIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByStoRaisingPortfolioIdAndCreatorId: PortfolioIdentitiesByStoRaisingPortfolioIdAndCreatorIdManyToManyConnection;
  /** Reads a single `Identity` that is related to this `Portfolio`. */
  identity?: Maybe<Identity>;
  identityId: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `Instruction`. */
  instructionsByLegFromIdAndInstructionId: PortfolioInstructionsByLegFromIdAndInstructionIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Instruction`. */
  instructionsByLegToIdAndInstructionId: PortfolioInstructionsByLegToIdAndInstructionIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByFromId: LegsConnection;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByToId: LegsConnection;
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  number: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByFromId: PortfolioMovementsConnection;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByToId: PortfolioMovementsConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByAssetTransactionFromPortfolioIdAndToPortfolioId: PortfolioPortfoliosByAssetTransactionFromPortfolioIdAndToPortfolioIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByAssetTransactionToPortfolioIdAndFromPortfolioId: PortfolioPortfoliosByAssetTransactionToPortfolioIdAndFromPortfolioIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByLegFromIdAndToId: PortfolioPortfoliosByLegFromIdAndToIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByLegToIdAndFromId: PortfolioPortfoliosByLegToIdAndFromIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByPortfolioMovementFromIdAndToId: PortfolioPortfoliosByPortfolioMovementFromIdAndToIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByPortfolioMovementToIdAndFromId: PortfolioPortfoliosByPortfolioMovementToIdAndFromIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByStoOfferingPortfolioIdAndRaisingPortfolioId: PortfolioPortfoliosByStoOfferingPortfolioIdAndRaisingPortfolioIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByStoRaisingPortfolioIdAndOfferingPortfolioId: PortfolioPortfoliosByStoRaisingPortfolioIdAndOfferingPortfolioIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Settlement`. */
  settlementsByLegFromIdAndSettlementId: PortfolioSettlementsByLegFromIdAndSettlementIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Settlement`. */
  settlementsByLegToIdAndSettlementId: PortfolioSettlementsByLegToIdAndSettlementIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByOfferingPortfolioId: StosConnection;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByRaisingPortfolioId: StosConnection;
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `Portfolio`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `Venue`. */
  venuesByStoOfferingPortfolioIdAndVenueId: PortfolioVenuesByStoOfferingPortfolioIdAndVenueIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Venue`. */
  venuesByStoRaisingPortfolioIdAndVenueId: PortfolioVenuesByStoRaisingPortfolioIdAndVenueIdManyToManyConnection;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioAssetTransactionsByFromPortfolioIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetTransactionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetTransactionsOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioAssetTransactionsByToPortfolioIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetTransactionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetTransactionsOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioAssetsByAssetTransactionFromPortfolioIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioAssetsByAssetTransactionToPortfolioIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioAssetsByDistributionPortfolioIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioAssetsByPortfolioMovementFromIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioAssetsByPortfolioMovementToIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioAssetsByStoOfferingPortfolioIdAndOfferingAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioAssetsByStoRaisingPortfolioIdAndOfferingAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioBlocksByAssetTransactionFromPortfolioIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioBlocksByAssetTransactionFromPortfolioIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioBlocksByAssetTransactionToPortfolioIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioBlocksByAssetTransactionToPortfolioIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioBlocksByDistributionPortfolioIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioBlocksByDistributionPortfolioIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioBlocksByLegFromIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioBlocksByLegFromIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioBlocksByLegToIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioBlocksByLegToIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioBlocksByPortfolioMovementFromIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioBlocksByPortfolioMovementFromIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioBlocksByPortfolioMovementToIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioBlocksByPortfolioMovementToIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioBlocksByStoOfferingPortfolioIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioBlocksByStoOfferingPortfolioIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioBlocksByStoRaisingPortfolioIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioBlocksByStoRaisingPortfolioIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioDistributionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<DistributionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DistributionsOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioIdentitiesByDistributionPortfolioIdAndIdentityIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioIdentitiesByStoOfferingPortfolioIdAndCreatorIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioIdentitiesByStoRaisingPortfolioIdAndCreatorIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioInstructionsByLegFromIdAndInstructionIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<InstructionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InstructionsOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioInstructionsByLegToIdAndInstructionIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<InstructionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InstructionsOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioLegsByFromIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<LegFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LegsOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioLegsByToIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<LegFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LegsOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioPortfolioMovementsByFromIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioMovementFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfolioMovementsOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioPortfolioMovementsByToIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioMovementFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfolioMovementsOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioPortfoliosByAssetTransactionFromPortfolioIdAndToPortfolioIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioPortfoliosByAssetTransactionToPortfolioIdAndFromPortfolioIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioPortfoliosByLegFromIdAndToIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioPortfoliosByLegToIdAndFromIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioPortfoliosByPortfolioMovementFromIdAndToIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioPortfoliosByPortfolioMovementToIdAndFromIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioPortfoliosByStoOfferingPortfolioIdAndRaisingPortfolioIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioPortfoliosByStoRaisingPortfolioIdAndOfferingPortfolioIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioSettlementsByLegFromIdAndSettlementIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<SettlementFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SettlementsOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioSettlementsByLegToIdAndSettlementIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<SettlementFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SettlementsOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioStosByOfferingPortfolioIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StoFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StosOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioStosByRaisingPortfolioIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StoFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StosOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioVenuesByStoOfferingPortfolioIdAndVenueIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<VenueFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VenuesOrderBy>>;
};

/**
 * Represents a grouping of Assets held by an Identity. Particular accounts maybe authorized only over certain portfolios
 *
 * Note: identities will always have a default Portfolio (id = 0)
 */
export type PortfolioVenuesByStoRaisingPortfolioIdAndVenueIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<VenueFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VenuesOrderBy>>;
};

export type PortfolioAggregates = {
  __typename?: 'PortfolioAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A connection to a list of `Asset` values, with data from `AssetTransaction`. */
export type PortfolioAssetsByAssetTransactionFromPortfolioIdAndAssetIdManyToManyConnection = {
  __typename?: 'PortfolioAssetsByAssetTransactionFromPortfolioIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `AssetTransaction`, and the cursor to aid in pagination. */
  edges: Array<PortfolioAssetsByAssetTransactionFromPortfolioIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `AssetTransaction`. */
export type PortfolioAssetsByAssetTransactionFromPortfolioIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `AssetTransaction`. */
export type PortfolioAssetsByAssetTransactionFromPortfolioIdAndAssetIdManyToManyEdge = {
  __typename?: 'PortfolioAssetsByAssetTransactionFromPortfolioIdAndAssetIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AssetTransaction`. */
  assetTransactions: AssetTransactionsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
};

/** A `Asset` edge in the connection, with data from `AssetTransaction`. */
export type PortfolioAssetsByAssetTransactionFromPortfolioIdAndAssetIdManyToManyEdgeAssetTransactionsArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AssetTransactionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AssetTransactionsOrderBy>>;
  };

/** A connection to a list of `Asset` values, with data from `AssetTransaction`. */
export type PortfolioAssetsByAssetTransactionToPortfolioIdAndAssetIdManyToManyConnection = {
  __typename?: 'PortfolioAssetsByAssetTransactionToPortfolioIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `AssetTransaction`, and the cursor to aid in pagination. */
  edges: Array<PortfolioAssetsByAssetTransactionToPortfolioIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `AssetTransaction`. */
export type PortfolioAssetsByAssetTransactionToPortfolioIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `AssetTransaction`. */
export type PortfolioAssetsByAssetTransactionToPortfolioIdAndAssetIdManyToManyEdge = {
  __typename?: 'PortfolioAssetsByAssetTransactionToPortfolioIdAndAssetIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AssetTransaction`. */
  assetTransactions: AssetTransactionsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
};

/** A `Asset` edge in the connection, with data from `AssetTransaction`. */
export type PortfolioAssetsByAssetTransactionToPortfolioIdAndAssetIdManyToManyEdgeAssetTransactionsArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AssetTransactionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AssetTransactionsOrderBy>>;
  };

/** A connection to a list of `Asset` values, with data from `Distribution`. */
export type PortfolioAssetsByDistributionPortfolioIdAndAssetIdManyToManyConnection = {
  __typename?: 'PortfolioAssetsByDistributionPortfolioIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<PortfolioAssetsByDistributionPortfolioIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `Distribution`. */
export type PortfolioAssetsByDistributionPortfolioIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `Distribution`. */
export type PortfolioAssetsByDistributionPortfolioIdAndAssetIdManyToManyEdge = {
  __typename?: 'PortfolioAssetsByDistributionPortfolioIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributions: DistributionsConnection;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
};

/** A `Asset` edge in the connection, with data from `Distribution`. */
export type PortfolioAssetsByDistributionPortfolioIdAndAssetIdManyToManyEdgeDistributionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<DistributionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DistributionsOrderBy>>;
};

/** A connection to a list of `Asset` values, with data from `PortfolioMovement`. */
export type PortfolioAssetsByPortfolioMovementFromIdAndAssetIdManyToManyConnection = {
  __typename?: 'PortfolioAssetsByPortfolioMovementFromIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<PortfolioAssetsByPortfolioMovementFromIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `PortfolioMovement`. */
export type PortfolioAssetsByPortfolioMovementFromIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `PortfolioMovement`. */
export type PortfolioAssetsByPortfolioMovementFromIdAndAssetIdManyToManyEdge = {
  __typename?: 'PortfolioAssetsByPortfolioMovementFromIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovements: PortfolioMovementsConnection;
};

/** A `Asset` edge in the connection, with data from `PortfolioMovement`. */
export type PortfolioAssetsByPortfolioMovementFromIdAndAssetIdManyToManyEdgePortfolioMovementsArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<PortfolioMovementFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<PortfolioMovementsOrderBy>>;
  };

/** A connection to a list of `Asset` values, with data from `PortfolioMovement`. */
export type PortfolioAssetsByPortfolioMovementToIdAndAssetIdManyToManyConnection = {
  __typename?: 'PortfolioAssetsByPortfolioMovementToIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<PortfolioAssetsByPortfolioMovementToIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `PortfolioMovement`. */
export type PortfolioAssetsByPortfolioMovementToIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `PortfolioMovement`. */
export type PortfolioAssetsByPortfolioMovementToIdAndAssetIdManyToManyEdge = {
  __typename?: 'PortfolioAssetsByPortfolioMovementToIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovements: PortfolioMovementsConnection;
};

/** A `Asset` edge in the connection, with data from `PortfolioMovement`. */
export type PortfolioAssetsByPortfolioMovementToIdAndAssetIdManyToManyEdgePortfolioMovementsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioMovementFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfolioMovementsOrderBy>>;
};

/** A connection to a list of `Asset` values, with data from `Sto`. */
export type PortfolioAssetsByStoOfferingPortfolioIdAndOfferingAssetIdManyToManyConnection = {
  __typename?: 'PortfolioAssetsByStoOfferingPortfolioIdAndOfferingAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<PortfolioAssetsByStoOfferingPortfolioIdAndOfferingAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `Sto`. */
export type PortfolioAssetsByStoOfferingPortfolioIdAndOfferingAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `Sto`. */
export type PortfolioAssetsByStoOfferingPortfolioIdAndOfferingAssetIdManyToManyEdge = {
  __typename?: 'PortfolioAssetsByStoOfferingPortfolioIdAndOfferingAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByOfferingAssetId: StosConnection;
};

/** A `Asset` edge in the connection, with data from `Sto`. */
export type PortfolioAssetsByStoOfferingPortfolioIdAndOfferingAssetIdManyToManyEdgeStosByOfferingAssetIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StoFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StosOrderBy>>;
  };

/** A connection to a list of `Asset` values, with data from `Sto`. */
export type PortfolioAssetsByStoRaisingPortfolioIdAndOfferingAssetIdManyToManyConnection = {
  __typename?: 'PortfolioAssetsByStoRaisingPortfolioIdAndOfferingAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<PortfolioAssetsByStoRaisingPortfolioIdAndOfferingAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `Sto`. */
export type PortfolioAssetsByStoRaisingPortfolioIdAndOfferingAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `Sto`. */
export type PortfolioAssetsByStoRaisingPortfolioIdAndOfferingAssetIdManyToManyEdge = {
  __typename?: 'PortfolioAssetsByStoRaisingPortfolioIdAndOfferingAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByOfferingAssetId: StosConnection;
};

/** A `Asset` edge in the connection, with data from `Sto`. */
export type PortfolioAssetsByStoRaisingPortfolioIdAndOfferingAssetIdManyToManyEdgeStosByOfferingAssetIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StoFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StosOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `AssetTransaction`. */
export type PortfolioBlocksByAssetTransactionFromPortfolioIdAndCreatedBlockIdManyToManyConnection =
  {
    __typename?: 'PortfolioBlocksByAssetTransactionFromPortfolioIdAndCreatedBlockIdManyToManyConnection';
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<BlockAggregates>;
    /** A list of edges which contains the `Block`, info from the `AssetTransaction`, and the cursor to aid in pagination. */
    edges: Array<PortfolioBlocksByAssetTransactionFromPortfolioIdAndCreatedBlockIdManyToManyEdge>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<BlockAggregates>>;
    /** A list of `Block` objects. */
    nodes: Array<Maybe<Block>>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Block` you could get from the connection. */
    totalCount: Scalars['Int']['output'];
  };

/** A connection to a list of `Block` values, with data from `AssetTransaction`. */
export type PortfolioBlocksByAssetTransactionFromPortfolioIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AssetTransaction`. */
export type PortfolioBlocksByAssetTransactionFromPortfolioIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'PortfolioBlocksByAssetTransactionFromPortfolioIdAndCreatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AssetTransaction`. */
  assetTransactionsByCreatedBlockId: AssetTransactionsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `AssetTransaction`. */
export type PortfolioBlocksByAssetTransactionFromPortfolioIdAndCreatedBlockIdManyToManyEdgeAssetTransactionsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AssetTransactionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AssetTransactionsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `AssetTransaction`. */
export type PortfolioBlocksByAssetTransactionFromPortfolioIdAndUpdatedBlockIdManyToManyConnection =
  {
    __typename?: 'PortfolioBlocksByAssetTransactionFromPortfolioIdAndUpdatedBlockIdManyToManyConnection';
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<BlockAggregates>;
    /** A list of edges which contains the `Block`, info from the `AssetTransaction`, and the cursor to aid in pagination. */
    edges: Array<PortfolioBlocksByAssetTransactionFromPortfolioIdAndUpdatedBlockIdManyToManyEdge>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<BlockAggregates>>;
    /** A list of `Block` objects. */
    nodes: Array<Maybe<Block>>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Block` you could get from the connection. */
    totalCount: Scalars['Int']['output'];
  };

/** A connection to a list of `Block` values, with data from `AssetTransaction`. */
export type PortfolioBlocksByAssetTransactionFromPortfolioIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AssetTransaction`. */
export type PortfolioBlocksByAssetTransactionFromPortfolioIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'PortfolioBlocksByAssetTransactionFromPortfolioIdAndUpdatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AssetTransaction`. */
  assetTransactionsByUpdatedBlockId: AssetTransactionsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `AssetTransaction`. */
export type PortfolioBlocksByAssetTransactionFromPortfolioIdAndUpdatedBlockIdManyToManyEdgeAssetTransactionsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AssetTransactionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AssetTransactionsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `AssetTransaction`. */
export type PortfolioBlocksByAssetTransactionToPortfolioIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'PortfolioBlocksByAssetTransactionToPortfolioIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `AssetTransaction`, and the cursor to aid in pagination. */
  edges: Array<PortfolioBlocksByAssetTransactionToPortfolioIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `AssetTransaction`. */
export type PortfolioBlocksByAssetTransactionToPortfolioIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AssetTransaction`. */
export type PortfolioBlocksByAssetTransactionToPortfolioIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'PortfolioBlocksByAssetTransactionToPortfolioIdAndCreatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AssetTransaction`. */
  assetTransactionsByCreatedBlockId: AssetTransactionsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `AssetTransaction`. */
export type PortfolioBlocksByAssetTransactionToPortfolioIdAndCreatedBlockIdManyToManyEdgeAssetTransactionsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AssetTransactionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AssetTransactionsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `AssetTransaction`. */
export type PortfolioBlocksByAssetTransactionToPortfolioIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'PortfolioBlocksByAssetTransactionToPortfolioIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `AssetTransaction`, and the cursor to aid in pagination. */
  edges: Array<PortfolioBlocksByAssetTransactionToPortfolioIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `AssetTransaction`. */
export type PortfolioBlocksByAssetTransactionToPortfolioIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AssetTransaction`. */
export type PortfolioBlocksByAssetTransactionToPortfolioIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'PortfolioBlocksByAssetTransactionToPortfolioIdAndUpdatedBlockIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AssetTransaction`. */
  assetTransactionsByUpdatedBlockId: AssetTransactionsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `AssetTransaction`. */
export type PortfolioBlocksByAssetTransactionToPortfolioIdAndUpdatedBlockIdManyToManyEdgeAssetTransactionsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AssetTransactionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AssetTransactionsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Distribution`. */
export type PortfolioBlocksByDistributionPortfolioIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'PortfolioBlocksByDistributionPortfolioIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<PortfolioBlocksByDistributionPortfolioIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Distribution`. */
export type PortfolioBlocksByDistributionPortfolioIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Distribution`. */
export type PortfolioBlocksByDistributionPortfolioIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'PortfolioBlocksByDistributionPortfolioIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributionsByCreatedBlockId: DistributionsConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Distribution`. */
export type PortfolioBlocksByDistributionPortfolioIdAndCreatedBlockIdManyToManyEdgeDistributionsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<DistributionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<DistributionsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Distribution`. */
export type PortfolioBlocksByDistributionPortfolioIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'PortfolioBlocksByDistributionPortfolioIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<PortfolioBlocksByDistributionPortfolioIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Distribution`. */
export type PortfolioBlocksByDistributionPortfolioIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Distribution`. */
export type PortfolioBlocksByDistributionPortfolioIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'PortfolioBlocksByDistributionPortfolioIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributionsByUpdatedBlockId: DistributionsConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Distribution`. */
export type PortfolioBlocksByDistributionPortfolioIdAndUpdatedBlockIdManyToManyEdgeDistributionsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<DistributionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<DistributionsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Leg`. */
export type PortfolioBlocksByLegFromIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'PortfolioBlocksByLegFromIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<PortfolioBlocksByLegFromIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Leg`. */
export type PortfolioBlocksByLegFromIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs = {
  groupBy: Array<BlocksGroupBy>;
  having?: InputMaybe<BlocksHavingInput>;
};

/** A `Block` edge in the connection, with data from `Leg`. */
export type PortfolioBlocksByLegFromIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'PortfolioBlocksByLegFromIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByCreatedBlockId: LegsConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Leg`. */
export type PortfolioBlocksByLegFromIdAndCreatedBlockIdManyToManyEdgeLegsByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<LegFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LegsOrderBy>>;
};

/** A connection to a list of `Block` values, with data from `Leg`. */
export type PortfolioBlocksByLegFromIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'PortfolioBlocksByLegFromIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<PortfolioBlocksByLegFromIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Leg`. */
export type PortfolioBlocksByLegFromIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs = {
  groupBy: Array<BlocksGroupBy>;
  having?: InputMaybe<BlocksHavingInput>;
};

/** A `Block` edge in the connection, with data from `Leg`. */
export type PortfolioBlocksByLegFromIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'PortfolioBlocksByLegFromIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByUpdatedBlockId: LegsConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Leg`. */
export type PortfolioBlocksByLegFromIdAndUpdatedBlockIdManyToManyEdgeLegsByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<LegFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LegsOrderBy>>;
};

/** A connection to a list of `Block` values, with data from `Leg`. */
export type PortfolioBlocksByLegToIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'PortfolioBlocksByLegToIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<PortfolioBlocksByLegToIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Leg`. */
export type PortfolioBlocksByLegToIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs = {
  groupBy: Array<BlocksGroupBy>;
  having?: InputMaybe<BlocksHavingInput>;
};

/** A `Block` edge in the connection, with data from `Leg`. */
export type PortfolioBlocksByLegToIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'PortfolioBlocksByLegToIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByCreatedBlockId: LegsConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Leg`. */
export type PortfolioBlocksByLegToIdAndCreatedBlockIdManyToManyEdgeLegsByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<LegFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LegsOrderBy>>;
};

/** A connection to a list of `Block` values, with data from `Leg`. */
export type PortfolioBlocksByLegToIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'PortfolioBlocksByLegToIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<PortfolioBlocksByLegToIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Leg`. */
export type PortfolioBlocksByLegToIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs = {
  groupBy: Array<BlocksGroupBy>;
  having?: InputMaybe<BlocksHavingInput>;
};

/** A `Block` edge in the connection, with data from `Leg`. */
export type PortfolioBlocksByLegToIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'PortfolioBlocksByLegToIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByUpdatedBlockId: LegsConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Leg`. */
export type PortfolioBlocksByLegToIdAndUpdatedBlockIdManyToManyEdgeLegsByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<LegFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LegsOrderBy>>;
};

/** A connection to a list of `Block` values, with data from `PortfolioMovement`. */
export type PortfolioBlocksByPortfolioMovementFromIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'PortfolioBlocksByPortfolioMovementFromIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<PortfolioBlocksByPortfolioMovementFromIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `PortfolioMovement`. */
export type PortfolioBlocksByPortfolioMovementFromIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `PortfolioMovement`. */
export type PortfolioBlocksByPortfolioMovementFromIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'PortfolioBlocksByPortfolioMovementFromIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByCreatedBlockId: PortfolioMovementsConnection;
};

/** A `Block` edge in the connection, with data from `PortfolioMovement`. */
export type PortfolioBlocksByPortfolioMovementFromIdAndCreatedBlockIdManyToManyEdgePortfolioMovementsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<PortfolioMovementFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<PortfolioMovementsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `PortfolioMovement`. */
export type PortfolioBlocksByPortfolioMovementFromIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'PortfolioBlocksByPortfolioMovementFromIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<PortfolioBlocksByPortfolioMovementFromIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `PortfolioMovement`. */
export type PortfolioBlocksByPortfolioMovementFromIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `PortfolioMovement`. */
export type PortfolioBlocksByPortfolioMovementFromIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'PortfolioBlocksByPortfolioMovementFromIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByUpdatedBlockId: PortfolioMovementsConnection;
};

/** A `Block` edge in the connection, with data from `PortfolioMovement`. */
export type PortfolioBlocksByPortfolioMovementFromIdAndUpdatedBlockIdManyToManyEdgePortfolioMovementsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<PortfolioMovementFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<PortfolioMovementsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `PortfolioMovement`. */
export type PortfolioBlocksByPortfolioMovementToIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'PortfolioBlocksByPortfolioMovementToIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<PortfolioBlocksByPortfolioMovementToIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `PortfolioMovement`. */
export type PortfolioBlocksByPortfolioMovementToIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `PortfolioMovement`. */
export type PortfolioBlocksByPortfolioMovementToIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'PortfolioBlocksByPortfolioMovementToIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByCreatedBlockId: PortfolioMovementsConnection;
};

/** A `Block` edge in the connection, with data from `PortfolioMovement`. */
export type PortfolioBlocksByPortfolioMovementToIdAndCreatedBlockIdManyToManyEdgePortfolioMovementsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<PortfolioMovementFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<PortfolioMovementsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `PortfolioMovement`. */
export type PortfolioBlocksByPortfolioMovementToIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'PortfolioBlocksByPortfolioMovementToIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<PortfolioBlocksByPortfolioMovementToIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `PortfolioMovement`. */
export type PortfolioBlocksByPortfolioMovementToIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `PortfolioMovement`. */
export type PortfolioBlocksByPortfolioMovementToIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'PortfolioBlocksByPortfolioMovementToIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByUpdatedBlockId: PortfolioMovementsConnection;
};

/** A `Block` edge in the connection, with data from `PortfolioMovement`. */
export type PortfolioBlocksByPortfolioMovementToIdAndUpdatedBlockIdManyToManyEdgePortfolioMovementsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<PortfolioMovementFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<PortfolioMovementsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Sto`. */
export type PortfolioBlocksByStoOfferingPortfolioIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'PortfolioBlocksByStoOfferingPortfolioIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<PortfolioBlocksByStoOfferingPortfolioIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Sto`. */
export type PortfolioBlocksByStoOfferingPortfolioIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Sto`. */
export type PortfolioBlocksByStoOfferingPortfolioIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'PortfolioBlocksByStoOfferingPortfolioIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByCreatedBlockId: StosConnection;
};

/** A `Block` edge in the connection, with data from `Sto`. */
export type PortfolioBlocksByStoOfferingPortfolioIdAndCreatedBlockIdManyToManyEdgeStosByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StoFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StosOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Sto`. */
export type PortfolioBlocksByStoOfferingPortfolioIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'PortfolioBlocksByStoOfferingPortfolioIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<PortfolioBlocksByStoOfferingPortfolioIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Sto`. */
export type PortfolioBlocksByStoOfferingPortfolioIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Sto`. */
export type PortfolioBlocksByStoOfferingPortfolioIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'PortfolioBlocksByStoOfferingPortfolioIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByUpdatedBlockId: StosConnection;
};

/** A `Block` edge in the connection, with data from `Sto`. */
export type PortfolioBlocksByStoOfferingPortfolioIdAndUpdatedBlockIdManyToManyEdgeStosByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StoFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StosOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Sto`. */
export type PortfolioBlocksByStoRaisingPortfolioIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'PortfolioBlocksByStoRaisingPortfolioIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<PortfolioBlocksByStoRaisingPortfolioIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Sto`. */
export type PortfolioBlocksByStoRaisingPortfolioIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Sto`. */
export type PortfolioBlocksByStoRaisingPortfolioIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'PortfolioBlocksByStoRaisingPortfolioIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByCreatedBlockId: StosConnection;
};

/** A `Block` edge in the connection, with data from `Sto`. */
export type PortfolioBlocksByStoRaisingPortfolioIdAndCreatedBlockIdManyToManyEdgeStosByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StoFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StosOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Sto`. */
export type PortfolioBlocksByStoRaisingPortfolioIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'PortfolioBlocksByStoRaisingPortfolioIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<PortfolioBlocksByStoRaisingPortfolioIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Sto`. */
export type PortfolioBlocksByStoRaisingPortfolioIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Sto`. */
export type PortfolioBlocksByStoRaisingPortfolioIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'PortfolioBlocksByStoRaisingPortfolioIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByUpdatedBlockId: StosConnection;
};

/** A `Block` edge in the connection, with data from `Sto`. */
export type PortfolioBlocksByStoRaisingPortfolioIdAndUpdatedBlockIdManyToManyEdgeStosByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StoFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StosOrderBy>>;
  };

/** A filter to be used against `Portfolio` object types. All fields are combined with a logical ‘and.’ */
export type PortfolioFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PortfolioFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `custodianId` field. */
  custodianId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `eventIdx` field. */
  eventIdx?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `identityId` field. */
  identityId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<PortfolioFilter>;
  /** Filter by the object’s `number` field. */
  number?: InputMaybe<IntFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PortfolioFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
};

/** A connection to a list of `Identity` values, with data from `Distribution`. */
export type PortfolioIdentitiesByDistributionPortfolioIdAndIdentityIdManyToManyConnection = {
  __typename?: 'PortfolioIdentitiesByDistributionPortfolioIdAndIdentityIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<PortfolioIdentitiesByDistributionPortfolioIdAndIdentityIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `Distribution`. */
export type PortfolioIdentitiesByDistributionPortfolioIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Distribution`. */
export type PortfolioIdentitiesByDistributionPortfolioIdAndIdentityIdManyToManyEdge = {
  __typename?: 'PortfolioIdentitiesByDistributionPortfolioIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributions: DistributionsConnection;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
};

/** A `Identity` edge in the connection, with data from `Distribution`. */
export type PortfolioIdentitiesByDistributionPortfolioIdAndIdentityIdManyToManyEdgeDistributionsArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<DistributionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<DistributionsOrderBy>>;
  };

/** A connection to a list of `Identity` values, with data from `Sto`. */
export type PortfolioIdentitiesByStoOfferingPortfolioIdAndCreatorIdManyToManyConnection = {
  __typename?: 'PortfolioIdentitiesByStoOfferingPortfolioIdAndCreatorIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<PortfolioIdentitiesByStoOfferingPortfolioIdAndCreatorIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `Sto`. */
export type PortfolioIdentitiesByStoOfferingPortfolioIdAndCreatorIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Sto`. */
export type PortfolioIdentitiesByStoOfferingPortfolioIdAndCreatorIdManyToManyEdge = {
  __typename?: 'PortfolioIdentitiesByStoOfferingPortfolioIdAndCreatorIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByCreatorId: StosConnection;
};

/** A `Identity` edge in the connection, with data from `Sto`. */
export type PortfolioIdentitiesByStoOfferingPortfolioIdAndCreatorIdManyToManyEdgeStosByCreatorIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StoFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StosOrderBy>>;
  };

/** A connection to a list of `Identity` values, with data from `Sto`. */
export type PortfolioIdentitiesByStoRaisingPortfolioIdAndCreatorIdManyToManyConnection = {
  __typename?: 'PortfolioIdentitiesByStoRaisingPortfolioIdAndCreatorIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<PortfolioIdentitiesByStoRaisingPortfolioIdAndCreatorIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `Sto`. */
export type PortfolioIdentitiesByStoRaisingPortfolioIdAndCreatorIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Sto`. */
export type PortfolioIdentitiesByStoRaisingPortfolioIdAndCreatorIdManyToManyEdge = {
  __typename?: 'PortfolioIdentitiesByStoRaisingPortfolioIdAndCreatorIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByCreatorId: StosConnection;
};

/** A `Identity` edge in the connection, with data from `Sto`. */
export type PortfolioIdentitiesByStoRaisingPortfolioIdAndCreatorIdManyToManyEdgeStosByCreatorIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StoFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StosOrderBy>>;
  };

/** A connection to a list of `Instruction` values, with data from `Leg`. */
export type PortfolioInstructionsByLegFromIdAndInstructionIdManyToManyConnection = {
  __typename?: 'PortfolioInstructionsByLegFromIdAndInstructionIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<InstructionAggregates>;
  /** A list of edges which contains the `Instruction`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<PortfolioInstructionsByLegFromIdAndInstructionIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<InstructionAggregates>>;
  /** A list of `Instruction` objects. */
  nodes: Array<Maybe<Instruction>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Instruction` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Instruction` values, with data from `Leg`. */
export type PortfolioInstructionsByLegFromIdAndInstructionIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<InstructionsGroupBy>;
    having?: InputMaybe<InstructionsHavingInput>;
  };

/** A `Instruction` edge in the connection, with data from `Leg`. */
export type PortfolioInstructionsByLegFromIdAndInstructionIdManyToManyEdge = {
  __typename?: 'PortfolioInstructionsByLegFromIdAndInstructionIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Leg`. */
  legs: LegsConnection;
  /** The `Instruction` at the end of the edge. */
  node?: Maybe<Instruction>;
};

/** A `Instruction` edge in the connection, with data from `Leg`. */
export type PortfolioInstructionsByLegFromIdAndInstructionIdManyToManyEdgeLegsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<LegFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LegsOrderBy>>;
};

/** A connection to a list of `Instruction` values, with data from `Leg`. */
export type PortfolioInstructionsByLegToIdAndInstructionIdManyToManyConnection = {
  __typename?: 'PortfolioInstructionsByLegToIdAndInstructionIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<InstructionAggregates>;
  /** A list of edges which contains the `Instruction`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<PortfolioInstructionsByLegToIdAndInstructionIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<InstructionAggregates>>;
  /** A list of `Instruction` objects. */
  nodes: Array<Maybe<Instruction>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Instruction` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Instruction` values, with data from `Leg`. */
export type PortfolioInstructionsByLegToIdAndInstructionIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<InstructionsGroupBy>;
    having?: InputMaybe<InstructionsHavingInput>;
  };

/** A `Instruction` edge in the connection, with data from `Leg`. */
export type PortfolioInstructionsByLegToIdAndInstructionIdManyToManyEdge = {
  __typename?: 'PortfolioInstructionsByLegToIdAndInstructionIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Leg`. */
  legs: LegsConnection;
  /** The `Instruction` at the end of the edge. */
  node?: Maybe<Instruction>;
};

/** A `Instruction` edge in the connection, with data from `Leg`. */
export type PortfolioInstructionsByLegToIdAndInstructionIdManyToManyEdgeLegsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<LegFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LegsOrderBy>>;
};

/**
 * Represents a transfer of Assets between a single identities portfolios.
 *
 * Note: transfers between identities are known as `Settlements`
 */
export type PortfolioMovement = Node & {
  __typename?: 'PortfolioMovement';
  address: Scalars['String']['output'];
  amount: Scalars['BigFloat']['output'];
  /** Reads a single `Asset` that is related to this `PortfolioMovement`. */
  asset?: Maybe<Asset>;
  assetId: Scalars['String']['output'];
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `PortfolioMovement`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  /** Reads a single `Portfolio` that is related to this `PortfolioMovement`. */
  from?: Maybe<Portfolio>;
  fromId: Scalars['String']['output'];
  id: Scalars['String']['output'];
  memo?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Portfolio` that is related to this `PortfolioMovement`. */
  to?: Maybe<Portfolio>;
  toId: Scalars['String']['output'];
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `PortfolioMovement`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
};

export type PortfolioMovementAggregates = {
  __typename?: 'PortfolioMovementAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A filter to be used against `PortfolioMovement` object types. All fields are combined with a logical ‘and.’ */
export type PortfolioMovementFilter = {
  /** Filter by the object’s `address` field. */
  address?: InputMaybe<StringFilter>;
  /** Filter by the object’s `amount` field. */
  amount?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PortfolioMovementFilter>>;
  /** Filter by the object’s `assetId` field. */
  assetId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `fromId` field. */
  fromId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `memo` field. */
  memo?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<PortfolioMovementFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PortfolioMovementFilter>>;
  /** Filter by the object’s `toId` field. */
  toId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
};

/** A connection to a list of `PortfolioMovement` values. */
export type PortfolioMovementsConnection = {
  __typename?: 'PortfolioMovementsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioMovementAggregates>;
  /** A list of edges which contains the `PortfolioMovement` and cursor to aid in pagination. */
  edges: Array<PortfolioMovementsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioMovementAggregates>>;
  /** A list of `PortfolioMovement` objects. */
  nodes: Array<Maybe<PortfolioMovement>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PortfolioMovement` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `PortfolioMovement` values. */
export type PortfolioMovementsConnectionGroupedAggregatesArgs = {
  groupBy: Array<PortfolioMovementsGroupBy>;
  having?: InputMaybe<PortfolioMovementsHavingInput>;
};

/** A `PortfolioMovement` edge in the connection. */
export type PortfolioMovementsEdge = {
  __typename?: 'PortfolioMovementsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `PortfolioMovement` at the end of the edge. */
  node?: Maybe<PortfolioMovement>;
};

/** Grouping methods for `PortfolioMovement` for usage during aggregation. */
export enum PortfolioMovementsGroupBy {
  Address = 'ADDRESS',
  Amount = 'AMOUNT',
  AssetId = 'ASSET_ID',
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  FromId = 'FROM_ID',
  Memo = 'MEMO',
  ToId = 'TO_ID',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
}

/** Conditions for `PortfolioMovement` aggregates. */
export type PortfolioMovementsHavingInput = {
  AND?: InputMaybe<Array<PortfolioMovementsHavingInput>>;
  OR?: InputMaybe<Array<PortfolioMovementsHavingInput>>;
};

/** Methods to use when ordering `PortfolioMovement`. */
export enum PortfolioMovementsOrderBy {
  AddressAsc = 'ADDRESS_ASC',
  AddressDesc = 'ADDRESS_DESC',
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  AssetIdAsc = 'ASSET_ID_ASC',
  AssetIdDesc = 'ASSET_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  FromIdAsc = 'FROM_ID_ASC',
  FromIdDesc = 'FROM_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MemoAsc = 'MEMO_ASC',
  MemoDesc = 'MEMO_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ToIdAsc = 'TO_ID_ASC',
  ToIdDesc = 'TO_ID_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
}

/** A connection to a list of `Portfolio` values, with data from `AssetTransaction`. */
export type PortfolioPortfoliosByAssetTransactionFromPortfolioIdAndToPortfolioIdManyToManyConnection =
  {
    __typename?: 'PortfolioPortfoliosByAssetTransactionFromPortfolioIdAndToPortfolioIdManyToManyConnection';
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<PortfolioAggregates>;
    /** A list of edges which contains the `Portfolio`, info from the `AssetTransaction`, and the cursor to aid in pagination. */
    edges: Array<PortfolioPortfoliosByAssetTransactionFromPortfolioIdAndToPortfolioIdManyToManyEdge>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
    /** A list of `Portfolio` objects. */
    nodes: Array<Maybe<Portfolio>>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Portfolio` you could get from the connection. */
    totalCount: Scalars['Int']['output'];
  };

/** A connection to a list of `Portfolio` values, with data from `AssetTransaction`. */
export type PortfolioPortfoliosByAssetTransactionFromPortfolioIdAndToPortfolioIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: InputMaybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `AssetTransaction`. */
export type PortfolioPortfoliosByAssetTransactionFromPortfolioIdAndToPortfolioIdManyToManyEdge = {
  __typename?: 'PortfolioPortfoliosByAssetTransactionFromPortfolioIdAndToPortfolioIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AssetTransaction`. */
  assetTransactionsByToPortfolioId: AssetTransactionsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
};

/** A `Portfolio` edge in the connection, with data from `AssetTransaction`. */
export type PortfolioPortfoliosByAssetTransactionFromPortfolioIdAndToPortfolioIdManyToManyEdgeAssetTransactionsByToPortfolioIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AssetTransactionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AssetTransactionsOrderBy>>;
  };

/** A connection to a list of `Portfolio` values, with data from `AssetTransaction`. */
export type PortfolioPortfoliosByAssetTransactionToPortfolioIdAndFromPortfolioIdManyToManyConnection =
  {
    __typename?: 'PortfolioPortfoliosByAssetTransactionToPortfolioIdAndFromPortfolioIdManyToManyConnection';
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<PortfolioAggregates>;
    /** A list of edges which contains the `Portfolio`, info from the `AssetTransaction`, and the cursor to aid in pagination. */
    edges: Array<PortfolioPortfoliosByAssetTransactionToPortfolioIdAndFromPortfolioIdManyToManyEdge>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
    /** A list of `Portfolio` objects. */
    nodes: Array<Maybe<Portfolio>>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Portfolio` you could get from the connection. */
    totalCount: Scalars['Int']['output'];
  };

/** A connection to a list of `Portfolio` values, with data from `AssetTransaction`. */
export type PortfolioPortfoliosByAssetTransactionToPortfolioIdAndFromPortfolioIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: InputMaybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `AssetTransaction`. */
export type PortfolioPortfoliosByAssetTransactionToPortfolioIdAndFromPortfolioIdManyToManyEdge = {
  __typename?: 'PortfolioPortfoliosByAssetTransactionToPortfolioIdAndFromPortfolioIdManyToManyEdge';
  /** Reads and enables pagination through a set of `AssetTransaction`. */
  assetTransactionsByFromPortfolioId: AssetTransactionsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
};

/** A `Portfolio` edge in the connection, with data from `AssetTransaction`. */
export type PortfolioPortfoliosByAssetTransactionToPortfolioIdAndFromPortfolioIdManyToManyEdgeAssetTransactionsByFromPortfolioIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<AssetTransactionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<AssetTransactionsOrderBy>>;
  };

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type PortfolioPortfoliosByLegFromIdAndToIdManyToManyConnection = {
  __typename?: 'PortfolioPortfoliosByLegFromIdAndToIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<PortfolioPortfoliosByLegFromIdAndToIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type PortfolioPortfoliosByLegFromIdAndToIdManyToManyConnectionGroupedAggregatesArgs = {
  groupBy: Array<PortfoliosGroupBy>;
  having?: InputMaybe<PortfoliosHavingInput>;
};

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type PortfolioPortfoliosByLegFromIdAndToIdManyToManyEdge = {
  __typename?: 'PortfolioPortfoliosByLegFromIdAndToIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByToId: LegsConnection;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
};

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type PortfolioPortfoliosByLegFromIdAndToIdManyToManyEdgeLegsByToIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<LegFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LegsOrderBy>>;
};

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type PortfolioPortfoliosByLegToIdAndFromIdManyToManyConnection = {
  __typename?: 'PortfolioPortfoliosByLegToIdAndFromIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<PortfolioPortfoliosByLegToIdAndFromIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type PortfolioPortfoliosByLegToIdAndFromIdManyToManyConnectionGroupedAggregatesArgs = {
  groupBy: Array<PortfoliosGroupBy>;
  having?: InputMaybe<PortfoliosHavingInput>;
};

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type PortfolioPortfoliosByLegToIdAndFromIdManyToManyEdge = {
  __typename?: 'PortfolioPortfoliosByLegToIdAndFromIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByFromId: LegsConnection;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
};

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type PortfolioPortfoliosByLegToIdAndFromIdManyToManyEdgeLegsByFromIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<LegFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LegsOrderBy>>;
};

/** A connection to a list of `Portfolio` values, with data from `PortfolioMovement`. */
export type PortfolioPortfoliosByPortfolioMovementFromIdAndToIdManyToManyConnection = {
  __typename?: 'PortfolioPortfoliosByPortfolioMovementFromIdAndToIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<PortfolioPortfoliosByPortfolioMovementFromIdAndToIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `PortfolioMovement`. */
export type PortfolioPortfoliosByPortfolioMovementFromIdAndToIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: InputMaybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `PortfolioMovement`. */
export type PortfolioPortfoliosByPortfolioMovementFromIdAndToIdManyToManyEdge = {
  __typename?: 'PortfolioPortfoliosByPortfolioMovementFromIdAndToIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByToId: PortfolioMovementsConnection;
};

/** A `Portfolio` edge in the connection, with data from `PortfolioMovement`. */
export type PortfolioPortfoliosByPortfolioMovementFromIdAndToIdManyToManyEdgePortfolioMovementsByToIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<PortfolioMovementFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<PortfolioMovementsOrderBy>>;
  };

/** A connection to a list of `Portfolio` values, with data from `PortfolioMovement`. */
export type PortfolioPortfoliosByPortfolioMovementToIdAndFromIdManyToManyConnection = {
  __typename?: 'PortfolioPortfoliosByPortfolioMovementToIdAndFromIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<PortfolioPortfoliosByPortfolioMovementToIdAndFromIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `PortfolioMovement`. */
export type PortfolioPortfoliosByPortfolioMovementToIdAndFromIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: InputMaybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `PortfolioMovement`. */
export type PortfolioPortfoliosByPortfolioMovementToIdAndFromIdManyToManyEdge = {
  __typename?: 'PortfolioPortfoliosByPortfolioMovementToIdAndFromIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByFromId: PortfolioMovementsConnection;
};

/** A `Portfolio` edge in the connection, with data from `PortfolioMovement`. */
export type PortfolioPortfoliosByPortfolioMovementToIdAndFromIdManyToManyEdgePortfolioMovementsByFromIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<PortfolioMovementFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<PortfolioMovementsOrderBy>>;
  };

/** A connection to a list of `Portfolio` values, with data from `Sto`. */
export type PortfolioPortfoliosByStoOfferingPortfolioIdAndRaisingPortfolioIdManyToManyConnection = {
  __typename?: 'PortfolioPortfoliosByStoOfferingPortfolioIdAndRaisingPortfolioIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<PortfolioPortfoliosByStoOfferingPortfolioIdAndRaisingPortfolioIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `Sto`. */
export type PortfolioPortfoliosByStoOfferingPortfolioIdAndRaisingPortfolioIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: InputMaybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `Sto`. */
export type PortfolioPortfoliosByStoOfferingPortfolioIdAndRaisingPortfolioIdManyToManyEdge = {
  __typename?: 'PortfolioPortfoliosByStoOfferingPortfolioIdAndRaisingPortfolioIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByRaisingPortfolioId: StosConnection;
};

/** A `Portfolio` edge in the connection, with data from `Sto`. */
export type PortfolioPortfoliosByStoOfferingPortfolioIdAndRaisingPortfolioIdManyToManyEdgeStosByRaisingPortfolioIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StoFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StosOrderBy>>;
  };

/** A connection to a list of `Portfolio` values, with data from `Sto`. */
export type PortfolioPortfoliosByStoRaisingPortfolioIdAndOfferingPortfolioIdManyToManyConnection = {
  __typename?: 'PortfolioPortfoliosByStoRaisingPortfolioIdAndOfferingPortfolioIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<PortfolioPortfoliosByStoRaisingPortfolioIdAndOfferingPortfolioIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `Sto`. */
export type PortfolioPortfoliosByStoRaisingPortfolioIdAndOfferingPortfolioIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: InputMaybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `Sto`. */
export type PortfolioPortfoliosByStoRaisingPortfolioIdAndOfferingPortfolioIdManyToManyEdge = {
  __typename?: 'PortfolioPortfoliosByStoRaisingPortfolioIdAndOfferingPortfolioIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByOfferingPortfolioId: StosConnection;
};

/** A `Portfolio` edge in the connection, with data from `Sto`. */
export type PortfolioPortfoliosByStoRaisingPortfolioIdAndOfferingPortfolioIdManyToManyEdgeStosByOfferingPortfolioIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StoFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StosOrderBy>>;
  };

/** A connection to a list of `Settlement` values, with data from `Leg`. */
export type PortfolioSettlementsByLegFromIdAndSettlementIdManyToManyConnection = {
  __typename?: 'PortfolioSettlementsByLegFromIdAndSettlementIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<SettlementAggregates>;
  /** A list of edges which contains the `Settlement`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<PortfolioSettlementsByLegFromIdAndSettlementIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<SettlementAggregates>>;
  /** A list of `Settlement` objects. */
  nodes: Array<Maybe<Settlement>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Settlement` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Settlement` values, with data from `Leg`. */
export type PortfolioSettlementsByLegFromIdAndSettlementIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<SettlementsGroupBy>;
    having?: InputMaybe<SettlementsHavingInput>;
  };

/** A `Settlement` edge in the connection, with data from `Leg`. */
export type PortfolioSettlementsByLegFromIdAndSettlementIdManyToManyEdge = {
  __typename?: 'PortfolioSettlementsByLegFromIdAndSettlementIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Leg`. */
  legs: LegsConnection;
  /** The `Settlement` at the end of the edge. */
  node?: Maybe<Settlement>;
};

/** A `Settlement` edge in the connection, with data from `Leg`. */
export type PortfolioSettlementsByLegFromIdAndSettlementIdManyToManyEdgeLegsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<LegFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LegsOrderBy>>;
};

/** A connection to a list of `Settlement` values, with data from `Leg`. */
export type PortfolioSettlementsByLegToIdAndSettlementIdManyToManyConnection = {
  __typename?: 'PortfolioSettlementsByLegToIdAndSettlementIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<SettlementAggregates>;
  /** A list of edges which contains the `Settlement`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<PortfolioSettlementsByLegToIdAndSettlementIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<SettlementAggregates>>;
  /** A list of `Settlement` objects. */
  nodes: Array<Maybe<Settlement>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Settlement` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Settlement` values, with data from `Leg`. */
export type PortfolioSettlementsByLegToIdAndSettlementIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<SettlementsGroupBy>;
    having?: InputMaybe<SettlementsHavingInput>;
  };

/** A `Settlement` edge in the connection, with data from `Leg`. */
export type PortfolioSettlementsByLegToIdAndSettlementIdManyToManyEdge = {
  __typename?: 'PortfolioSettlementsByLegToIdAndSettlementIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Leg`. */
  legs: LegsConnection;
  /** The `Settlement` at the end of the edge. */
  node?: Maybe<Settlement>;
};

/** A `Settlement` edge in the connection, with data from `Leg`. */
export type PortfolioSettlementsByLegToIdAndSettlementIdManyToManyEdgeLegsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<LegFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LegsOrderBy>>;
};

/** A connection to a list of `Venue` values, with data from `Sto`. */
export type PortfolioVenuesByStoOfferingPortfolioIdAndVenueIdManyToManyConnection = {
  __typename?: 'PortfolioVenuesByStoOfferingPortfolioIdAndVenueIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<VenueAggregates>;
  /** A list of edges which contains the `Venue`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<PortfolioVenuesByStoOfferingPortfolioIdAndVenueIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<VenueAggregates>>;
  /** A list of `Venue` objects. */
  nodes: Array<Maybe<Venue>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Venue` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Venue` values, with data from `Sto`. */
export type PortfolioVenuesByStoOfferingPortfolioIdAndVenueIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<VenuesGroupBy>;
    having?: InputMaybe<VenuesHavingInput>;
  };

/** A `Venue` edge in the connection, with data from `Sto`. */
export type PortfolioVenuesByStoOfferingPortfolioIdAndVenueIdManyToManyEdge = {
  __typename?: 'PortfolioVenuesByStoOfferingPortfolioIdAndVenueIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Venue` at the end of the edge. */
  node?: Maybe<Venue>;
  /** Reads and enables pagination through a set of `Sto`. */
  stos: StosConnection;
};

/** A `Venue` edge in the connection, with data from `Sto`. */
export type PortfolioVenuesByStoOfferingPortfolioIdAndVenueIdManyToManyEdgeStosArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StoFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StosOrderBy>>;
};

/** A connection to a list of `Venue` values, with data from `Sto`. */
export type PortfolioVenuesByStoRaisingPortfolioIdAndVenueIdManyToManyConnection = {
  __typename?: 'PortfolioVenuesByStoRaisingPortfolioIdAndVenueIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<VenueAggregates>;
  /** A list of edges which contains the `Venue`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<PortfolioVenuesByStoRaisingPortfolioIdAndVenueIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<VenueAggregates>>;
  /** A list of `Venue` objects. */
  nodes: Array<Maybe<Venue>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Venue` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Venue` values, with data from `Sto`. */
export type PortfolioVenuesByStoRaisingPortfolioIdAndVenueIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<VenuesGroupBy>;
    having?: InputMaybe<VenuesHavingInput>;
  };

/** A `Venue` edge in the connection, with data from `Sto`. */
export type PortfolioVenuesByStoRaisingPortfolioIdAndVenueIdManyToManyEdge = {
  __typename?: 'PortfolioVenuesByStoRaisingPortfolioIdAndVenueIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Venue` at the end of the edge. */
  node?: Maybe<Venue>;
  /** Reads and enables pagination through a set of `Sto`. */
  stos: StosConnection;
};

/** A `Venue` edge in the connection, with data from `Sto`. */
export type PortfolioVenuesByStoRaisingPortfolioIdAndVenueIdManyToManyEdgeStosArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StoFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StosOrderBy>>;
};

/** A connection to a list of `Portfolio` values. */
export type PortfoliosConnection = {
  __typename?: 'PortfoliosConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio` and cursor to aid in pagination. */
  edges: Array<PortfoliosEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values. */
export type PortfoliosConnectionGroupedAggregatesArgs = {
  groupBy: Array<PortfoliosGroupBy>;
  having?: InputMaybe<PortfoliosHavingInput>;
};

/** A `Portfolio` edge in the connection. */
export type PortfoliosEdge = {
  __typename?: 'PortfoliosEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
};

/** Grouping methods for `Portfolio` for usage during aggregation. */
export enum PortfoliosGroupBy {
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  CustodianId = 'CUSTODIAN_ID',
  DeletedAt = 'DELETED_AT',
  EventIdx = 'EVENT_IDX',
  IdentityId = 'IDENTITY_ID',
  Name = 'NAME',
  Number = 'NUMBER',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
}

/** Conditions for `Portfolio` aggregates. */
export type PortfoliosHavingInput = {
  AND?: InputMaybe<Array<PortfoliosHavingInput>>;
  OR?: InputMaybe<Array<PortfoliosHavingInput>>;
};

/** Methods to use when ordering `Portfolio`. */
export enum PortfoliosOrderBy {
  AssetTransactionsByFromPortfolioIdCountAsc = 'ASSET_TRANSACTIONS_BY_FROM_PORTFOLIO_ID_COUNT_ASC',
  AssetTransactionsByFromPortfolioIdCountDesc = 'ASSET_TRANSACTIONS_BY_FROM_PORTFOLIO_ID_COUNT_DESC',
  AssetTransactionsByToPortfolioIdCountAsc = 'ASSET_TRANSACTIONS_BY_TO_PORTFOLIO_ID_COUNT_ASC',
  AssetTransactionsByToPortfolioIdCountDesc = 'ASSET_TRANSACTIONS_BY_TO_PORTFOLIO_ID_COUNT_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  CustodianIdAsc = 'CUSTODIAN_ID_ASC',
  CustodianIdDesc = 'CUSTODIAN_ID_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  DistributionsCountAsc = 'DISTRIBUTIONS_COUNT_ASC',
  DistributionsCountDesc = 'DISTRIBUTIONS_COUNT_DESC',
  EventIdxAsc = 'EVENT_IDX_ASC',
  EventIdxDesc = 'EVENT_IDX_DESC',
  IdentityIdAsc = 'IDENTITY_ID_ASC',
  IdentityIdDesc = 'IDENTITY_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LegsByFromIdCountAsc = 'LEGS_BY_FROM_ID_COUNT_ASC',
  LegsByFromIdCountDesc = 'LEGS_BY_FROM_ID_COUNT_DESC',
  LegsByToIdCountAsc = 'LEGS_BY_TO_ID_COUNT_ASC',
  LegsByToIdCountDesc = 'LEGS_BY_TO_ID_COUNT_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  NumberAsc = 'NUMBER_ASC',
  NumberDesc = 'NUMBER_DESC',
  PortfolioMovementsByFromIdCountAsc = 'PORTFOLIO_MOVEMENTS_BY_FROM_ID_COUNT_ASC',
  PortfolioMovementsByFromIdCountDesc = 'PORTFOLIO_MOVEMENTS_BY_FROM_ID_COUNT_DESC',
  PortfolioMovementsByToIdCountAsc = 'PORTFOLIO_MOVEMENTS_BY_TO_ID_COUNT_ASC',
  PortfolioMovementsByToIdCountDesc = 'PORTFOLIO_MOVEMENTS_BY_TO_ID_COUNT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  StosByOfferingPortfolioIdCountAsc = 'STOS_BY_OFFERING_PORTFOLIO_ID_COUNT_ASC',
  StosByOfferingPortfolioIdCountDesc = 'STOS_BY_OFFERING_PORTFOLIO_ID_COUNT_DESC',
  StosByRaisingPortfolioIdCountAsc = 'STOS_BY_RAISING_PORTFOLIO_ID_COUNT_ASC',
  StosByRaisingPortfolioIdCountDesc = 'STOS_BY_RAISING_PORTFOLIO_ID_COUNT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
}

/** Represents a potential change to how the chain will operate. It will need gain sufficient "Aye" votes before having effect */
export type Proposal = Node & {
  __typename?: 'Proposal';
  balance: Scalars['BigFloat']['output'];
  /** Reads and enables pagination through a set of `Block`. */
  blocksByProposalVoteProposalIdAndCreatedBlockId: ProposalBlocksByProposalVoteProposalIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByProposalVoteProposalIdAndUpdatedBlockId: ProposalBlocksByProposalVoteProposalIdAndUpdatedBlockIdManyToManyConnection;
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `Proposal`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Identity` that is related to this `Proposal`. */
  owner?: Maybe<Identity>;
  ownerId: Scalars['String']['output'];
  proposer: Scalars['JSON']['output'];
  snapshotted: Scalars['Boolean']['output'];
  state: ProposalStateEnum;
  totalAyeWeight: Scalars['BigFloat']['output'];
  totalNayWeight: Scalars['BigFloat']['output'];
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `Proposal`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
  url?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `ProposalVote`. */
  votes: ProposalVotesConnection;
};

/** Represents a potential change to how the chain will operate. It will need gain sufficient "Aye" votes before having effect */
export type ProposalBlocksByProposalVoteProposalIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a potential change to how the chain will operate. It will need gain sufficient "Aye" votes before having effect */
export type ProposalBlocksByProposalVoteProposalIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a potential change to how the chain will operate. It will need gain sufficient "Aye" votes before having effect */
export type ProposalVotesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ProposalVoteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProposalVotesOrderBy>>;
};

export type ProposalAggregates = {
  __typename?: 'ProposalAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A connection to a list of `Block` values, with data from `ProposalVote`. */
export type ProposalBlocksByProposalVoteProposalIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'ProposalBlocksByProposalVoteProposalIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `ProposalVote`, and the cursor to aid in pagination. */
  edges: Array<ProposalBlocksByProposalVoteProposalIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `ProposalVote`. */
export type ProposalBlocksByProposalVoteProposalIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `ProposalVote`. */
export type ProposalBlocksByProposalVoteProposalIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'ProposalBlocksByProposalVoteProposalIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `ProposalVote`. */
  proposalVotesByCreatedBlockId: ProposalVotesConnection;
};

/** A `Block` edge in the connection, with data from `ProposalVote`. */
export type ProposalBlocksByProposalVoteProposalIdAndCreatedBlockIdManyToManyEdgeProposalVotesByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<ProposalVoteFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<ProposalVotesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `ProposalVote`. */
export type ProposalBlocksByProposalVoteProposalIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'ProposalBlocksByProposalVoteProposalIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `ProposalVote`, and the cursor to aid in pagination. */
  edges: Array<ProposalBlocksByProposalVoteProposalIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `ProposalVote`. */
export type ProposalBlocksByProposalVoteProposalIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `ProposalVote`. */
export type ProposalBlocksByProposalVoteProposalIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'ProposalBlocksByProposalVoteProposalIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `ProposalVote`. */
  proposalVotesByUpdatedBlockId: ProposalVotesConnection;
};

/** A `Block` edge in the connection, with data from `ProposalVote`. */
export type ProposalBlocksByProposalVoteProposalIdAndUpdatedBlockIdManyToManyEdgeProposalVotesByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<ProposalVoteFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<ProposalVotesOrderBy>>;
  };

/** A filter to be used against `Proposal` object types. All fields are combined with a logical ‘and.’ */
export type ProposalFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ProposalFilter>>;
  /** Filter by the object’s `balance` field. */
  balance?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ProposalFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ProposalFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `proposer` field. */
  proposer?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `snapshotted` field. */
  snapshotted?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `state` field. */
  state?: InputMaybe<ProposalStateEnumFilter>;
  /** Filter by the object’s `totalAyeWeight` field. */
  totalAyeWeight?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totalNayWeight` field. */
  totalNayWeight?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `url` field. */
  url?: InputMaybe<StringFilter>;
};

/**  Represents all possible Proposal statuses */
export enum ProposalStateEnum {
  All = 'All',
  Executed = 'Executed',
  Expired = 'Expired',
  Failed = 'Failed',
  Pending = 'Pending',
  Rejected = 'Rejected',
  Scheduled = 'Scheduled',
}

/** A filter to be used against ProposalStateEnum fields. All fields are combined with a logical ‘and.’ */
export type ProposalStateEnumFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<ProposalStateEnum>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<ProposalStateEnum>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<ProposalStateEnum>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<ProposalStateEnum>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<ProposalStateEnum>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<ProposalStateEnum>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<ProposalStateEnum>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<ProposalStateEnum>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<ProposalStateEnum>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<ProposalStateEnum>>;
};

/** Represents a vote on a governance proposal */
export type ProposalVote = Node & {
  __typename?: 'ProposalVote';
  account: Scalars['String']['output'];
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `ProposalVote`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  id: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Proposal` that is related to this `ProposalVote`. */
  proposal?: Maybe<Proposal>;
  proposalId: Scalars['String']['output'];
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `ProposalVote`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
  vote: Scalars['Boolean']['output'];
  weight: Scalars['BigFloat']['output'];
};

export type ProposalVoteAggregates = {
  __typename?: 'ProposalVoteAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A filter to be used against `ProposalVote` object types. All fields are combined with a logical ‘and.’ */
export type ProposalVoteFilter = {
  /** Filter by the object’s `account` field. */
  account?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ProposalVoteFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ProposalVoteFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ProposalVoteFilter>>;
  /** Filter by the object’s `proposalId` field. */
  proposalId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vote` field. */
  vote?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `weight` field. */
  weight?: InputMaybe<BigFloatFilter>;
};

/** A connection to a list of `ProposalVote` values. */
export type ProposalVotesConnection = {
  __typename?: 'ProposalVotesConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<ProposalVoteAggregates>;
  /** A list of edges which contains the `ProposalVote` and cursor to aid in pagination. */
  edges: Array<ProposalVotesEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<ProposalVoteAggregates>>;
  /** A list of `ProposalVote` objects. */
  nodes: Array<Maybe<ProposalVote>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ProposalVote` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `ProposalVote` values. */
export type ProposalVotesConnectionGroupedAggregatesArgs = {
  groupBy: Array<ProposalVotesGroupBy>;
  having?: InputMaybe<ProposalVotesHavingInput>;
};

/** A `ProposalVote` edge in the connection. */
export type ProposalVotesEdge = {
  __typename?: 'ProposalVotesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ProposalVote` at the end of the edge. */
  node?: Maybe<ProposalVote>;
};

/** Grouping methods for `ProposalVote` for usage during aggregation. */
export enum ProposalVotesGroupBy {
  Account = 'ACCOUNT',
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  ProposalId = 'PROPOSAL_ID',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  Vote = 'VOTE',
  Weight = 'WEIGHT',
}

/** Conditions for `ProposalVote` aggregates. */
export type ProposalVotesHavingInput = {
  AND?: InputMaybe<Array<ProposalVotesHavingInput>>;
  OR?: InputMaybe<Array<ProposalVotesHavingInput>>;
};

/** Methods to use when ordering `ProposalVote`. */
export enum ProposalVotesOrderBy {
  AccountAsc = 'ACCOUNT_ASC',
  AccountDesc = 'ACCOUNT_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ProposalIdAsc = 'PROPOSAL_ID_ASC',
  ProposalIdDesc = 'PROPOSAL_ID_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  VoteAsc = 'VOTE_ASC',
  VoteDesc = 'VOTE_DESC',
  WeightAsc = 'WEIGHT_ASC',
  WeightDesc = 'WEIGHT_DESC',
}

/** A connection to a list of `Proposal` values. */
export type ProposalsConnection = {
  __typename?: 'ProposalsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<ProposalAggregates>;
  /** A list of edges which contains the `Proposal` and cursor to aid in pagination. */
  edges: Array<ProposalsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<ProposalAggregates>>;
  /** A list of `Proposal` objects. */
  nodes: Array<Maybe<Proposal>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Proposal` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Proposal` values. */
export type ProposalsConnectionGroupedAggregatesArgs = {
  groupBy: Array<ProposalsGroupBy>;
  having?: InputMaybe<ProposalsHavingInput>;
};

/** A `Proposal` edge in the connection. */
export type ProposalsEdge = {
  __typename?: 'ProposalsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Proposal` at the end of the edge. */
  node?: Maybe<Proposal>;
};

/** Grouping methods for `Proposal` for usage during aggregation. */
export enum ProposalsGroupBy {
  Balance = 'BALANCE',
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  Description = 'DESCRIPTION',
  OwnerId = 'OWNER_ID',
  Proposer = 'PROPOSER',
  Snapshotted = 'SNAPSHOTTED',
  State = 'STATE',
  TotalAyeWeight = 'TOTAL_AYE_WEIGHT',
  TotalNayWeight = 'TOTAL_NAY_WEIGHT',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  Url = 'URL',
}

/** Conditions for `Proposal` aggregates. */
export type ProposalsHavingInput = {
  AND?: InputMaybe<Array<ProposalsHavingInput>>;
  OR?: InputMaybe<Array<ProposalsHavingInput>>;
};

/** Methods to use when ordering `Proposal`. */
export enum ProposalsOrderBy {
  BalanceAsc = 'BALANCE_ASC',
  BalanceDesc = 'BALANCE_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ProposerAsc = 'PROPOSER_ASC',
  ProposerDesc = 'PROPOSER_DESC',
  SnapshottedAsc = 'SNAPSHOTTED_ASC',
  SnapshottedDesc = 'SNAPSHOTTED_DESC',
  StateAsc = 'STATE_ASC',
  StateDesc = 'STATE_DESC',
  TotalAyeWeightAsc = 'TOTAL_AYE_WEIGHT_ASC',
  TotalAyeWeightDesc = 'TOTAL_AYE_WEIGHT_DESC',
  TotalNayWeightAsc = 'TOTAL_NAY_WEIGHT_ASC',
  TotalNayWeightDesc = 'TOTAL_NAY_WEIGHT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  UrlAsc = 'URL_ASC',
  UrlDesc = 'URL_DESC',
  VotesCountAsc = 'VOTES_COUNT_ASC',
  VotesCountDesc = 'VOTES_COUNT_DESC',
}

/** The root query type which gives access points into the data universe. */
export type Query = Node & {
  __typename?: 'Query';
  _metadata?: Maybe<_Metadata>;
  account?: Maybe<Account>;
  /** Reads a single `Account` using its globally unique `ID`. */
  accountByNodeId?: Maybe<Account>;
  /** Reads and enables pagination through a set of `AccountHistory`. */
  accountHistories?: Maybe<AccountHistoriesConnection>;
  accountHistory?: Maybe<AccountHistory>;
  /** Reads a single `AccountHistory` using its globally unique `ID`. */
  accountHistoryByNodeId?: Maybe<AccountHistory>;
  /** Reads and enables pagination through a set of `Account`. */
  accounts?: Maybe<AccountsConnection>;
  agentGroup?: Maybe<AgentGroup>;
  /** Reads a single `AgentGroup` using its globally unique `ID`. */
  agentGroupByNodeId?: Maybe<AgentGroup>;
  agentGroupMembership?: Maybe<AgentGroupMembership>;
  /** Reads a single `AgentGroupMembership` using its globally unique `ID`. */
  agentGroupMembershipByNodeId?: Maybe<AgentGroupMembership>;
  /** Reads and enables pagination through a set of `AgentGroupMembership`. */
  agentGroupMemberships?: Maybe<AgentGroupMembershipsConnection>;
  /** Reads and enables pagination through a set of `AgentGroup`. */
  agentGroups?: Maybe<AgentGroupsConnection>;
  asset?: Maybe<Asset>;
  /** Reads a single `Asset` using its globally unique `ID`. */
  assetByNodeId?: Maybe<Asset>;
  assetDocument?: Maybe<AssetDocument>;
  /** Reads a single `AssetDocument` using its globally unique `ID`. */
  assetDocumentByNodeId?: Maybe<AssetDocument>;
  /** Reads and enables pagination through a set of `AssetDocument`. */
  assetDocuments?: Maybe<AssetDocumentsConnection>;
  assetHolder?: Maybe<AssetHolder>;
  /** Reads a single `AssetHolder` using its globally unique `ID`. */
  assetHolderByNodeId?: Maybe<AssetHolder>;
  /** Reads and enables pagination through a set of `AssetHolder`. */
  assetHolders?: Maybe<AssetHoldersConnection>;
  assetPendingOwnershipTransfer?: Maybe<AssetPendingOwnershipTransfer>;
  /** Reads a single `AssetPendingOwnershipTransfer` using its globally unique `ID`. */
  assetPendingOwnershipTransferByNodeId?: Maybe<AssetPendingOwnershipTransfer>;
  /** Reads and enables pagination through a set of `AssetPendingOwnershipTransfer`. */
  assetPendingOwnershipTransfers?: Maybe<AssetPendingOwnershipTransfersConnection>;
  assetTransaction?: Maybe<AssetTransaction>;
  /** Reads a single `AssetTransaction` using its globally unique `ID`. */
  assetTransactionByNodeId?: Maybe<AssetTransaction>;
  /** Reads and enables pagination through a set of `AssetTransaction`. */
  assetTransactions?: Maybe<AssetTransactionsConnection>;
  /** Reads and enables pagination through a set of `Asset`. */
  assets?: Maybe<AssetsConnection>;
  authorization?: Maybe<Authorization>;
  /** Reads a single `Authorization` using its globally unique `ID`. */
  authorizationByNodeId?: Maybe<Authorization>;
  /** Reads and enables pagination through a set of `Authorization`. */
  authorizations?: Maybe<AuthorizationsConnection>;
  block?: Maybe<Block>;
  /** Reads a single `Block` using its globally unique `ID`. */
  blockByNodeId?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Block`. */
  blocks?: Maybe<BlocksConnection>;
  bridgeEvent?: Maybe<BridgeEvent>;
  /** Reads a single `BridgeEvent` using its globally unique `ID`. */
  bridgeEventByNodeId?: Maybe<BridgeEvent>;
  /** Reads and enables pagination through a set of `BridgeEvent`. */
  bridgeEvents?: Maybe<BridgeEventsConnection>;
  /** Reads and enables pagination through a set of `ChildIdentity`. */
  childIdentities?: Maybe<ChildIdentitiesConnection>;
  childIdentity?: Maybe<ChildIdentity>;
  /** Reads a single `ChildIdentity` using its globally unique `ID`. */
  childIdentityByNodeId?: Maybe<ChildIdentity>;
  claim?: Maybe<Claim>;
  /** Reads a single `Claim` using its globally unique `ID`. */
  claimByNodeId?: Maybe<Claim>;
  claimScope?: Maybe<ClaimScope>;
  /** Reads a single `ClaimScope` using its globally unique `ID`. */
  claimScopeByNodeId?: Maybe<ClaimScope>;
  /** Reads and enables pagination through a set of `ClaimScope`. */
  claimScopes?: Maybe<ClaimScopesConnection>;
  /** Reads and enables pagination through a set of `Claim`. */
  claims?: Maybe<ClaimsConnection>;
  compliance?: Maybe<Compliance>;
  /** Reads a single `Compliance` using its globally unique `ID`. */
  complianceByNodeId?: Maybe<Compliance>;
  /** Reads and enables pagination through a set of `Compliance`. */
  compliances?: Maybe<CompliancesConnection>;
  debug?: Maybe<Debug>;
  /** Reads a single `Debug` using its globally unique `ID`. */
  debugByNodeId?: Maybe<Debug>;
  /** Reads and enables pagination through a set of `Debug`. */
  debugs?: Maybe<DebugsConnection>;
  distribution?: Maybe<Distribution>;
  /** Reads a single `Distribution` using its globally unique `ID`. */
  distributionByNodeId?: Maybe<Distribution>;
  distributionPayment?: Maybe<DistributionPayment>;
  /** Reads a single `DistributionPayment` using its globally unique `ID`. */
  distributionPaymentByNodeId?: Maybe<DistributionPayment>;
  /** Reads and enables pagination through a set of `DistributionPayment`. */
  distributionPayments?: Maybe<DistributionPaymentsConnection>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributions?: Maybe<DistributionsConnection>;
  event?: Maybe<Event>;
  /** Reads a single `Event` using its globally unique `ID`. */
  eventByNodeId?: Maybe<Event>;
  /** Reads and enables pagination through a set of `Event`. */
  events?: Maybe<EventsConnection>;
  extrinsic?: Maybe<Extrinsic>;
  /** Reads a single `Extrinsic` using its globally unique `ID`. */
  extrinsicByNodeId?: Maybe<Extrinsic>;
  /** Reads and enables pagination through a set of `Extrinsic`. */
  extrinsics?: Maybe<ExtrinsicsConnection>;
  foundType?: Maybe<FoundType>;
  /** Reads a single `FoundType` using its globally unique `ID`. */
  foundTypeByNodeId?: Maybe<FoundType>;
  /** Reads and enables pagination through a set of `FoundType`. */
  foundTypes?: Maybe<FoundTypesConnection>;
  funding?: Maybe<Funding>;
  /** Reads a single `Funding` using its globally unique `ID`. */
  fundingByNodeId?: Maybe<Funding>;
  /** Reads and enables pagination through a set of `Funding`. */
  fundings?: Maybe<FundingsConnection>;
  /** Reads and enables pagination through a set of `Identity`. */
  identities?: Maybe<IdentitiesConnection>;
  identity?: Maybe<Identity>;
  /** Reads a single `Identity` using its globally unique `ID`. */
  identityByNodeId?: Maybe<Identity>;
  instruction?: Maybe<Instruction>;
  /** Reads a single `Instruction` using its globally unique `ID`. */
  instructionByNodeId?: Maybe<Instruction>;
  /** Reads and enables pagination through a set of `Instruction`. */
  instructions?: Maybe<InstructionsConnection>;
  investment?: Maybe<Investment>;
  /** Reads a single `Investment` using its globally unique `ID`. */
  investmentByNodeId?: Maybe<Investment>;
  /** Reads and enables pagination through a set of `Investment`. */
  investments?: Maybe<InvestmentsConnection>;
  leg?: Maybe<Leg>;
  /** Reads a single `Leg` using its globally unique `ID`. */
  legByNodeId?: Maybe<Leg>;
  /** Reads and enables pagination through a set of `Leg`. */
  legs?: Maybe<LegsConnection>;
  migration?: Maybe<Migration>;
  /** Reads a single `Migration` using its globally unique `ID`. */
  migrationByNodeId?: Maybe<Migration>;
  /** Reads and enables pagination through a set of `Migration`. */
  migrations?: Maybe<MigrationsConnection>;
  /** Fetches an object given its globally unique `ID`. */
  node?: Maybe<Node>;
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
  nodeId: Scalars['ID']['output'];
  permission?: Maybe<Permission>;
  /** Reads a single `Permission` using its globally unique `ID`. */
  permissionByNodeId?: Maybe<Permission>;
  /** Reads and enables pagination through a set of `Permission`. */
  permissions?: Maybe<PermissionsConnection>;
  polyxTransaction?: Maybe<PolyxTransaction>;
  /** Reads a single `PolyxTransaction` using its globally unique `ID`. */
  polyxTransactionByNodeId?: Maybe<PolyxTransaction>;
  /** Reads and enables pagination through a set of `PolyxTransaction`. */
  polyxTransactions?: Maybe<PolyxTransactionsConnection>;
  portfolio?: Maybe<Portfolio>;
  /** Reads a single `Portfolio` using its globally unique `ID`. */
  portfolioByNodeId?: Maybe<Portfolio>;
  portfolioMovement?: Maybe<PortfolioMovement>;
  /** Reads a single `PortfolioMovement` using its globally unique `ID`. */
  portfolioMovementByNodeId?: Maybe<PortfolioMovement>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovements?: Maybe<PortfolioMovementsConnection>;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfolios?: Maybe<PortfoliosConnection>;
  proposal?: Maybe<Proposal>;
  /** Reads a single `Proposal` using its globally unique `ID`. */
  proposalByNodeId?: Maybe<Proposal>;
  proposalVote?: Maybe<ProposalVote>;
  /** Reads a single `ProposalVote` using its globally unique `ID`. */
  proposalVoteByNodeId?: Maybe<ProposalVote>;
  /** Reads and enables pagination through a set of `ProposalVote`. */
  proposalVotes?: Maybe<ProposalVotesConnection>;
  /** Reads and enables pagination through a set of `Proposal`. */
  proposals?: Maybe<ProposalsConnection>;
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query;
  settlement?: Maybe<Settlement>;
  /** Reads a single `Settlement` using its globally unique `ID`. */
  settlementByNodeId?: Maybe<Settlement>;
  /** Reads and enables pagination through a set of `Settlement`. */
  settlements?: Maybe<SettlementsConnection>;
  stakingEvent?: Maybe<StakingEvent>;
  /** Reads a single `StakingEvent` using its globally unique `ID`. */
  stakingEventByNodeId?: Maybe<StakingEvent>;
  /** Reads and enables pagination through a set of `StakingEvent`. */
  stakingEvents?: Maybe<StakingEventsConnection>;
  statType?: Maybe<StatType>;
  /** Reads a single `StatType` using its globally unique `ID`. */
  statTypeByNodeId?: Maybe<StatType>;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypes?: Maybe<StatTypesConnection>;
  sto?: Maybe<Sto>;
  /** Reads a single `Sto` using its globally unique `ID`. */
  stoByNodeId?: Maybe<Sto>;
  /** Reads and enables pagination through a set of `Sto`. */
  stos?: Maybe<StosConnection>;
  subqueryVersion?: Maybe<SubqueryVersion>;
  /** Reads a single `SubqueryVersion` using its globally unique `ID`. */
  subqueryVersionByNodeId?: Maybe<SubqueryVersion>;
  /** Reads and enables pagination through a set of `SubqueryVersion`. */
  subqueryVersions?: Maybe<SubqueryVersionsConnection>;
  tickerExternalAgent?: Maybe<TickerExternalAgent>;
  tickerExternalAgentAction?: Maybe<TickerExternalAgentAction>;
  /** Reads a single `TickerExternalAgentAction` using its globally unique `ID`. */
  tickerExternalAgentActionByNodeId?: Maybe<TickerExternalAgentAction>;
  /** Reads and enables pagination through a set of `TickerExternalAgentAction`. */
  tickerExternalAgentActions?: Maybe<TickerExternalAgentActionsConnection>;
  /** Reads a single `TickerExternalAgent` using its globally unique `ID`. */
  tickerExternalAgentByNodeId?: Maybe<TickerExternalAgent>;
  /** Reads and enables pagination through a set of `TickerExternalAgentHistory`. */
  tickerExternalAgentHistories?: Maybe<TickerExternalAgentHistoriesConnection>;
  tickerExternalAgentHistory?: Maybe<TickerExternalAgentHistory>;
  /** Reads a single `TickerExternalAgentHistory` using its globally unique `ID`. */
  tickerExternalAgentHistoryByNodeId?: Maybe<TickerExternalAgentHistory>;
  /** Reads and enables pagination through a set of `TickerExternalAgent`. */
  tickerExternalAgents?: Maybe<TickerExternalAgentsConnection>;
  transferCompliance?: Maybe<TransferCompliance>;
  /** Reads a single `TransferCompliance` using its globally unique `ID`. */
  transferComplianceByNodeId?: Maybe<TransferCompliance>;
  transferComplianceExemption?: Maybe<TransferComplianceExemption>;
  /** Reads a single `TransferComplianceExemption` using its globally unique `ID`. */
  transferComplianceExemptionByNodeId?: Maybe<TransferComplianceExemption>;
  /** Reads and enables pagination through a set of `TransferComplianceExemption`. */
  transferComplianceExemptions?: Maybe<TransferComplianceExemptionsConnection>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliances?: Maybe<TransferCompliancesConnection>;
  transferManager?: Maybe<TransferManager>;
  /** Reads a single `TransferManager` using its globally unique `ID`. */
  transferManagerByNodeId?: Maybe<TransferManager>;
  /** Reads and enables pagination through a set of `TransferManager`. */
  transferManagers?: Maybe<TransferManagersConnection>;
  trustedClaimIssuer?: Maybe<TrustedClaimIssuer>;
  /** Reads a single `TrustedClaimIssuer` using its globally unique `ID`. */
  trustedClaimIssuerByNodeId?: Maybe<TrustedClaimIssuer>;
  /** Reads and enables pagination through a set of `TrustedClaimIssuer`. */
  trustedClaimIssuers?: Maybe<TrustedClaimIssuersConnection>;
  venue?: Maybe<Venue>;
  /** Reads a single `Venue` using its globally unique `ID`. */
  venueByNodeId?: Maybe<Venue>;
  /** Reads and enables pagination through a set of `Venue`. */
  venues?: Maybe<VenuesConnection>;
};

/** The root query type which gives access points into the data universe. */
export type QueryAccountArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryAccountByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryAccountHistoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AccountHistoryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountHistoriesOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryAccountHistoryArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryAccountHistoryByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryAccountsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AccountFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountsOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryAgentGroupArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryAgentGroupByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryAgentGroupMembershipArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryAgentGroupMembershipByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryAgentGroupMembershipsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AgentGroupMembershipFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AgentGroupMembershipsOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryAgentGroupsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AgentGroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AgentGroupsOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryAssetArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryAssetByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryAssetDocumentArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryAssetDocumentByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryAssetDocumentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetDocumentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetDocumentsOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryAssetHolderArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryAssetHolderByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryAssetHoldersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetHolderFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetHoldersOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryAssetPendingOwnershipTransferArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryAssetPendingOwnershipTransferByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryAssetPendingOwnershipTransfersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetPendingOwnershipTransferFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetPendingOwnershipTransfersOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryAssetTransactionArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryAssetTransactionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryAssetTransactionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetTransactionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetTransactionsOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryAssetsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryAuthorizationArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryAuthorizationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryAuthorizationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AuthorizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AuthorizationsOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryBlockArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryBlockByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryBlocksArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryBridgeEventArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryBridgeEventByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryBridgeEventsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BridgeEventFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BridgeEventsOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryChildIdentitiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ChildIdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ChildIdentitiesOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryChildIdentityArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryChildIdentityByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryClaimArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryClaimByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryClaimScopeArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryClaimScopeByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryClaimScopesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ClaimScopeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClaimScopesOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryClaimsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ClaimFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClaimsOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryComplianceArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryComplianceByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryCompliancesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ComplianceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CompliancesOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryDebugArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryDebugByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryDebugsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<DebugFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DebugsOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryDistributionArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryDistributionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryDistributionPaymentArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryDistributionPaymentByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryDistributionPaymentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<DistributionPaymentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DistributionPaymentsOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryDistributionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<DistributionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DistributionsOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryEventArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryEventByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryEventsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<EventFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryExtrinsicArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryExtrinsicByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryExtrinsicsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ExtrinsicFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ExtrinsicsOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryFoundTypeArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryFoundTypeByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryFoundTypesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<FoundTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FoundTypesOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryFundingArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryFundingByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryFundingsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<FundingFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FundingsOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryIdentitiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryIdentityArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryIdentityByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryInstructionArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryInstructionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryInstructionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<InstructionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InstructionsOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryInvestmentArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryInvestmentByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryInvestmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<InvestmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InvestmentsOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryLegArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryLegByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryLegsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<LegFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LegsOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryMigrationArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryMigrationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryMigrationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<MigrationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MigrationsOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryNodeArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryPermissionArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryPermissionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryPermissionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PermissionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryPolyxTransactionArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryPolyxTransactionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryPolyxTransactionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PolyxTransactionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PolyxTransactionsOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryPortfolioArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryPortfolioByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryPortfolioMovementArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryPortfolioMovementByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryPortfolioMovementsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioMovementFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfolioMovementsOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryPortfoliosArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryProposalArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryProposalByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryProposalVoteArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryProposalVoteByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryProposalVotesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ProposalVoteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProposalVotesOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryProposalsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ProposalFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProposalsOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QuerySettlementArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QuerySettlementByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QuerySettlementsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<SettlementFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SettlementsOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryStakingEventArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryStakingEventByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryStakingEventsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StakingEventFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StakingEventsOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryStatTypeArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryStatTypeByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryStatTypesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StatTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StatTypesOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryStoArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryStoByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryStosArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StoFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StosOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QuerySubqueryVersionArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QuerySubqueryVersionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QuerySubqueryVersionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<SubqueryVersionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SubqueryVersionsOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryTickerExternalAgentArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryTickerExternalAgentActionArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryTickerExternalAgentActionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryTickerExternalAgentActionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<TickerExternalAgentActionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TickerExternalAgentActionsOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryTickerExternalAgentByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryTickerExternalAgentHistoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<TickerExternalAgentHistoryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TickerExternalAgentHistoriesOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryTickerExternalAgentHistoryArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryTickerExternalAgentHistoryByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryTickerExternalAgentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<TickerExternalAgentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TickerExternalAgentsOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryTransferComplianceArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryTransferComplianceByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryTransferComplianceExemptionArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryTransferComplianceExemptionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryTransferComplianceExemptionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<TransferComplianceExemptionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TransferComplianceExemptionsOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryTransferCompliancesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<TransferComplianceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TransferCompliancesOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryTransferManagerArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryTransferManagerByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryTransferManagersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<TransferManagerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TransferManagersOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryTrustedClaimIssuerArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryTrustedClaimIssuerByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryTrustedClaimIssuersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<TrustedClaimIssuerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TrustedClaimIssuersOrderBy>>;
};

/** The root query type which gives access points into the data universe. */
export type QueryVenueArgs = {
  id: Scalars['String']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryVenueByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};

/** The root query type which gives access points into the data universe. */
export type QueryVenuesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<VenueFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VenuesOrderBy>>;
};

/** Represents a trade of assets between parties */
export type Settlement = Node & {
  __typename?: 'Settlement';
  /** Reads and enables pagination through a set of `Block`. */
  blocksByLegSettlementIdAndCreatedBlockId: SettlementBlocksByLegSettlementIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByLegSettlementIdAndUpdatedBlockId: SettlementBlocksByLegSettlementIdAndUpdatedBlockIdManyToManyConnection;
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `Settlement`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  id: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `Instruction`. */
  instructionsByLegSettlementIdAndInstructionId: SettlementInstructionsByLegSettlementIdAndInstructionIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Leg`. */
  legs: LegsConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByLegSettlementIdAndFromId: SettlementPortfoliosByLegSettlementIdAndFromIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByLegSettlementIdAndToId: SettlementPortfoliosByLegSettlementIdAndToIdManyToManyConnection;
  result: SettlementResultEnum;
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `Settlement`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
};

/** Represents a trade of assets between parties */
export type SettlementBlocksByLegSettlementIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a trade of assets between parties */
export type SettlementBlocksByLegSettlementIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/** Represents a trade of assets between parties */
export type SettlementInstructionsByLegSettlementIdAndInstructionIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<InstructionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InstructionsOrderBy>>;
};

/** Represents a trade of assets between parties */
export type SettlementLegsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<LegFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LegsOrderBy>>;
};

/** Represents a trade of assets between parties */
export type SettlementPortfoliosByLegSettlementIdAndFromIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/** Represents a trade of assets between parties */
export type SettlementPortfoliosByLegSettlementIdAndToIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

export type SettlementAggregates = {
  __typename?: 'SettlementAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A connection to a list of `Block` values, with data from `Leg`. */
export type SettlementBlocksByLegSettlementIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'SettlementBlocksByLegSettlementIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<SettlementBlocksByLegSettlementIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Leg`. */
export type SettlementBlocksByLegSettlementIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Leg`. */
export type SettlementBlocksByLegSettlementIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'SettlementBlocksByLegSettlementIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByCreatedBlockId: LegsConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Leg`. */
export type SettlementBlocksByLegSettlementIdAndCreatedBlockIdManyToManyEdgeLegsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<LegFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<LegsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Leg`. */
export type SettlementBlocksByLegSettlementIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'SettlementBlocksByLegSettlementIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<SettlementBlocksByLegSettlementIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Leg`. */
export type SettlementBlocksByLegSettlementIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Leg`. */
export type SettlementBlocksByLegSettlementIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'SettlementBlocksByLegSettlementIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByUpdatedBlockId: LegsConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Leg`. */
export type SettlementBlocksByLegSettlementIdAndUpdatedBlockIdManyToManyEdgeLegsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<LegFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<LegsOrderBy>>;
  };

/** A filter to be used against `Settlement` object types. All fields are combined with a logical ‘and.’ */
export type SettlementFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SettlementFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SettlementFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SettlementFilter>>;
  /** Filter by the object’s `result` field. */
  result?: InputMaybe<SettlementResultEnumFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
};

/** A connection to a list of `Instruction` values, with data from `Leg`. */
export type SettlementInstructionsByLegSettlementIdAndInstructionIdManyToManyConnection = {
  __typename?: 'SettlementInstructionsByLegSettlementIdAndInstructionIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<InstructionAggregates>;
  /** A list of edges which contains the `Instruction`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<SettlementInstructionsByLegSettlementIdAndInstructionIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<InstructionAggregates>>;
  /** A list of `Instruction` objects. */
  nodes: Array<Maybe<Instruction>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Instruction` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Instruction` values, with data from `Leg`. */
export type SettlementInstructionsByLegSettlementIdAndInstructionIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<InstructionsGroupBy>;
    having?: InputMaybe<InstructionsHavingInput>;
  };

/** A `Instruction` edge in the connection, with data from `Leg`. */
export type SettlementInstructionsByLegSettlementIdAndInstructionIdManyToManyEdge = {
  __typename?: 'SettlementInstructionsByLegSettlementIdAndInstructionIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Leg`. */
  legs: LegsConnection;
  /** The `Instruction` at the end of the edge. */
  node?: Maybe<Instruction>;
};

/** A `Instruction` edge in the connection, with data from `Leg`. */
export type SettlementInstructionsByLegSettlementIdAndInstructionIdManyToManyEdgeLegsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<LegFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LegsOrderBy>>;
};

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type SettlementPortfoliosByLegSettlementIdAndFromIdManyToManyConnection = {
  __typename?: 'SettlementPortfoliosByLegSettlementIdAndFromIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<SettlementPortfoliosByLegSettlementIdAndFromIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type SettlementPortfoliosByLegSettlementIdAndFromIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: InputMaybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type SettlementPortfoliosByLegSettlementIdAndFromIdManyToManyEdge = {
  __typename?: 'SettlementPortfoliosByLegSettlementIdAndFromIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByFromId: LegsConnection;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
};

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type SettlementPortfoliosByLegSettlementIdAndFromIdManyToManyEdgeLegsByFromIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<LegFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LegsOrderBy>>;
};

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type SettlementPortfoliosByLegSettlementIdAndToIdManyToManyConnection = {
  __typename?: 'SettlementPortfoliosByLegSettlementIdAndToIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<SettlementPortfoliosByLegSettlementIdAndToIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type SettlementPortfoliosByLegSettlementIdAndToIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: InputMaybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type SettlementPortfoliosByLegSettlementIdAndToIdManyToManyEdge = {
  __typename?: 'SettlementPortfoliosByLegSettlementIdAndToIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByToId: LegsConnection;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
};

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type SettlementPortfoliosByLegSettlementIdAndToIdManyToManyEdgeLegsByToIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<LegFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LegsOrderBy>>;
};

/**  Represents all possible states of a Settlement */
export enum SettlementResultEnum {
  Executed = 'Executed',
  Failed = 'Failed',
  None = 'None',
  Rejected = 'Rejected',
}

/** A filter to be used against SettlementResultEnum fields. All fields are combined with a logical ‘and.’ */
export type SettlementResultEnumFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<SettlementResultEnum>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<SettlementResultEnum>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<SettlementResultEnum>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<SettlementResultEnum>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<SettlementResultEnum>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<SettlementResultEnum>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<SettlementResultEnum>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<SettlementResultEnum>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<SettlementResultEnum>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<SettlementResultEnum>>;
};

/** A connection to a list of `Settlement` values. */
export type SettlementsConnection = {
  __typename?: 'SettlementsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<SettlementAggregates>;
  /** A list of edges which contains the `Settlement` and cursor to aid in pagination. */
  edges: Array<SettlementsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<SettlementAggregates>>;
  /** A list of `Settlement` objects. */
  nodes: Array<Maybe<Settlement>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Settlement` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Settlement` values. */
export type SettlementsConnectionGroupedAggregatesArgs = {
  groupBy: Array<SettlementsGroupBy>;
  having?: InputMaybe<SettlementsHavingInput>;
};

/** A `Settlement` edge in the connection. */
export type SettlementsEdge = {
  __typename?: 'SettlementsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Settlement` at the end of the edge. */
  node?: Maybe<Settlement>;
};

/** Grouping methods for `Settlement` for usage during aggregation. */
export enum SettlementsGroupBy {
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  Result = 'RESULT',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
}

/** Conditions for `Settlement` aggregates. */
export type SettlementsHavingInput = {
  AND?: InputMaybe<Array<SettlementsHavingInput>>;
  OR?: InputMaybe<Array<SettlementsHavingInput>>;
};

/** Methods to use when ordering `Settlement`. */
export enum SettlementsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LegsCountAsc = 'LEGS_COUNT_ASC',
  LegsCountDesc = 'LEGS_COUNT_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ResultAsc = 'RESULT_ASC',
  ResultDesc = 'RESULT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
}

/** Represents a change in staking status */
export type StakingEvent = Node & {
  __typename?: 'StakingEvent';
  amount?: Maybe<Scalars['BigFloat']['output']>;
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `StakingEvent`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  datetime: Scalars['Datetime']['output'];
  eventId: EventIdEnum;
  id: Scalars['String']['output'];
  /** Reads a single `Identity` that is related to this `StakingEvent`. */
  identity?: Maybe<Identity>;
  identityId?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  nominatedValidators?: Maybe<Scalars['JSON']['output']>;
  stashAccount?: Maybe<Scalars['String']['output']>;
  transactionId?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `StakingEvent`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
};

export type StakingEventAggregates = {
  __typename?: 'StakingEventAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A filter to be used against `StakingEvent` object types. All fields are combined with a logical ‘and.’ */
export type StakingEventFilter = {
  /** Filter by the object’s `amount` field. */
  amount?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<StakingEventFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `datetime` field. */
  datetime?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `eventId` field. */
  eventId?: InputMaybe<EventIdEnumFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `identityId` field. */
  identityId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `nominatedValidators` field. */
  nominatedValidators?: InputMaybe<JsonFilter>;
  /** Negates the expression. */
  not?: InputMaybe<StakingEventFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<StakingEventFilter>>;
  /** Filter by the object’s `stashAccount` field. */
  stashAccount?: InputMaybe<StringFilter>;
  /** Filter by the object’s `transactionId` field. */
  transactionId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
};

/** A connection to a list of `StakingEvent` values. */
export type StakingEventsConnection = {
  __typename?: 'StakingEventsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<StakingEventAggregates>;
  /** A list of edges which contains the `StakingEvent` and cursor to aid in pagination. */
  edges: Array<StakingEventsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<StakingEventAggregates>>;
  /** A list of `StakingEvent` objects. */
  nodes: Array<Maybe<StakingEvent>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `StakingEvent` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `StakingEvent` values. */
export type StakingEventsConnectionGroupedAggregatesArgs = {
  groupBy: Array<StakingEventsGroupBy>;
  having?: InputMaybe<StakingEventsHavingInput>;
};

/** A `StakingEvent` edge in the connection. */
export type StakingEventsEdge = {
  __typename?: 'StakingEventsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `StakingEvent` at the end of the edge. */
  node?: Maybe<StakingEvent>;
};

/** Grouping methods for `StakingEvent` for usage during aggregation. */
export enum StakingEventsGroupBy {
  Amount = 'AMOUNT',
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  Datetime = 'DATETIME',
  EventId = 'EVENT_ID',
  IdentityId = 'IDENTITY_ID',
  NominatedValidators = 'NOMINATED_VALIDATORS',
  StashAccount = 'STASH_ACCOUNT',
  TransactionId = 'TRANSACTION_ID',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
}

/** Conditions for `StakingEvent` aggregates. */
export type StakingEventsHavingInput = {
  AND?: InputMaybe<Array<StakingEventsHavingInput>>;
  OR?: InputMaybe<Array<StakingEventsHavingInput>>;
};

/** Methods to use when ordering `StakingEvent`. */
export enum StakingEventsOrderBy {
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  DatetimeAsc = 'DATETIME_ASC',
  DatetimeDesc = 'DATETIME_DESC',
  EventIdAsc = 'EVENT_ID_ASC',
  EventIdDesc = 'EVENT_ID_DESC',
  IdentityIdAsc = 'IDENTITY_ID_ASC',
  IdentityIdDesc = 'IDENTITY_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  NominatedValidatorsAsc = 'NOMINATED_VALIDATORS_ASC',
  NominatedValidatorsDesc = 'NOMINATED_VALIDATORS_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  StashAccountAsc = 'STASH_ACCOUNT_ASC',
  StashAccountDesc = 'STASH_ACCOUNT_DESC',
  TransactionIdAsc = 'TRANSACTION_ID_ASC',
  TransactionIdDesc = 'TRANSACTION_ID_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
}

/**  Represents all known stat types */
export enum StatOpTypeEnum {
  Balance = 'Balance',
  Count = 'Count',
}

/** A filter to be used against StatOpTypeEnum fields. All fields are combined with a logical ‘and.’ */
export type StatOpTypeEnumFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<StatOpTypeEnum>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<StatOpTypeEnum>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<StatOpTypeEnum>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<StatOpTypeEnum>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<StatOpTypeEnum>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<StatOpTypeEnum>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<StatOpTypeEnum>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<StatOpTypeEnum>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<StatOpTypeEnum>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<StatOpTypeEnum>>;
};

/**
 * Represents an on chain statistic about the Asset owners. e.g. How many investors hold the Asset
 *
 * These are required to be enabled in order for the chain to enforce transfer restrictions
 *
 * e.g. A restriction requiring ownership to be at least 50% Canadian would require a StatType of type `Balance` scoped to Jurisdiction before being created
 */
export type StatType = Node & {
  __typename?: 'StatType';
  /** Reads a single `Asset` that is related to this `StatType`. */
  asset?: Maybe<Asset>;
  assetId: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTransferComplianceStatTypeIdAndAssetId: StatTypeAssetsByTransferComplianceStatTypeIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTransferComplianceStatTypeIdAndCreatedBlockId: StatTypeBlocksByTransferComplianceStatTypeIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTransferComplianceStatTypeIdAndUpdatedBlockId: StatTypeBlocksByTransferComplianceStatTypeIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads a single `Identity` that is related to this `StatType`. */
  claimIssuer?: Maybe<Identity>;
  claimIssuerId?: Maybe<Scalars['String']['output']>;
  claimType?: Maybe<ClaimTypeEnum>;
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `StatType`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  id: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByTransferComplianceStatTypeIdAndClaimIssuerId: StatTypeIdentitiesByTransferComplianceStatTypeIdAndClaimIssuerIdManyToManyConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  opType: StatOpTypeEnum;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliances: TransferCompliancesConnection;
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `StatType`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
};

/**
 * Represents an on chain statistic about the Asset owners. e.g. How many investors hold the Asset
 *
 * These are required to be enabled in order for the chain to enforce transfer restrictions
 *
 * e.g. A restriction requiring ownership to be at least 50% Canadian would require a StatType of type `Balance` scoped to Jurisdiction before being created
 */
export type StatTypeAssetsByTransferComplianceStatTypeIdAndAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/**
 * Represents an on chain statistic about the Asset owners. e.g. How many investors hold the Asset
 *
 * These are required to be enabled in order for the chain to enforce transfer restrictions
 *
 * e.g. A restriction requiring ownership to be at least 50% Canadian would require a StatType of type `Balance` scoped to Jurisdiction before being created
 */
export type StatTypeBlocksByTransferComplianceStatTypeIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents an on chain statistic about the Asset owners. e.g. How many investors hold the Asset
 *
 * These are required to be enabled in order for the chain to enforce transfer restrictions
 *
 * e.g. A restriction requiring ownership to be at least 50% Canadian would require a StatType of type `Balance` scoped to Jurisdiction before being created
 */
export type StatTypeBlocksByTransferComplianceStatTypeIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents an on chain statistic about the Asset owners. e.g. How many investors hold the Asset
 *
 * These are required to be enabled in order for the chain to enforce transfer restrictions
 *
 * e.g. A restriction requiring ownership to be at least 50% Canadian would require a StatType of type `Balance` scoped to Jurisdiction before being created
 */
export type StatTypeIdentitiesByTransferComplianceStatTypeIdAndClaimIssuerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/**
 * Represents an on chain statistic about the Asset owners. e.g. How many investors hold the Asset
 *
 * These are required to be enabled in order for the chain to enforce transfer restrictions
 *
 * e.g. A restriction requiring ownership to be at least 50% Canadian would require a StatType of type `Balance` scoped to Jurisdiction before being created
 */
export type StatTypeTransferCompliancesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<TransferComplianceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TransferCompliancesOrderBy>>;
};

export type StatTypeAggregates = {
  __typename?: 'StatTypeAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A connection to a list of `Asset` values, with data from `TransferCompliance`. */
export type StatTypeAssetsByTransferComplianceStatTypeIdAndAssetIdManyToManyConnection = {
  __typename?: 'StatTypeAssetsByTransferComplianceStatTypeIdAndAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
  edges: Array<StatTypeAssetsByTransferComplianceStatTypeIdAndAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `TransferCompliance`. */
export type StatTypeAssetsByTransferComplianceStatTypeIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: InputMaybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TransferCompliance`. */
export type StatTypeAssetsByTransferComplianceStatTypeIdAndAssetIdManyToManyEdge = {
  __typename?: 'StatTypeAssetsByTransferComplianceStatTypeIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliances: TransferCompliancesConnection;
};

/** A `Asset` edge in the connection, with data from `TransferCompliance`. */
export type StatTypeAssetsByTransferComplianceStatTypeIdAndAssetIdManyToManyEdgeTransferCompliancesArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TransferComplianceFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TransferCompliancesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `TransferCompliance`. */
export type StatTypeBlocksByTransferComplianceStatTypeIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'StatTypeBlocksByTransferComplianceStatTypeIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
  edges: Array<StatTypeBlocksByTransferComplianceStatTypeIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `TransferCompliance`. */
export type StatTypeBlocksByTransferComplianceStatTypeIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TransferCompliance`. */
export type StatTypeBlocksByTransferComplianceStatTypeIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'StatTypeBlocksByTransferComplianceStatTypeIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliancesByCreatedBlockId: TransferCompliancesConnection;
};

/** A `Block` edge in the connection, with data from `TransferCompliance`. */
export type StatTypeBlocksByTransferComplianceStatTypeIdAndCreatedBlockIdManyToManyEdgeTransferCompliancesByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TransferComplianceFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TransferCompliancesOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `TransferCompliance`. */
export type StatTypeBlocksByTransferComplianceStatTypeIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'StatTypeBlocksByTransferComplianceStatTypeIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
  edges: Array<StatTypeBlocksByTransferComplianceStatTypeIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `TransferCompliance`. */
export type StatTypeBlocksByTransferComplianceStatTypeIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TransferCompliance`. */
export type StatTypeBlocksByTransferComplianceStatTypeIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'StatTypeBlocksByTransferComplianceStatTypeIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliancesByUpdatedBlockId: TransferCompliancesConnection;
};

/** A `Block` edge in the connection, with data from `TransferCompliance`. */
export type StatTypeBlocksByTransferComplianceStatTypeIdAndUpdatedBlockIdManyToManyEdgeTransferCompliancesByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TransferComplianceFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TransferCompliancesOrderBy>>;
  };

/** A filter to be used against `StatType` object types. All fields are combined with a logical ‘and.’ */
export type StatTypeFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<StatTypeFilter>>;
  /** Filter by the object’s `assetId` field. */
  assetId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `claimIssuerId` field. */
  claimIssuerId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `claimType` field. */
  claimType?: InputMaybe<ClaimTypeEnumFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<StatTypeFilter>;
  /** Filter by the object’s `opType` field. */
  opType?: InputMaybe<StatOpTypeEnumFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<StatTypeFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
};

/** A connection to a list of `Identity` values, with data from `TransferCompliance`. */
export type StatTypeIdentitiesByTransferComplianceStatTypeIdAndClaimIssuerIdManyToManyConnection = {
  __typename?: 'StatTypeIdentitiesByTransferComplianceStatTypeIdAndClaimIssuerIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
  edges: Array<StatTypeIdentitiesByTransferComplianceStatTypeIdAndClaimIssuerIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `TransferCompliance`. */
export type StatTypeIdentitiesByTransferComplianceStatTypeIdAndClaimIssuerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: InputMaybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `TransferCompliance`. */
export type StatTypeIdentitiesByTransferComplianceStatTypeIdAndClaimIssuerIdManyToManyEdge = {
  __typename?: 'StatTypeIdentitiesByTransferComplianceStatTypeIdAndClaimIssuerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliancesByClaimIssuerId: TransferCompliancesConnection;
};

/** A `Identity` edge in the connection, with data from `TransferCompliance`. */
export type StatTypeIdentitiesByTransferComplianceStatTypeIdAndClaimIssuerIdManyToManyEdgeTransferCompliancesByClaimIssuerIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<TransferComplianceFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<TransferCompliancesOrderBy>>;
  };

/** A connection to a list of `StatType` values. */
export type StatTypesConnection = {
  __typename?: 'StatTypesConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<StatTypeAggregates>;
  /** A list of edges which contains the `StatType` and cursor to aid in pagination. */
  edges: Array<StatTypesEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<StatTypeAggregates>>;
  /** A list of `StatType` objects. */
  nodes: Array<Maybe<StatType>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `StatType` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `StatType` values. */
export type StatTypesConnectionGroupedAggregatesArgs = {
  groupBy: Array<StatTypesGroupBy>;
  having?: InputMaybe<StatTypesHavingInput>;
};

/** A `StatType` edge in the connection. */
export type StatTypesEdge = {
  __typename?: 'StatTypesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `StatType` at the end of the edge. */
  node?: Maybe<StatType>;
};

/** Grouping methods for `StatType` for usage during aggregation. */
export enum StatTypesGroupBy {
  AssetId = 'ASSET_ID',
  ClaimIssuerId = 'CLAIM_ISSUER_ID',
  ClaimType = 'CLAIM_TYPE',
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  OpType = 'OP_TYPE',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
}

/** Conditions for `StatType` aggregates. */
export type StatTypesHavingInput = {
  AND?: InputMaybe<Array<StatTypesHavingInput>>;
  OR?: InputMaybe<Array<StatTypesHavingInput>>;
};

/** Methods to use when ordering `StatType`. */
export enum StatTypesOrderBy {
  AssetIdAsc = 'ASSET_ID_ASC',
  AssetIdDesc = 'ASSET_ID_DESC',
  ClaimIssuerIdAsc = 'CLAIM_ISSUER_ID_ASC',
  ClaimIssuerIdDesc = 'CLAIM_ISSUER_ID_DESC',
  ClaimTypeAsc = 'CLAIM_TYPE_ASC',
  ClaimTypeDesc = 'CLAIM_TYPE_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  OpTypeAsc = 'OP_TYPE_ASC',
  OpTypeDesc = 'OP_TYPE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TransferCompliancesCountAsc = 'TRANSFER_COMPLIANCES_COUNT_ASC',
  TransferCompliancesCountDesc = 'TRANSFER_COMPLIANCES_COUNT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
}

/** Securities Token Offering. Represents a fund raising effort from a company. e.g. sale of company equity in exchange for a stable coin */
export type Sto = Node & {
  __typename?: 'Sto';
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `Sto`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  /** Reads a single `Identity` that is related to this `Sto`. */
  creator?: Maybe<Identity>;
  creatorId: Scalars['String']['output'];
  end?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['String']['output'];
  minimumInvestment: Scalars['BigFloat']['output'];
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Asset` that is related to this `Sto`. */
  offeringAsset?: Maybe<Asset>;
  offeringAssetId: Scalars['String']['output'];
  /** Reads a single `Portfolio` that is related to this `Sto`. */
  offeringPortfolio?: Maybe<Portfolio>;
  offeringPortfolioId: Scalars['String']['output'];
  raisingAssetId: Scalars['String']['output'];
  /** Reads a single `Portfolio` that is related to this `Sto`. */
  raisingPortfolio?: Maybe<Portfolio>;
  raisingPortfolioId: Scalars['String']['output'];
  start?: Maybe<Scalars['Datetime']['output']>;
  status: StoStatus;
  stoId: Scalars['Int']['output'];
  tiers: Scalars['JSON']['output'];
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `Sto`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
  /** Reads a single `Venue` that is related to this `Sto`. */
  venue?: Maybe<Venue>;
  venueId: Scalars['String']['output'];
};

export type StoAggregates = {
  __typename?: 'StoAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A filter to be used against `Sto` object types. All fields are combined with a logical ‘and.’ */
export type StoFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<StoFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `creatorId` field. */
  creatorId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `end` field. */
  end?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `minimumInvestment` field. */
  minimumInvestment?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<StoFilter>;
  /** Filter by the object’s `offeringAssetId` field. */
  offeringAssetId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `offeringPortfolioId` field. */
  offeringPortfolioId?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<StoFilter>>;
  /** Filter by the object’s `raisingAssetId` field. */
  raisingAssetId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `raisingPortfolioId` field. */
  raisingPortfolioId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `start` field. */
  start?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<StoStatusFilter>;
  /** Filter by the object’s `stoId` field. */
  stoId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `tiers` field. */
  tiers?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `venueId` field. */
  venueId?: InputMaybe<StringFilter>;
};

/**  Represents all possible statuses for a STO */
export enum StoStatus {
  Closed = 'Closed',
  ClosedEarly = 'ClosedEarly',
  Frozen = 'Frozen',
  Live = 'Live',
}

/** A filter to be used against StoStatus fields. All fields are combined with a logical ‘and.’ */
export type StoStatusFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<StoStatus>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<StoStatus>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<StoStatus>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<StoStatus>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<StoStatus>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<StoStatus>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<StoStatus>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<StoStatus>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<StoStatus>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<StoStatus>>;
};

/** A connection to a list of `Sto` values. */
export type StosConnection = {
  __typename?: 'StosConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<StoAggregates>;
  /** A list of edges which contains the `Sto` and cursor to aid in pagination. */
  edges: Array<StosEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<StoAggregates>>;
  /** A list of `Sto` objects. */
  nodes: Array<Maybe<Sto>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Sto` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Sto` values. */
export type StosConnectionGroupedAggregatesArgs = {
  groupBy: Array<StosGroupBy>;
  having?: InputMaybe<StosHavingInput>;
};

/** A `Sto` edge in the connection. */
export type StosEdge = {
  __typename?: 'StosEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Sto` at the end of the edge. */
  node?: Maybe<Sto>;
};

/** Grouping methods for `Sto` for usage during aggregation. */
export enum StosGroupBy {
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  CreatorId = 'CREATOR_ID',
  End = 'END',
  MinimumInvestment = 'MINIMUM_INVESTMENT',
  Name = 'NAME',
  OfferingAssetId = 'OFFERING_ASSET_ID',
  OfferingPortfolioId = 'OFFERING_PORTFOLIO_ID',
  RaisingAssetId = 'RAISING_ASSET_ID',
  RaisingPortfolioId = 'RAISING_PORTFOLIO_ID',
  Start = 'START',
  Status = 'STATUS',
  StoId = 'STO_ID',
  Tiers = 'TIERS',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  VenueId = 'VENUE_ID',
}

/** Conditions for `Sto` aggregates. */
export type StosHavingInput = {
  AND?: InputMaybe<Array<StosHavingInput>>;
  OR?: InputMaybe<Array<StosHavingInput>>;
};

/** Methods to use when ordering `Sto`. */
export enum StosOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  CreatorIdAsc = 'CREATOR_ID_ASC',
  CreatorIdDesc = 'CREATOR_ID_DESC',
  EndAsc = 'END_ASC',
  EndDesc = 'END_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MinimumInvestmentAsc = 'MINIMUM_INVESTMENT_ASC',
  MinimumInvestmentDesc = 'MINIMUM_INVESTMENT_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OfferingAssetIdAsc = 'OFFERING_ASSET_ID_ASC',
  OfferingAssetIdDesc = 'OFFERING_ASSET_ID_DESC',
  OfferingPortfolioIdAsc = 'OFFERING_PORTFOLIO_ID_ASC',
  OfferingPortfolioIdDesc = 'OFFERING_PORTFOLIO_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RaisingAssetIdAsc = 'RAISING_ASSET_ID_ASC',
  RaisingAssetIdDesc = 'RAISING_ASSET_ID_DESC',
  RaisingPortfolioIdAsc = 'RAISING_PORTFOLIO_ID_ASC',
  RaisingPortfolioIdDesc = 'RAISING_PORTFOLIO_ID_DESC',
  StartAsc = 'START_ASC',
  StartDesc = 'START_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  StoIdAsc = 'STO_ID_ASC',
  StoIdDesc = 'STO_ID_DESC',
  TiersAsc = 'TIERS_ASC',
  TiersDesc = 'TIERS_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  VenueIdAsc = 'VENUE_ID_ASC',
  VenueIdDesc = 'VENUE_ID_DESC',
}

/** A filter to be used against String fields. All fields are combined with a logical ‘and.’ */
export type StringFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value, treating null like an ordinary value (case-insensitive). */
  distinctFromInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Ends with the specified string (case-sensitive). */
  endsWith?: InputMaybe<Scalars['String']['input']>;
  /** Ends with the specified string (case-insensitive). */
  endsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value (case-insensitive). */
  equalToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['String']['input']>;
  /** Greater than the specified value (case-insensitive). */
  greaterThanInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Greater than or equal to the specified value (case-insensitive). */
  greaterThanOrEqualToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Included in the specified list (case-insensitive). */
  inInsensitive?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Contains the specified string (case-sensitive). */
  includes?: InputMaybe<Scalars['String']['input']>;
  /** Contains the specified string (case-insensitive). */
  includesInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['String']['input']>;
  /** Less than the specified value (case-insensitive). */
  lessThanInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Less than or equal to the specified value (case-insensitive). */
  lessThanOrEqualToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  like?: InputMaybe<Scalars['String']['input']>;
  /** Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  likeInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value, treating null like an ordinary value (case-insensitive). */
  notDistinctFromInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Does not end with the specified string (case-sensitive). */
  notEndsWith?: InputMaybe<Scalars['String']['input']>;
  /** Does not end with the specified string (case-insensitive). */
  notEndsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value (case-insensitive). */
  notEqualToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Not included in the specified list (case-insensitive). */
  notInInsensitive?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Does not contain the specified string (case-sensitive). */
  notIncludes?: InputMaybe<Scalars['String']['input']>;
  /** Does not contain the specified string (case-insensitive). */
  notIncludesInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLike?: InputMaybe<Scalars['String']['input']>;
  /** Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLikeInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Does not start with the specified string (case-sensitive). */
  notStartsWith?: InputMaybe<Scalars['String']['input']>;
  /** Does not start with the specified string (case-insensitive). */
  notStartsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Starts with the specified string (case-sensitive). */
  startsWith?: InputMaybe<Scalars['String']['input']>;
  /** Starts with the specified string (case-insensitive). */
  startsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
};

/** Represents the deployed version of the node indexing the data */
export type SubqueryVersion = Node & {
  __typename?: 'SubqueryVersion';
  createdAt: Scalars['Datetime']['output'];
  id: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  updatedAt: Scalars['Datetime']['output'];
  version: Scalars['String']['output'];
};

export type SubqueryVersionAggregates = {
  __typename?: 'SubqueryVersionAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A filter to be used against `SubqueryVersion` object types. All fields are combined with a logical ‘and.’ */
export type SubqueryVersionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SubqueryVersionFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SubqueryVersionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SubqueryVersionFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `version` field. */
  version?: InputMaybe<StringFilter>;
};

/** A connection to a list of `SubqueryVersion` values. */
export type SubqueryVersionsConnection = {
  __typename?: 'SubqueryVersionsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<SubqueryVersionAggregates>;
  /** A list of edges which contains the `SubqueryVersion` and cursor to aid in pagination. */
  edges: Array<SubqueryVersionsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<SubqueryVersionAggregates>>;
  /** A list of `SubqueryVersion` objects. */
  nodes: Array<Maybe<SubqueryVersion>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SubqueryVersion` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `SubqueryVersion` values. */
export type SubqueryVersionsConnectionGroupedAggregatesArgs = {
  groupBy: Array<SubqueryVersionsGroupBy>;
  having?: InputMaybe<SubqueryVersionsHavingInput>;
};

/** A `SubqueryVersion` edge in the connection. */
export type SubqueryVersionsEdge = {
  __typename?: 'SubqueryVersionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `SubqueryVersion` at the end of the edge. */
  node?: Maybe<SubqueryVersion>;
};

/** Grouping methods for `SubqueryVersion` for usage during aggregation. */
export enum SubqueryVersionsGroupBy {
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
  Version = 'VERSION',
}

/** Conditions for `SubqueryVersion` aggregates. */
export type SubqueryVersionsHavingInput = {
  AND?: InputMaybe<Array<SubqueryVersionsHavingInput>>;
  OR?: InputMaybe<Array<SubqueryVersionsHavingInput>>;
};

/** Methods to use when ordering `SubqueryVersion`. */
export enum SubqueryVersionsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  VersionAsc = 'VERSION_ASC',
  VersionDesc = 'VERSION_DESC',
}

export type TableEstimate = {
  __typename?: 'TableEstimate';
  estimate?: Maybe<Scalars['Int']['output']>;
  table?: Maybe<Scalars['String']['output']>;
};

/** Represents an Identity authorized to perform actions on behalf of a company */
export type TickerExternalAgent = Node & {
  __typename?: 'TickerExternalAgent';
  /** Reads a single `Asset` that is related to this `TickerExternalAgent`. */
  asset?: Maybe<Asset>;
  assetId: Scalars['String']['output'];
  /** Reads a single `Identity` that is related to this `TickerExternalAgent`. */
  caller?: Maybe<Identity>;
  callerId: Scalars['String']['output'];
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `TickerExternalAgent`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  datetime: Scalars['Datetime']['output'];
  eventIdx: Scalars['Int']['output'];
  id: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `TickerExternalAgent`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
};

/** Represents an administrative action on an Asset, e.g. tokens issued, compliance rules updated, document added, etc. */
export type TickerExternalAgentAction = Node & {
  __typename?: 'TickerExternalAgentAction';
  /** Reads a single `Asset` that is related to this `TickerExternalAgentAction`. */
  asset?: Maybe<Asset>;
  assetId: Scalars['String']['output'];
  /** Reads a single `Identity` that is related to this `TickerExternalAgentAction`. */
  caller?: Maybe<Identity>;
  callerId?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `TickerExternalAgentAction`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  eventId: EventIdEnum;
  eventIdx: Scalars['Int']['output'];
  id: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  palletName: Scalars['String']['output'];
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `TickerExternalAgentAction`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
};

export type TickerExternalAgentActionAggregates = {
  __typename?: 'TickerExternalAgentActionAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A filter to be used against `TickerExternalAgentAction` object types. All fields are combined with a logical ‘and.’ */
export type TickerExternalAgentActionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TickerExternalAgentActionFilter>>;
  /** Filter by the object’s `assetId` field. */
  assetId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `callerId` field. */
  callerId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `eventId` field. */
  eventId?: InputMaybe<EventIdEnumFilter>;
  /** Filter by the object’s `eventIdx` field. */
  eventIdx?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TickerExternalAgentActionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TickerExternalAgentActionFilter>>;
  /** Filter by the object’s `palletName` field. */
  palletName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
};

/** A connection to a list of `TickerExternalAgentAction` values. */
export type TickerExternalAgentActionsConnection = {
  __typename?: 'TickerExternalAgentActionsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<TickerExternalAgentActionAggregates>;
  /** A list of edges which contains the `TickerExternalAgentAction` and cursor to aid in pagination. */
  edges: Array<TickerExternalAgentActionsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<TickerExternalAgentActionAggregates>>;
  /** A list of `TickerExternalAgentAction` objects. */
  nodes: Array<Maybe<TickerExternalAgentAction>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TickerExternalAgentAction` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `TickerExternalAgentAction` values. */
export type TickerExternalAgentActionsConnectionGroupedAggregatesArgs = {
  groupBy: Array<TickerExternalAgentActionsGroupBy>;
  having?: InputMaybe<TickerExternalAgentActionsHavingInput>;
};

/** A `TickerExternalAgentAction` edge in the connection. */
export type TickerExternalAgentActionsEdge = {
  __typename?: 'TickerExternalAgentActionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TickerExternalAgentAction` at the end of the edge. */
  node?: Maybe<TickerExternalAgentAction>;
};

/** Grouping methods for `TickerExternalAgentAction` for usage during aggregation. */
export enum TickerExternalAgentActionsGroupBy {
  AssetId = 'ASSET_ID',
  CallerId = 'CALLER_ID',
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  EventId = 'EVENT_ID',
  EventIdx = 'EVENT_IDX',
  PalletName = 'PALLET_NAME',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
}

/** Conditions for `TickerExternalAgentAction` aggregates. */
export type TickerExternalAgentActionsHavingInput = {
  AND?: InputMaybe<Array<TickerExternalAgentActionsHavingInput>>;
  OR?: InputMaybe<Array<TickerExternalAgentActionsHavingInput>>;
};

/** Methods to use when ordering `TickerExternalAgentAction`. */
export enum TickerExternalAgentActionsOrderBy {
  AssetIdAsc = 'ASSET_ID_ASC',
  AssetIdDesc = 'ASSET_ID_DESC',
  CallerIdAsc = 'CALLER_ID_ASC',
  CallerIdDesc = 'CALLER_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  EventIdxAsc = 'EVENT_IDX_ASC',
  EventIdxDesc = 'EVENT_IDX_DESC',
  EventIdAsc = 'EVENT_ID_ASC',
  EventIdDesc = 'EVENT_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PalletNameAsc = 'PALLET_NAME_ASC',
  PalletNameDesc = 'PALLET_NAME_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
}

export type TickerExternalAgentAggregates = {
  __typename?: 'TickerExternalAgentAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A filter to be used against `TickerExternalAgent` object types. All fields are combined with a logical ‘and.’ */
export type TickerExternalAgentFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TickerExternalAgentFilter>>;
  /** Filter by the object’s `assetId` field. */
  assetId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `callerId` field. */
  callerId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `datetime` field. */
  datetime?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `eventIdx` field. */
  eventIdx?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TickerExternalAgentFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TickerExternalAgentFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
};

/** A connection to a list of `TickerExternalAgentHistory` values. */
export type TickerExternalAgentHistoriesConnection = {
  __typename?: 'TickerExternalAgentHistoriesConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<TickerExternalAgentHistoryAggregates>;
  /** A list of edges which contains the `TickerExternalAgentHistory` and cursor to aid in pagination. */
  edges: Array<TickerExternalAgentHistoriesEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<TickerExternalAgentHistoryAggregates>>;
  /** A list of `TickerExternalAgentHistory` objects. */
  nodes: Array<Maybe<TickerExternalAgentHistory>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TickerExternalAgentHistory` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `TickerExternalAgentHistory` values. */
export type TickerExternalAgentHistoriesConnectionGroupedAggregatesArgs = {
  groupBy: Array<TickerExternalAgentHistoriesGroupBy>;
  having?: InputMaybe<TickerExternalAgentHistoriesHavingInput>;
};

/** A `TickerExternalAgentHistory` edge in the connection. */
export type TickerExternalAgentHistoriesEdge = {
  __typename?: 'TickerExternalAgentHistoriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TickerExternalAgentHistory` at the end of the edge. */
  node?: Maybe<TickerExternalAgentHistory>;
};

/** Grouping methods for `TickerExternalAgentHistory` for usage during aggregation. */
export enum TickerExternalAgentHistoriesGroupBy {
  AssetId = 'ASSET_ID',
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  Datetime = 'DATETIME',
  EventIdx = 'EVENT_IDX',
  IdentityId = 'IDENTITY_ID',
  Permissions = 'PERMISSIONS',
  Type = 'TYPE',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
}

/** Conditions for `TickerExternalAgentHistory` aggregates. */
export type TickerExternalAgentHistoriesHavingInput = {
  AND?: InputMaybe<Array<TickerExternalAgentHistoriesHavingInput>>;
  OR?: InputMaybe<Array<TickerExternalAgentHistoriesHavingInput>>;
};

/** Methods to use when ordering `TickerExternalAgentHistory`. */
export enum TickerExternalAgentHistoriesOrderBy {
  AssetIdAsc = 'ASSET_ID_ASC',
  AssetIdDesc = 'ASSET_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  DatetimeAsc = 'DATETIME_ASC',
  DatetimeDesc = 'DATETIME_DESC',
  EventIdxAsc = 'EVENT_IDX_ASC',
  EventIdxDesc = 'EVENT_IDX_DESC',
  IdentityIdAsc = 'IDENTITY_ID_ASC',
  IdentityIdDesc = 'IDENTITY_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PermissionsAsc = 'PERMISSIONS_ASC',
  PermissionsDesc = 'PERMISSIONS_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
}

/**
 * Represents a change in the status of an external agent.
 *
 * "AgentAdded" and "AgentPermissionsChanged" will have `permissions` field. `AgentRemoved` will have an empty `permissions` value
 */
export type TickerExternalAgentHistory = Node & {
  __typename?: 'TickerExternalAgentHistory';
  /** Reads a single `Asset` that is related to this `TickerExternalAgentHistory`. */
  asset?: Maybe<Asset>;
  assetId: Scalars['String']['output'];
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `TickerExternalAgentHistory`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  datetime: Scalars['Datetime']['output'];
  eventIdx: Scalars['Int']['output'];
  id: Scalars['String']['output'];
  /** Reads a single `Identity` that is related to this `TickerExternalAgentHistory`. */
  identity?: Maybe<Identity>;
  identityId: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  permissions?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `TickerExternalAgentHistory`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
};

export type TickerExternalAgentHistoryAggregates = {
  __typename?: 'TickerExternalAgentHistoryAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A filter to be used against `TickerExternalAgentHistory` object types. All fields are combined with a logical ‘and.’ */
export type TickerExternalAgentHistoryFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TickerExternalAgentHistoryFilter>>;
  /** Filter by the object’s `assetId` field. */
  assetId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `datetime` field. */
  datetime?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `eventIdx` field. */
  eventIdx?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `identityId` field. */
  identityId?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TickerExternalAgentHistoryFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TickerExternalAgentHistoryFilter>>;
  /** Filter by the object’s `permissions` field. */
  permissions?: InputMaybe<StringFilter>;
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
};

/** A connection to a list of `TickerExternalAgent` values. */
export type TickerExternalAgentsConnection = {
  __typename?: 'TickerExternalAgentsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<TickerExternalAgentAggregates>;
  /** A list of edges which contains the `TickerExternalAgent` and cursor to aid in pagination. */
  edges: Array<TickerExternalAgentsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<TickerExternalAgentAggregates>>;
  /** A list of `TickerExternalAgent` objects. */
  nodes: Array<Maybe<TickerExternalAgent>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TickerExternalAgent` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `TickerExternalAgent` values. */
export type TickerExternalAgentsConnectionGroupedAggregatesArgs = {
  groupBy: Array<TickerExternalAgentsGroupBy>;
  having?: InputMaybe<TickerExternalAgentsHavingInput>;
};

/** A `TickerExternalAgent` edge in the connection. */
export type TickerExternalAgentsEdge = {
  __typename?: 'TickerExternalAgentsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TickerExternalAgent` at the end of the edge. */
  node?: Maybe<TickerExternalAgent>;
};

/** Grouping methods for `TickerExternalAgent` for usage during aggregation. */
export enum TickerExternalAgentsGroupBy {
  AssetId = 'ASSET_ID',
  CallerId = 'CALLER_ID',
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  Datetime = 'DATETIME',
  EventIdx = 'EVENT_IDX',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
}

/** Conditions for `TickerExternalAgent` aggregates. */
export type TickerExternalAgentsHavingInput = {
  AND?: InputMaybe<Array<TickerExternalAgentsHavingInput>>;
  OR?: InputMaybe<Array<TickerExternalAgentsHavingInput>>;
};

/** Methods to use when ordering `TickerExternalAgent`. */
export enum TickerExternalAgentsOrderBy {
  AssetIdAsc = 'ASSET_ID_ASC',
  AssetIdDesc = 'ASSET_ID_DESC',
  CallerIdAsc = 'CALLER_ID_ASC',
  CallerIdDesc = 'CALLER_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  DatetimeAsc = 'DATETIME_ASC',
  DatetimeDesc = 'DATETIME_DESC',
  EventIdxAsc = 'EVENT_IDX_ASC',
  EventIdxDesc = 'EVENT_IDX_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
}

/**
 * Represents restriction that will ensure the composition of ownership remains a certain way
 *
 * e.g. No more than 2000 individual investors to avoid additional reporting requirements
 */
export type TransferCompliance = Node & {
  __typename?: 'TransferCompliance';
  /** Reads a single `Asset` that is related to this `TransferCompliance`. */
  asset?: Maybe<Asset>;
  assetId: Scalars['String']['output'];
  /** Reads a single `Identity` that is related to this `TransferCompliance`. */
  claimIssuer?: Maybe<Identity>;
  claimIssuerId?: Maybe<Scalars['String']['output']>;
  claimType?: Maybe<ClaimTypeEnum>;
  claimValue?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `TransferCompliance`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  id: Scalars['String']['output'];
  max?: Maybe<Scalars['BigFloat']['output']>;
  min?: Maybe<Scalars['BigFloat']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `StatType` that is related to this `TransferCompliance`. */
  statType?: Maybe<StatType>;
  statTypeId: Scalars['String']['output'];
  type: TransferComplianceTypeEnum;
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `TransferCompliance`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
  value?: Maybe<Scalars['BigFloat']['output']>;
};

export type TransferComplianceAggregates = {
  __typename?: 'TransferComplianceAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** Represents an exemption for an individual for TransferCompliance rules */
export type TransferComplianceExemption = Node & {
  __typename?: 'TransferComplianceExemption';
  /** Reads a single `Asset` that is related to this `TransferComplianceExemption`. */
  asset?: Maybe<Asset>;
  assetId: Scalars['String']['output'];
  claimType?: Maybe<ClaimTypeEnum>;
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `TransferComplianceExemption`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  exemptedEntityId: Scalars['String']['output'];
  id: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  opType: StatOpTypeEnum;
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `TransferComplianceExemption`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
};

export type TransferComplianceExemptionAggregates = {
  __typename?: 'TransferComplianceExemptionAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A filter to be used against `TransferComplianceExemption` object types. All fields are combined with a logical ‘and.’ */
export type TransferComplianceExemptionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TransferComplianceExemptionFilter>>;
  /** Filter by the object’s `assetId` field. */
  assetId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `claimType` field. */
  claimType?: InputMaybe<ClaimTypeEnumFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `exemptedEntityId` field. */
  exemptedEntityId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TransferComplianceExemptionFilter>;
  /** Filter by the object’s `opType` field. */
  opType?: InputMaybe<StatOpTypeEnumFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TransferComplianceExemptionFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
};

/** A connection to a list of `TransferComplianceExemption` values. */
export type TransferComplianceExemptionsConnection = {
  __typename?: 'TransferComplianceExemptionsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<TransferComplianceExemptionAggregates>;
  /** A list of edges which contains the `TransferComplianceExemption` and cursor to aid in pagination. */
  edges: Array<TransferComplianceExemptionsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<TransferComplianceExemptionAggregates>>;
  /** A list of `TransferComplianceExemption` objects. */
  nodes: Array<Maybe<TransferComplianceExemption>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TransferComplianceExemption` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `TransferComplianceExemption` values. */
export type TransferComplianceExemptionsConnectionGroupedAggregatesArgs = {
  groupBy: Array<TransferComplianceExemptionsGroupBy>;
  having?: InputMaybe<TransferComplianceExemptionsHavingInput>;
};

/** A `TransferComplianceExemption` edge in the connection. */
export type TransferComplianceExemptionsEdge = {
  __typename?: 'TransferComplianceExemptionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TransferComplianceExemption` at the end of the edge. */
  node?: Maybe<TransferComplianceExemption>;
};

/** Grouping methods for `TransferComplianceExemption` for usage during aggregation. */
export enum TransferComplianceExemptionsGroupBy {
  AssetId = 'ASSET_ID',
  ClaimType = 'CLAIM_TYPE',
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  ExemptedEntityId = 'EXEMPTED_ENTITY_ID',
  OpType = 'OP_TYPE',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
}

/** Conditions for `TransferComplianceExemption` aggregates. */
export type TransferComplianceExemptionsHavingInput = {
  AND?: InputMaybe<Array<TransferComplianceExemptionsHavingInput>>;
  OR?: InputMaybe<Array<TransferComplianceExemptionsHavingInput>>;
};

/** Methods to use when ordering `TransferComplianceExemption`. */
export enum TransferComplianceExemptionsOrderBy {
  AssetIdAsc = 'ASSET_ID_ASC',
  AssetIdDesc = 'ASSET_ID_DESC',
  ClaimTypeAsc = 'CLAIM_TYPE_ASC',
  ClaimTypeDesc = 'CLAIM_TYPE_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  ExemptedEntityIdAsc = 'EXEMPTED_ENTITY_ID_ASC',
  ExemptedEntityIdDesc = 'EXEMPTED_ENTITY_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  OpTypeAsc = 'OP_TYPE_ASC',
  OpTypeDesc = 'OP_TYPE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
}

/** A filter to be used against `TransferCompliance` object types. All fields are combined with a logical ‘and.’ */
export type TransferComplianceFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TransferComplianceFilter>>;
  /** Filter by the object’s `assetId` field. */
  assetId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `claimIssuerId` field. */
  claimIssuerId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `claimType` field. */
  claimType?: InputMaybe<ClaimTypeEnumFilter>;
  /** Filter by the object’s `claimValue` field. */
  claimValue?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `max` field. */
  max?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `min` field. */
  min?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TransferComplianceFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TransferComplianceFilter>>;
  /** Filter by the object’s `statTypeId` field. */
  statTypeId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<TransferComplianceTypeEnumFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `value` field. */
  value?: InputMaybe<BigFloatFilter>;
};

/**  Represents all possible transfer restriction rules that can be enabled */
export enum TransferComplianceTypeEnum {
  ClaimCount = 'ClaimCount',
  ClaimOwnership = 'ClaimOwnership',
  MaxInvestorCount = 'MaxInvestorCount',
  MaxInvestorOwnership = 'MaxInvestorOwnership',
}

/** A filter to be used against TransferComplianceTypeEnum fields. All fields are combined with a logical ‘and.’ */
export type TransferComplianceTypeEnumFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<TransferComplianceTypeEnum>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<TransferComplianceTypeEnum>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<TransferComplianceTypeEnum>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<TransferComplianceTypeEnum>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<TransferComplianceTypeEnum>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<TransferComplianceTypeEnum>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<TransferComplianceTypeEnum>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<TransferComplianceTypeEnum>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<TransferComplianceTypeEnum>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<TransferComplianceTypeEnum>>;
};

/** A connection to a list of `TransferCompliance` values. */
export type TransferCompliancesConnection = {
  __typename?: 'TransferCompliancesConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<TransferComplianceAggregates>;
  /** A list of edges which contains the `TransferCompliance` and cursor to aid in pagination. */
  edges: Array<TransferCompliancesEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<TransferComplianceAggregates>>;
  /** A list of `TransferCompliance` objects. */
  nodes: Array<Maybe<TransferCompliance>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TransferCompliance` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `TransferCompliance` values. */
export type TransferCompliancesConnectionGroupedAggregatesArgs = {
  groupBy: Array<TransferCompliancesGroupBy>;
  having?: InputMaybe<TransferCompliancesHavingInput>;
};

/** A `TransferCompliance` edge in the connection. */
export type TransferCompliancesEdge = {
  __typename?: 'TransferCompliancesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TransferCompliance` at the end of the edge. */
  node?: Maybe<TransferCompliance>;
};

/** Grouping methods for `TransferCompliance` for usage during aggregation. */
export enum TransferCompliancesGroupBy {
  AssetId = 'ASSET_ID',
  ClaimIssuerId = 'CLAIM_ISSUER_ID',
  ClaimType = 'CLAIM_TYPE',
  ClaimValue = 'CLAIM_VALUE',
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  Max = 'MAX',
  Min = 'MIN',
  StatTypeId = 'STAT_TYPE_ID',
  Type = 'TYPE',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  Value = 'VALUE',
}

/** Conditions for `TransferCompliance` aggregates. */
export type TransferCompliancesHavingInput = {
  AND?: InputMaybe<Array<TransferCompliancesHavingInput>>;
  OR?: InputMaybe<Array<TransferCompliancesHavingInput>>;
};

/** Methods to use when ordering `TransferCompliance`. */
export enum TransferCompliancesOrderBy {
  AssetIdAsc = 'ASSET_ID_ASC',
  AssetIdDesc = 'ASSET_ID_DESC',
  ClaimIssuerIdAsc = 'CLAIM_ISSUER_ID_ASC',
  ClaimIssuerIdDesc = 'CLAIM_ISSUER_ID_DESC',
  ClaimTypeAsc = 'CLAIM_TYPE_ASC',
  ClaimTypeDesc = 'CLAIM_TYPE_DESC',
  ClaimValueAsc = 'CLAIM_VALUE_ASC',
  ClaimValueDesc = 'CLAIM_VALUE_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MaxAsc = 'MAX_ASC',
  MaxDesc = 'MAX_DESC',
  MinAsc = 'MIN_ASC',
  MinDesc = 'MIN_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  StatTypeIdAsc = 'STAT_TYPE_ID_ASC',
  StatTypeIdDesc = 'STAT_TYPE_ID_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  ValueAsc = 'VALUE_ASC',
  ValueDesc = 'VALUE_DESC',
}

/** deprecated in favor of `TransferCompliance` */
export type TransferManager = Node & {
  __typename?: 'TransferManager';
  /** Reads a single `Asset` that is related to this `TransferManager`. */
  asset?: Maybe<Asset>;
  assetId: Scalars['String']['output'];
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `TransferManager`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  exemptedEntities: Scalars['JSON']['output'];
  id: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  type: TransferRestrictionTypeEnum;
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `TransferManager`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
  value: Scalars['Int']['output'];
};

export type TransferManagerAggregates = {
  __typename?: 'TransferManagerAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A filter to be used against `TransferManager` object types. All fields are combined with a logical ‘and.’ */
export type TransferManagerFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TransferManagerFilter>>;
  /** Filter by the object’s `assetId` field. */
  assetId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `exemptedEntities` field. */
  exemptedEntities?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TransferManagerFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TransferManagerFilter>>;
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<TransferRestrictionTypeEnumFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `value` field. */
  value?: InputMaybe<IntFilter>;
};

/** A connection to a list of `TransferManager` values. */
export type TransferManagersConnection = {
  __typename?: 'TransferManagersConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<TransferManagerAggregates>;
  /** A list of edges which contains the `TransferManager` and cursor to aid in pagination. */
  edges: Array<TransferManagersEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<TransferManagerAggregates>>;
  /** A list of `TransferManager` objects. */
  nodes: Array<Maybe<TransferManager>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TransferManager` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `TransferManager` values. */
export type TransferManagersConnectionGroupedAggregatesArgs = {
  groupBy: Array<TransferManagersGroupBy>;
  having?: InputMaybe<TransferManagersHavingInput>;
};

/** A `TransferManager` edge in the connection. */
export type TransferManagersEdge = {
  __typename?: 'TransferManagersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TransferManager` at the end of the edge. */
  node?: Maybe<TransferManager>;
};

/** Grouping methods for `TransferManager` for usage during aggregation. */
export enum TransferManagersGroupBy {
  AssetId = 'ASSET_ID',
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  ExemptedEntities = 'EXEMPTED_ENTITIES',
  Type = 'TYPE',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  Value = 'VALUE',
}

/** Conditions for `TransferManager` aggregates. */
export type TransferManagersHavingInput = {
  AND?: InputMaybe<Array<TransferManagersHavingInput>>;
  OR?: InputMaybe<Array<TransferManagersHavingInput>>;
};

/** Methods to use when ordering `TransferManager`. */
export enum TransferManagersOrderBy {
  AssetIdAsc = 'ASSET_ID_ASC',
  AssetIdDesc = 'ASSET_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  ExemptedEntitiesAsc = 'EXEMPTED_ENTITIES_ASC',
  ExemptedEntitiesDesc = 'EXEMPTED_ENTITIES_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  ValueAsc = 'VALUE_ASC',
  ValueDesc = 'VALUE_DESC',
}

/**  Represents all possible transfer restriction types */
export enum TransferRestrictionTypeEnum {
  Count = 'Count',
  Percentage = 'Percentage',
}

/** A filter to be used against TransferRestrictionTypeEnum fields. All fields are combined with a logical ‘and.’ */
export type TransferRestrictionTypeEnumFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<TransferRestrictionTypeEnum>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<TransferRestrictionTypeEnum>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<TransferRestrictionTypeEnum>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<TransferRestrictionTypeEnum>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<TransferRestrictionTypeEnum>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<TransferRestrictionTypeEnum>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<TransferRestrictionTypeEnum>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<TransferRestrictionTypeEnum>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<TransferRestrictionTypeEnum>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<TransferRestrictionTypeEnum>>;
};

/**
 * An claim issuer that is trusted for an Asset.
 *
 * Assets relying on on chain compliance should be explicit on which issuers they trust
 */
export type TrustedClaimIssuer = Node & {
  __typename?: 'TrustedClaimIssuer';
  /** Reads a single `Asset` that is related to this `TrustedClaimIssuer`. */
  asset?: Maybe<Asset>;
  assetId: Scalars['String']['output'];
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `TrustedClaimIssuer`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  eventIdx: Scalars['Int']['output'];
  id: Scalars['String']['output'];
  issuer: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `TrustedClaimIssuer`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
};

export type TrustedClaimIssuerAggregates = {
  __typename?: 'TrustedClaimIssuerAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A filter to be used against `TrustedClaimIssuer` object types. All fields are combined with a logical ‘and.’ */
export type TrustedClaimIssuerFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TrustedClaimIssuerFilter>>;
  /** Filter by the object’s `assetId` field. */
  assetId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `eventIdx` field. */
  eventIdx?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `issuer` field. */
  issuer?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TrustedClaimIssuerFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TrustedClaimIssuerFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
};

/** A connection to a list of `TrustedClaimIssuer` values. */
export type TrustedClaimIssuersConnection = {
  __typename?: 'TrustedClaimIssuersConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<TrustedClaimIssuerAggregates>;
  /** A list of edges which contains the `TrustedClaimIssuer` and cursor to aid in pagination. */
  edges: Array<TrustedClaimIssuersEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<TrustedClaimIssuerAggregates>>;
  /** A list of `TrustedClaimIssuer` objects. */
  nodes: Array<Maybe<TrustedClaimIssuer>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TrustedClaimIssuer` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `TrustedClaimIssuer` values. */
export type TrustedClaimIssuersConnectionGroupedAggregatesArgs = {
  groupBy: Array<TrustedClaimIssuersGroupBy>;
  having?: InputMaybe<TrustedClaimIssuersHavingInput>;
};

/** A `TrustedClaimIssuer` edge in the connection. */
export type TrustedClaimIssuersEdge = {
  __typename?: 'TrustedClaimIssuersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TrustedClaimIssuer` at the end of the edge. */
  node?: Maybe<TrustedClaimIssuer>;
};

/** Grouping methods for `TrustedClaimIssuer` for usage during aggregation. */
export enum TrustedClaimIssuersGroupBy {
  AssetId = 'ASSET_ID',
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  EventIdx = 'EVENT_IDX',
  Issuer = 'ISSUER',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
}

/** Conditions for `TrustedClaimIssuer` aggregates. */
export type TrustedClaimIssuersHavingInput = {
  AND?: InputMaybe<Array<TrustedClaimIssuersHavingInput>>;
  OR?: InputMaybe<Array<TrustedClaimIssuersHavingInput>>;
};

/** Methods to use when ordering `TrustedClaimIssuer`. */
export enum TrustedClaimIssuersOrderBy {
  AssetIdAsc = 'ASSET_ID_ASC',
  AssetIdDesc = 'ASSET_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  EventIdxAsc = 'EVENT_IDX_ASC',
  EventIdxDesc = 'EVENT_IDX_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IssuerAsc = 'ISSUER_ASC',
  IssuerDesc = 'ISSUER_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
}

/**
 * Represents a place to trade assets. This allows for additional mediation and control over the exchange of Assets
 *
 * e.g. An asset may specify it can only be exchanged at a particular Venue, allowing the Venue owner to explicitly approve transactions
 */
export type Venue = Node & {
  __typename?: 'Venue';
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByStoVenueIdAndOfferingAssetId: VenueAssetsByStoVenueIdAndOfferingAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByInstructionVenueIdAndCreatedBlockId: VenueBlocksByInstructionVenueIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByInstructionVenueIdAndUpdatedBlockId: VenueBlocksByInstructionVenueIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByStoVenueIdAndCreatedBlockId: VenueBlocksByStoVenueIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByStoVenueIdAndUpdatedBlockId: VenueBlocksByStoVenueIdAndUpdatedBlockIdManyToManyConnection;
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `Venue`. */
  createdBlock?: Maybe<Block>;
  createdBlockId: Scalars['String']['output'];
  details?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByStoVenueIdAndCreatorId: VenueIdentitiesByStoVenueIdAndCreatorIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Instruction`. */
  instructions: InstructionsConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Identity` that is related to this `Venue`. */
  owner?: Maybe<Identity>;
  ownerId: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByStoVenueIdAndOfferingPortfolioId: VenuePortfoliosByStoVenueIdAndOfferingPortfolioIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByStoVenueIdAndRaisingPortfolioId: VenuePortfoliosByStoVenueIdAndRaisingPortfolioIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Sto`. */
  stos: StosConnection;
  type: Scalars['String']['output'];
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `Block` that is related to this `Venue`. */
  updatedBlock?: Maybe<Block>;
  updatedBlockId: Scalars['String']['output'];
};

/**
 * Represents a place to trade assets. This allows for additional mediation and control over the exchange of Assets
 *
 * e.g. An asset may specify it can only be exchanged at a particular Venue, allowing the Venue owner to explicitly approve transactions
 */
export type VenueAssetsByStoVenueIdAndOfferingAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssetsOrderBy>>;
};

/**
 * Represents a place to trade assets. This allows for additional mediation and control over the exchange of Assets
 *
 * e.g. An asset may specify it can only be exchanged at a particular Venue, allowing the Venue owner to explicitly approve transactions
 */
export type VenueBlocksByInstructionVenueIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a place to trade assets. This allows for additional mediation and control over the exchange of Assets
 *
 * e.g. An asset may specify it can only be exchanged at a particular Venue, allowing the Venue owner to explicitly approve transactions
 */
export type VenueBlocksByInstructionVenueIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a place to trade assets. This allows for additional mediation and control over the exchange of Assets
 *
 * e.g. An asset may specify it can only be exchanged at a particular Venue, allowing the Venue owner to explicitly approve transactions
 */
export type VenueBlocksByStoVenueIdAndCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a place to trade assets. This allows for additional mediation and control over the exchange of Assets
 *
 * e.g. An asset may specify it can only be exchanged at a particular Venue, allowing the Venue owner to explicitly approve transactions
 */
export type VenueBlocksByStoVenueIdAndUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};

/**
 * Represents a place to trade assets. This allows for additional mediation and control over the exchange of Assets
 *
 * e.g. An asset may specify it can only be exchanged at a particular Venue, allowing the Venue owner to explicitly approve transactions
 */
export type VenueIdentitiesByStoVenueIdAndCreatorIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<IdentityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentitiesOrderBy>>;
};

/**
 * Represents a place to trade assets. This allows for additional mediation and control over the exchange of Assets
 *
 * e.g. An asset may specify it can only be exchanged at a particular Venue, allowing the Venue owner to explicitly approve transactions
 */
export type VenueInstructionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<InstructionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InstructionsOrderBy>>;
};

/**
 * Represents a place to trade assets. This allows for additional mediation and control over the exchange of Assets
 *
 * e.g. An asset may specify it can only be exchanged at a particular Venue, allowing the Venue owner to explicitly approve transactions
 */
export type VenuePortfoliosByStoVenueIdAndOfferingPortfolioIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/**
 * Represents a place to trade assets. This allows for additional mediation and control over the exchange of Assets
 *
 * e.g. An asset may specify it can only be exchanged at a particular Venue, allowing the Venue owner to explicitly approve transactions
 */
export type VenuePortfoliosByStoVenueIdAndRaisingPortfolioIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PortfolioFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PortfoliosOrderBy>>;
};

/**
 * Represents a place to trade assets. This allows for additional mediation and control over the exchange of Assets
 *
 * e.g. An asset may specify it can only be exchanged at a particular Venue, allowing the Venue owner to explicitly approve transactions
 */
export type VenueStosArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StoFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StosOrderBy>>;
};

export type VenueAggregates = {
  __typename?: 'VenueAggregates';
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A connection to a list of `Asset` values, with data from `Sto`. */
export type VenueAssetsByStoVenueIdAndOfferingAssetIdManyToManyConnection = {
  __typename?: 'VenueAssetsByStoVenueIdAndOfferingAssetIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** A list of edges which contains the `Asset`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<VenueAssetsByStoVenueIdAndOfferingAssetIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Asset` values, with data from `Sto`. */
export type VenueAssetsByStoVenueIdAndOfferingAssetIdManyToManyConnectionGroupedAggregatesArgs = {
  groupBy: Array<AssetsGroupBy>;
  having?: InputMaybe<AssetsHavingInput>;
};

/** A `Asset` edge in the connection, with data from `Sto`. */
export type VenueAssetsByStoVenueIdAndOfferingAssetIdManyToManyEdge = {
  __typename?: 'VenueAssetsByStoVenueIdAndOfferingAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByOfferingAssetId: StosConnection;
};

/** A `Asset` edge in the connection, with data from `Sto`. */
export type VenueAssetsByStoVenueIdAndOfferingAssetIdManyToManyEdgeStosByOfferingAssetIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StoFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StosOrderBy>>;
};

/** A connection to a list of `Block` values, with data from `Instruction`. */
export type VenueBlocksByInstructionVenueIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'VenueBlocksByInstructionVenueIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Instruction`, and the cursor to aid in pagination. */
  edges: Array<VenueBlocksByInstructionVenueIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Instruction`. */
export type VenueBlocksByInstructionVenueIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Instruction`. */
export type VenueBlocksByInstructionVenueIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'VenueBlocksByInstructionVenueIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Instruction`. */
  instructionsByCreatedBlockId: InstructionsConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Instruction`. */
export type VenueBlocksByInstructionVenueIdAndCreatedBlockIdManyToManyEdgeInstructionsByCreatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<InstructionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<InstructionsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Instruction`. */
export type VenueBlocksByInstructionVenueIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'VenueBlocksByInstructionVenueIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Instruction`, and the cursor to aid in pagination. */
  edges: Array<VenueBlocksByInstructionVenueIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Instruction`. */
export type VenueBlocksByInstructionVenueIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: InputMaybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Instruction`. */
export type VenueBlocksByInstructionVenueIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'VenueBlocksByInstructionVenueIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Instruction`. */
  instructionsByUpdatedBlockId: InstructionsConnection;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** A `Block` edge in the connection, with data from `Instruction`. */
export type VenueBlocksByInstructionVenueIdAndUpdatedBlockIdManyToManyEdgeInstructionsByUpdatedBlockIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<InstructionFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<InstructionsOrderBy>>;
  };

/** A connection to a list of `Block` values, with data from `Sto`. */
export type VenueBlocksByStoVenueIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'VenueBlocksByStoVenueIdAndCreatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<VenueBlocksByStoVenueIdAndCreatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Sto`. */
export type VenueBlocksByStoVenueIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs = {
  groupBy: Array<BlocksGroupBy>;
  having?: InputMaybe<BlocksHavingInput>;
};

/** A `Block` edge in the connection, with data from `Sto`. */
export type VenueBlocksByStoVenueIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'VenueBlocksByStoVenueIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByCreatedBlockId: StosConnection;
};

/** A `Block` edge in the connection, with data from `Sto`. */
export type VenueBlocksByStoVenueIdAndCreatedBlockIdManyToManyEdgeStosByCreatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StoFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StosOrderBy>>;
};

/** A connection to a list of `Block` values, with data from `Sto`. */
export type VenueBlocksByStoVenueIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'VenueBlocksByStoVenueIdAndUpdatedBlockIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<VenueBlocksByStoVenueIdAndUpdatedBlockIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Block` values, with data from `Sto`. */
export type VenueBlocksByStoVenueIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs = {
  groupBy: Array<BlocksGroupBy>;
  having?: InputMaybe<BlocksHavingInput>;
};

/** A `Block` edge in the connection, with data from `Sto`. */
export type VenueBlocksByStoVenueIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'VenueBlocksByStoVenueIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByUpdatedBlockId: StosConnection;
};

/** A `Block` edge in the connection, with data from `Sto`. */
export type VenueBlocksByStoVenueIdAndUpdatedBlockIdManyToManyEdgeStosByUpdatedBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StoFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StosOrderBy>>;
};

/** A filter to be used against `Venue` object types. All fields are combined with a logical ‘and.’ */
export type VenueFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<VenueFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `details` field. */
  details?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<VenueFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<VenueFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: InputMaybe<StringFilter>;
};

/** A connection to a list of `Identity` values, with data from `Sto`. */
export type VenueIdentitiesByStoVenueIdAndCreatorIdManyToManyConnection = {
  __typename?: 'VenueIdentitiesByStoVenueIdAndCreatorIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** A list of edges which contains the `Identity`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<VenueIdentitiesByStoVenueIdAndCreatorIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Identity` values, with data from `Sto`. */
export type VenueIdentitiesByStoVenueIdAndCreatorIdManyToManyConnectionGroupedAggregatesArgs = {
  groupBy: Array<IdentitiesGroupBy>;
  having?: InputMaybe<IdentitiesHavingInput>;
};

/** A `Identity` edge in the connection, with data from `Sto`. */
export type VenueIdentitiesByStoVenueIdAndCreatorIdManyToManyEdge = {
  __typename?: 'VenueIdentitiesByStoVenueIdAndCreatorIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByCreatorId: StosConnection;
};

/** A `Identity` edge in the connection, with data from `Sto`. */
export type VenueIdentitiesByStoVenueIdAndCreatorIdManyToManyEdgeStosByCreatorIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StoFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StosOrderBy>>;
};

/** A connection to a list of `Portfolio` values, with data from `Sto`. */
export type VenuePortfoliosByStoVenueIdAndOfferingPortfolioIdManyToManyConnection = {
  __typename?: 'VenuePortfoliosByStoVenueIdAndOfferingPortfolioIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<VenuePortfoliosByStoVenueIdAndOfferingPortfolioIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `Sto`. */
export type VenuePortfoliosByStoVenueIdAndOfferingPortfolioIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: InputMaybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `Sto`. */
export type VenuePortfoliosByStoVenueIdAndOfferingPortfolioIdManyToManyEdge = {
  __typename?: 'VenuePortfoliosByStoVenueIdAndOfferingPortfolioIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByOfferingPortfolioId: StosConnection;
};

/** A `Portfolio` edge in the connection, with data from `Sto`. */
export type VenuePortfoliosByStoVenueIdAndOfferingPortfolioIdManyToManyEdgeStosByOfferingPortfolioIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StoFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StosOrderBy>>;
  };

/** A connection to a list of `Portfolio` values, with data from `Sto`. */
export type VenuePortfoliosByStoVenueIdAndRaisingPortfolioIdManyToManyConnection = {
  __typename?: 'VenuePortfoliosByStoVenueIdAndRaisingPortfolioIdManyToManyConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** A list of edges which contains the `Portfolio`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<VenuePortfoliosByStoVenueIdAndRaisingPortfolioIdManyToManyEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Portfolio` values, with data from `Sto`. */
export type VenuePortfoliosByStoVenueIdAndRaisingPortfolioIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: InputMaybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `Sto`. */
export type VenuePortfoliosByStoVenueIdAndRaisingPortfolioIdManyToManyEdge = {
  __typename?: 'VenuePortfoliosByStoVenueIdAndRaisingPortfolioIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByRaisingPortfolioId: StosConnection;
};

/** A `Portfolio` edge in the connection, with data from `Sto`. */
export type VenuePortfoliosByStoVenueIdAndRaisingPortfolioIdManyToManyEdgeStosByRaisingPortfolioIdArgs =
  {
    after?: InputMaybe<Scalars['Cursor']['input']>;
    before?: InputMaybe<Scalars['Cursor']['input']>;
    filter?: InputMaybe<StoFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    orderBy?: InputMaybe<Array<StosOrderBy>>;
  };

/** A connection to a list of `Venue` values. */
export type VenuesConnection = {
  __typename?: 'VenuesConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<VenueAggregates>;
  /** A list of edges which contains the `Venue` and cursor to aid in pagination. */
  edges: Array<VenuesEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<VenueAggregates>>;
  /** A list of `Venue` objects. */
  nodes: Array<Maybe<Venue>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Venue` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A connection to a list of `Venue` values. */
export type VenuesConnectionGroupedAggregatesArgs = {
  groupBy: Array<VenuesGroupBy>;
  having?: InputMaybe<VenuesHavingInput>;
};

/** A `Venue` edge in the connection. */
export type VenuesEdge = {
  __typename?: 'VenuesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Venue` at the end of the edge. */
  node?: Maybe<Venue>;
};

/** Grouping methods for `Venue` for usage during aggregation. */
export enum VenuesGroupBy {
  CreatedAt = 'CREATED_AT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  Details = 'DETAILS',
  OwnerId = 'OWNER_ID',
  Type = 'TYPE',
  UpdatedAt = 'UPDATED_AT',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
}

/** Conditions for `Venue` aggregates. */
export type VenuesHavingInput = {
  AND?: InputMaybe<Array<VenuesHavingInput>>;
  OR?: InputMaybe<Array<VenuesHavingInput>>;
};

/** Methods to use when ordering `Venue`. */
export enum VenuesOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  DetailsAsc = 'DETAILS_ASC',
  DetailsDesc = 'DETAILS_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InstructionsCountAsc = 'INSTRUCTIONS_COUNT_ASC',
  InstructionsCountDesc = 'INSTRUCTIONS_COUNT_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  StosCountAsc = 'STOS_COUNT_ASC',
  StosCountDesc = 'STOS_COUNT_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
}

export type _Metadata = {
  __typename?: '_Metadata';
  chain?: Maybe<Scalars['String']['output']>;
  dynamicDatasources?: Maybe<Scalars['String']['output']>;
  genesisHash?: Maybe<Scalars['String']['output']>;
  indexerHealthy?: Maybe<Scalars['Boolean']['output']>;
  indexerNodeVersion?: Maybe<Scalars['String']['output']>;
  lastProcessedHeight?: Maybe<Scalars['Int']['output']>;
  lastProcessedTimestamp?: Maybe<Scalars['Date']['output']>;
  queryNodeVersion?: Maybe<Scalars['String']['output']>;
  rowCountEstimate?: Maybe<Array<Maybe<TableEstimate>>>;
  specName?: Maybe<Scalars['String']['output']>;
  targetHeight?: Maybe<Scalars['Int']['output']>;
};
