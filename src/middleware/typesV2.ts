export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** A floating point number that requires more precision than IEEE 754 binary 64 */
  BigFloat: any;
  /** A location in a connection that can be used for resuming pagination. */
  Cursor: any;
  /** The day, does not include a time. */
  Date: any;
  /**
   * A point in time as described by the [ISO
   * 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
   */
  Datetime: any;
  /** The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
  JSON: any;
};

export type Account = Node & {
  __typename?: 'Account';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  address: Scalars['String'];
  identityId: Scalars['String'];
  eventId: Scalars['String'];
  permissionsId: Scalars['String'];
  datetime: Scalars['Datetime'];
  createdBlockId: Scalars['String'];
  updatedBlockId: Scalars['String'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Identity` that is related to this `Account`. */
  identity?: Maybe<Identity>;
  /** Reads a single `Permission` that is related to this `Account`. */
  permissions?: Maybe<Permission>;
  /** Reads a single `Block` that is related to this `Account`. */
  createdBlock?: Maybe<Block>;
  /** Reads a single `Block` that is related to this `Account`. */
  updatedBlock?: Maybe<Block>;
};

export type AccountAggregates = {
  __typename?: 'AccountAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `Account` object types. All fields are combined with a logical ‘and.’ */
export type AccountFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `address` field. */
  address?: Maybe<StringFilter>;
  /** Filter by the object’s `identityId` field. */
  identityId?: Maybe<StringFilter>;
  /** Filter by the object’s `eventId` field. */
  eventId?: Maybe<StringFilter>;
  /** Filter by the object’s `permissionsId` field. */
  permissionsId?: Maybe<StringFilter>;
  /** Filter by the object’s `datetime` field. */
  datetime?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<AccountFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<AccountFilter>>;
  /** Negates the expression. */
  not?: Maybe<AccountFilter>;
};

/** A connection to a list of `Account` values. */
export type AccountsConnection = {
  __typename?: 'AccountsConnection';
  /** A list of `Account` objects. */
  nodes: Array<Maybe<Account>>;
  /** A list of edges which contains the `Account` and cursor to aid in pagination. */
  edges: Array<AccountsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Account` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AccountAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AccountAggregates>>;
};

/** A connection to a list of `Account` values. */
export type AccountsConnectionGroupedAggregatesArgs = {
  groupBy: Array<AccountsGroupBy>;
  having?: Maybe<AccountsHavingInput>;
};

/** A `Account` edge in the connection. */
export type AccountsEdge = {
  __typename?: 'AccountsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Account` at the end of the edge. */
  node?: Maybe<Account>;
};

/** Grouping methods for `Account` for usage during aggregation. */
export enum AccountsGroupBy {
  IdentityId = 'IDENTITY_ID',
  EventId = 'EVENT_ID',
  PermissionsId = 'PERMISSIONS_ID',
  Datetime = 'DATETIME',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `Account` aggregates. */
export type AccountsHavingInput = {
  AND?: Maybe<Array<AccountsHavingInput>>;
  OR?: Maybe<Array<AccountsHavingInput>>;
};

/** Methods to use when ordering `Account`. */
export enum AccountsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  AddressAsc = 'ADDRESS_ASC',
  AddressDesc = 'ADDRESS_DESC',
  IdentityIdAsc = 'IDENTITY_ID_ASC',
  IdentityIdDesc = 'IDENTITY_ID_DESC',
  EventIdAsc = 'EVENT_ID_ASC',
  EventIdDesc = 'EVENT_ID_DESC',
  PermissionsIdAsc = 'PERMISSIONS_ID_ASC',
  PermissionsIdDesc = 'PERMISSIONS_ID_DESC',
  DatetimeAsc = 'DATETIME_ASC',
  DatetimeDesc = 'DATETIME_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
}

export type AgentGroup = Node & {
  __typename?: 'AgentGroup';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  permissions: Scalars['String'];
  createdBlockId: Scalars['String'];
  updatedBlockId: Scalars['String'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Block` that is related to this `AgentGroup`. */
  createdBlock?: Maybe<Block>;
  /** Reads a single `Block` that is related to this `AgentGroup`. */
  updatedBlock?: Maybe<Block>;
  /** Reads and enables pagination through a set of `AgentGroupMembership`. */
  members: AgentGroupMembershipsConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAgentGroupMembershipGroupIdAndCreatedBlockId: AgentGroupBlocksByAgentGroupMembershipGroupIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAgentGroupMembershipGroupIdAndUpdatedBlockId: AgentGroupBlocksByAgentGroupMembershipGroupIdAndUpdatedBlockIdManyToManyConnection;
};

export type AgentGroupMembersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AgentGroupMembershipsOrderBy>>;
  filter?: Maybe<AgentGroupMembershipFilter>;
};

export type AgentGroupBlocksByAgentGroupMembershipGroupIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type AgentGroupBlocksByAgentGroupMembershipGroupIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type AgentGroupAggregates = {
  __typename?: 'AgentGroupAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A connection to a list of `Block` values, with data from `AgentGroupMembership`. */
export type AgentGroupBlocksByAgentGroupMembershipGroupIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'AgentGroupBlocksByAgentGroupMembershipGroupIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `AgentGroupMembership`, and the cursor to aid in pagination. */
  edges: Array<AgentGroupBlocksByAgentGroupMembershipGroupIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `AgentGroupMembership`. */
export type AgentGroupBlocksByAgentGroupMembershipGroupIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AgentGroupMembership`. */
export type AgentGroupBlocksByAgentGroupMembershipGroupIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'AgentGroupBlocksByAgentGroupMembershipGroupIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `AgentGroupMembership`. */
  agentGroupMembershipsByCreatedBlockId: AgentGroupMembershipsConnection;
};

/** A `Block` edge in the connection, with data from `AgentGroupMembership`. */
export type AgentGroupBlocksByAgentGroupMembershipGroupIdAndCreatedBlockIdManyToManyEdgeAgentGroupMembershipsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AgentGroupMembershipsOrderBy>>;
    filter?: Maybe<AgentGroupMembershipFilter>;
  };

/** A connection to a list of `Block` values, with data from `AgentGroupMembership`. */
export type AgentGroupBlocksByAgentGroupMembershipGroupIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'AgentGroupBlocksByAgentGroupMembershipGroupIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `AgentGroupMembership`, and the cursor to aid in pagination. */
  edges: Array<AgentGroupBlocksByAgentGroupMembershipGroupIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `AgentGroupMembership`. */
export type AgentGroupBlocksByAgentGroupMembershipGroupIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AgentGroupMembership`. */
export type AgentGroupBlocksByAgentGroupMembershipGroupIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'AgentGroupBlocksByAgentGroupMembershipGroupIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `AgentGroupMembership`. */
  agentGroupMembershipsByUpdatedBlockId: AgentGroupMembershipsConnection;
};

/** A `Block` edge in the connection, with data from `AgentGroupMembership`. */
export type AgentGroupBlocksByAgentGroupMembershipGroupIdAndUpdatedBlockIdManyToManyEdgeAgentGroupMembershipsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AgentGroupMembershipsOrderBy>>;
    filter?: Maybe<AgentGroupMembershipFilter>;
  };

/** A filter to be used against `AgentGroup` object types. All fields are combined with a logical ‘and.’ */
export type AgentGroupFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `permissions` field. */
  permissions?: Maybe<StringFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<AgentGroupFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<AgentGroupFilter>>;
  /** Negates the expression. */
  not?: Maybe<AgentGroupFilter>;
};

export type AgentGroupMembership = Node & {
  __typename?: 'AgentGroupMembership';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  member: Scalars['String'];
  groupId: Scalars['String'];
  createdBlockId: Scalars['String'];
  updatedBlockId: Scalars['String'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `AgentGroup` that is related to this `AgentGroupMembership`. */
  group?: Maybe<AgentGroup>;
  /** Reads a single `Block` that is related to this `AgentGroupMembership`. */
  createdBlock?: Maybe<Block>;
  /** Reads a single `Block` that is related to this `AgentGroupMembership`. */
  updatedBlock?: Maybe<Block>;
};

export type AgentGroupMembershipAggregates = {
  __typename?: 'AgentGroupMembershipAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `AgentGroupMembership` object types. All fields are combined with a logical ‘and.’ */
export type AgentGroupMembershipFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `member` field. */
  member?: Maybe<StringFilter>;
  /** Filter by the object’s `groupId` field. */
  groupId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<AgentGroupMembershipFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<AgentGroupMembershipFilter>>;
  /** Negates the expression. */
  not?: Maybe<AgentGroupMembershipFilter>;
};

/** A connection to a list of `AgentGroupMembership` values. */
export type AgentGroupMembershipsConnection = {
  __typename?: 'AgentGroupMembershipsConnection';
  /** A list of `AgentGroupMembership` objects. */
  nodes: Array<Maybe<AgentGroupMembership>>;
  /** A list of edges which contains the `AgentGroupMembership` and cursor to aid in pagination. */
  edges: Array<AgentGroupMembershipsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AgentGroupMembership` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AgentGroupMembershipAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AgentGroupMembershipAggregates>>;
};

/** A connection to a list of `AgentGroupMembership` values. */
export type AgentGroupMembershipsConnectionGroupedAggregatesArgs = {
  groupBy: Array<AgentGroupMembershipsGroupBy>;
  having?: Maybe<AgentGroupMembershipsHavingInput>;
};

/** A `AgentGroupMembership` edge in the connection. */
export type AgentGroupMembershipsEdge = {
  __typename?: 'AgentGroupMembershipsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `AgentGroupMembership` at the end of the edge. */
  node?: Maybe<AgentGroupMembership>;
};

/** Grouping methods for `AgentGroupMembership` for usage during aggregation. */
export enum AgentGroupMembershipsGroupBy {
  Member = 'MEMBER',
  GroupId = 'GROUP_ID',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `AgentGroupMembership` aggregates. */
export type AgentGroupMembershipsHavingInput = {
  AND?: Maybe<Array<AgentGroupMembershipsHavingInput>>;
  OR?: Maybe<Array<AgentGroupMembershipsHavingInput>>;
};

/** Methods to use when ordering `AgentGroupMembership`. */
export enum AgentGroupMembershipsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MemberAsc = 'MEMBER_ASC',
  MemberDesc = 'MEMBER_DESC',
  GroupIdAsc = 'GROUP_ID_ASC',
  GroupIdDesc = 'GROUP_ID_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
}

/** A connection to a list of `AgentGroup` values. */
export type AgentGroupsConnection = {
  __typename?: 'AgentGroupsConnection';
  /** A list of `AgentGroup` objects. */
  nodes: Array<Maybe<AgentGroup>>;
  /** A list of edges which contains the `AgentGroup` and cursor to aid in pagination. */
  edges: Array<AgentGroupsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AgentGroup` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AgentGroupAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AgentGroupAggregates>>;
};

/** A connection to a list of `AgentGroup` values. */
export type AgentGroupsConnectionGroupedAggregatesArgs = {
  groupBy: Array<AgentGroupsGroupBy>;
  having?: Maybe<AgentGroupsHavingInput>;
};

/** A `AgentGroup` edge in the connection. */
export type AgentGroupsEdge = {
  __typename?: 'AgentGroupsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `AgentGroup` at the end of the edge. */
  node?: Maybe<AgentGroup>;
};

/** Grouping methods for `AgentGroup` for usage during aggregation. */
export enum AgentGroupsGroupBy {
  Permissions = 'PERMISSIONS',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `AgentGroup` aggregates. */
export type AgentGroupsHavingInput = {
  AND?: Maybe<Array<AgentGroupsHavingInput>>;
  OR?: Maybe<Array<AgentGroupsHavingInput>>;
};

/** Methods to use when ordering `AgentGroup`. */
export enum AgentGroupsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  PermissionsAsc = 'PERMISSIONS_ASC',
  PermissionsDesc = 'PERMISSIONS_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  MembersCountAsc = 'MEMBERS_COUNT_ASC',
  MembersCountDesc = 'MEMBERS_COUNT_DESC',
}

export type Asset = Node & {
  __typename?: 'Asset';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  ticker: Scalars['String'];
  name?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  fundingRound?: Maybe<Scalars['String']>;
  isDivisible: Scalars['Boolean'];
  isFrozen: Scalars['Boolean'];
  isUniquenessRequired: Scalars['Boolean'];
  identifiers: Scalars['JSON'];
  ownerId: Scalars['String'];
  totalSupply: Scalars['BigFloat'];
  totalTransfers: Scalars['BigFloat'];
  isCompliancePaused: Scalars['Boolean'];
  eventIdx: Scalars['Int'];
  createdBlockId: Scalars['String'];
  updatedBlockId: Scalars['String'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Identity` that is related to this `Asset`. */
  owner?: Maybe<Identity>;
  /** Reads a single `Block` that is related to this `Asset`. */
  createdBlock?: Maybe<Block>;
  /** Reads a single `Block` that is related to this `Asset`. */
  updatedBlock?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TickerExternalAgentAction`. */
  tickerExternalAgentActions: TickerExternalAgentActionsConnection;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByOfferingAssetId: StosConnection;
  /** Reads and enables pagination through a set of `TickerExternalAgent`. */
  tickerExternalAgents: TickerExternalAgentsConnection;
  /** Reads and enables pagination through a set of `TickerExternalAgentHistory`. */
  tickerExternalAgentHistories: TickerExternalAgentHistoriesConnection;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovements: PortfolioMovementsConnection;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributions: DistributionsConnection;
  /** Reads and enables pagination through a set of `TrustedClaimIssuer`. */
  trustedClaimIssuers: TrustedClaimIssuersConnection;
  /** Reads and enables pagination through a set of `TransferManager`. */
  transferManagers: TransferManagersConnection;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypes: StatTypesConnection;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliances: TransferCompliancesConnection;
  /** Reads and enables pagination through a set of `TransferComplianceExemption`. */
  transferComplianceExemptions: TransferComplianceExemptionsConnection;
  /** Reads and enables pagination through a set of `Compliance`. */
  compliance: CompliancesConnection;
  /** Reads and enables pagination through a set of `AssetHolder`. */
  holders: AssetHoldersConnection;
  /** Reads and enables pagination through a set of `AssetDocument`. */
  documents: AssetDocumentsConnection;
  /** Reads and enables pagination through a set of `Funding`. */
  fundings: FundingsConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByTickerExternalAgentActionAssetIdAndCallerId: AssetIdentitiesByTickerExternalAgentActionAssetIdAndCallerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTickerExternalAgentActionAssetIdAndCreatedBlockId: AssetBlocksByTickerExternalAgentActionAssetIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTickerExternalAgentActionAssetIdAndUpdatedBlockId: AssetBlocksByTickerExternalAgentActionAssetIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByStoOfferingAssetIdAndCreatedBlockId: AssetBlocksByStoOfferingAssetIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByStoOfferingAssetIdAndUpdatedBlockId: AssetBlocksByStoOfferingAssetIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByTickerExternalAgentAssetIdAndCallerId: AssetIdentitiesByTickerExternalAgentAssetIdAndCallerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTickerExternalAgentAssetIdAndCreatedBlockId: AssetBlocksByTickerExternalAgentAssetIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTickerExternalAgentAssetIdAndUpdatedBlockId: AssetBlocksByTickerExternalAgentAssetIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByTickerExternalAgentHistoryAssetIdAndIdentityId: AssetIdentitiesByTickerExternalAgentHistoryAssetIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTickerExternalAgentHistoryAssetIdAndCreatedBlockId: AssetBlocksByTickerExternalAgentHistoryAssetIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTickerExternalAgentHistoryAssetIdAndUpdatedBlockId: AssetBlocksByTickerExternalAgentHistoryAssetIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByPortfolioMovementAssetIdAndFromId: AssetPortfoliosByPortfolioMovementAssetIdAndFromIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByPortfolioMovementAssetIdAndToId: AssetPortfoliosByPortfolioMovementAssetIdAndToIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByPortfolioMovementAssetIdAndCreatedBlockId: AssetBlocksByPortfolioMovementAssetIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByPortfolioMovementAssetIdAndUpdatedBlockId: AssetBlocksByPortfolioMovementAssetIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByDistributionAssetIdAndIdentityId: AssetIdentitiesByDistributionAssetIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByDistributionAssetIdAndPortfolioId: AssetPortfoliosByDistributionAssetIdAndPortfolioIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByDistributionAssetIdAndCreatedBlockId: AssetBlocksByDistributionAssetIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByDistributionAssetIdAndUpdatedBlockId: AssetBlocksByDistributionAssetIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTrustedClaimIssuerAssetIdAndCreatedBlockId: AssetBlocksByTrustedClaimIssuerAssetIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTrustedClaimIssuerAssetIdAndUpdatedBlockId: AssetBlocksByTrustedClaimIssuerAssetIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTransferManagerAssetIdAndCreatedBlockId: AssetBlocksByTransferManagerAssetIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTransferManagerAssetIdAndUpdatedBlockId: AssetBlocksByTransferManagerAssetIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByStatTypeAssetIdAndClaimIssuerId: AssetIdentitiesByStatTypeAssetIdAndClaimIssuerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByStatTypeAssetIdAndCreatedBlockId: AssetBlocksByStatTypeAssetIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByStatTypeAssetIdAndUpdatedBlockId: AssetBlocksByStatTypeAssetIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypesByTransferComplianceAssetIdAndStatTypeId: AssetStatTypesByTransferComplianceAssetIdAndStatTypeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByTransferComplianceAssetIdAndClaimIssuerId: AssetIdentitiesByTransferComplianceAssetIdAndClaimIssuerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTransferComplianceAssetIdAndCreatedBlockId: AssetBlocksByTransferComplianceAssetIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTransferComplianceAssetIdAndUpdatedBlockId: AssetBlocksByTransferComplianceAssetIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTransferComplianceExemptionAssetIdAndCreatedBlockId: AssetBlocksByTransferComplianceExemptionAssetIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTransferComplianceExemptionAssetIdAndUpdatedBlockId: AssetBlocksByTransferComplianceExemptionAssetIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByComplianceAssetIdAndCreatedBlockId: AssetBlocksByComplianceAssetIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByComplianceAssetIdAndUpdatedBlockId: AssetBlocksByComplianceAssetIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByAssetHolderAssetIdAndIdentityId: AssetIdentitiesByAssetHolderAssetIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetHolderAssetIdAndCreatedBlockId: AssetBlocksByAssetHolderAssetIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetHolderAssetIdAndUpdatedBlockId: AssetBlocksByAssetHolderAssetIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetDocumentAssetIdAndCreatedBlockId: AssetBlocksByAssetDocumentAssetIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetDocumentAssetIdAndUpdatedBlockId: AssetBlocksByAssetDocumentAssetIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByFundingAssetIdAndCreatedBlockId: AssetBlocksByFundingAssetIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByFundingAssetIdAndUpdatedBlockId: AssetBlocksByFundingAssetIdAndUpdatedBlockIdManyToManyConnection;
};

export type AssetTickerExternalAgentActionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TickerExternalAgentActionsOrderBy>>;
  filter?: Maybe<TickerExternalAgentActionFilter>;
};

export type AssetStosByOfferingAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StosOrderBy>>;
  filter?: Maybe<StoFilter>;
};

export type AssetTickerExternalAgentsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TickerExternalAgentsOrderBy>>;
  filter?: Maybe<TickerExternalAgentFilter>;
};

export type AssetTickerExternalAgentHistoriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TickerExternalAgentHistoriesOrderBy>>;
  filter?: Maybe<TickerExternalAgentHistoryFilter>;
};

export type AssetPortfolioMovementsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PortfolioMovementsOrderBy>>;
  filter?: Maybe<PortfolioMovementFilter>;
};

export type AssetDistributionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<DistributionsOrderBy>>;
  filter?: Maybe<DistributionFilter>;
};

export type AssetTrustedClaimIssuersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TrustedClaimIssuersOrderBy>>;
  filter?: Maybe<TrustedClaimIssuerFilter>;
};

export type AssetTransferManagersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TransferManagersOrderBy>>;
  filter?: Maybe<TransferManagerFilter>;
};

export type AssetStatTypesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StatTypesOrderBy>>;
  filter?: Maybe<StatTypeFilter>;
};

export type AssetTransferCompliancesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TransferCompliancesOrderBy>>;
  filter?: Maybe<TransferComplianceFilter>;
};

export type AssetTransferComplianceExemptionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TransferComplianceExemptionsOrderBy>>;
  filter?: Maybe<TransferComplianceExemptionFilter>;
};

export type AssetComplianceArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CompliancesOrderBy>>;
  filter?: Maybe<ComplianceFilter>;
};

export type AssetHoldersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetHoldersOrderBy>>;
  filter?: Maybe<AssetHolderFilter>;
};

export type AssetDocumentsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetDocumentsOrderBy>>;
  filter?: Maybe<AssetDocumentFilter>;
};

export type AssetFundingsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<FundingsOrderBy>>;
  filter?: Maybe<FundingFilter>;
};

export type AssetIdentitiesByTickerExternalAgentActionAssetIdAndCallerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type AssetBlocksByTickerExternalAgentActionAssetIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type AssetBlocksByTickerExternalAgentActionAssetIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type AssetBlocksByStoOfferingAssetIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type AssetBlocksByStoOfferingAssetIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type AssetIdentitiesByTickerExternalAgentAssetIdAndCallerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type AssetBlocksByTickerExternalAgentAssetIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type AssetBlocksByTickerExternalAgentAssetIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type AssetIdentitiesByTickerExternalAgentHistoryAssetIdAndIdentityIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type AssetBlocksByTickerExternalAgentHistoryAssetIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type AssetBlocksByTickerExternalAgentHistoryAssetIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type AssetPortfoliosByPortfolioMovementAssetIdAndFromIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PortfoliosOrderBy>>;
  filter?: Maybe<PortfolioFilter>;
};

export type AssetPortfoliosByPortfolioMovementAssetIdAndToIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PortfoliosOrderBy>>;
  filter?: Maybe<PortfolioFilter>;
};

export type AssetBlocksByPortfolioMovementAssetIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type AssetBlocksByPortfolioMovementAssetIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type AssetIdentitiesByDistributionAssetIdAndIdentityIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type AssetPortfoliosByDistributionAssetIdAndPortfolioIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PortfoliosOrderBy>>;
  filter?: Maybe<PortfolioFilter>;
};

export type AssetBlocksByDistributionAssetIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type AssetBlocksByDistributionAssetIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type AssetBlocksByTrustedClaimIssuerAssetIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type AssetBlocksByTrustedClaimIssuerAssetIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type AssetBlocksByTransferManagerAssetIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type AssetBlocksByTransferManagerAssetIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type AssetIdentitiesByStatTypeAssetIdAndClaimIssuerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type AssetBlocksByStatTypeAssetIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type AssetBlocksByStatTypeAssetIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type AssetStatTypesByTransferComplianceAssetIdAndStatTypeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StatTypesOrderBy>>;
  filter?: Maybe<StatTypeFilter>;
};

export type AssetIdentitiesByTransferComplianceAssetIdAndClaimIssuerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type AssetBlocksByTransferComplianceAssetIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type AssetBlocksByTransferComplianceAssetIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type AssetBlocksByTransferComplianceExemptionAssetIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type AssetBlocksByTransferComplianceExemptionAssetIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type AssetBlocksByComplianceAssetIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type AssetBlocksByComplianceAssetIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type AssetIdentitiesByAssetHolderAssetIdAndIdentityIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type AssetBlocksByAssetHolderAssetIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type AssetBlocksByAssetHolderAssetIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type AssetBlocksByAssetDocumentAssetIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type AssetBlocksByAssetDocumentAssetIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type AssetBlocksByFundingAssetIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type AssetBlocksByFundingAssetIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type AssetAggregates = {
  __typename?: 'AssetAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A connection to a list of `Block` values, with data from `AssetDocument`. */
export type AssetBlocksByAssetDocumentAssetIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByAssetDocumentAssetIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `AssetDocument`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByAssetDocumentAssetIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `AssetDocument`. */
export type AssetBlocksByAssetDocumentAssetIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AssetDocument`. */
export type AssetBlocksByAssetDocumentAssetIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByAssetDocumentAssetIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `AssetDocument`. */
  assetDocumentsByCreatedBlockId: AssetDocumentsConnection;
};

/** A `Block` edge in the connection, with data from `AssetDocument`. */
export type AssetBlocksByAssetDocumentAssetIdAndCreatedBlockIdManyToManyEdgeAssetDocumentsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AssetDocumentsOrderBy>>;
    filter?: Maybe<AssetDocumentFilter>;
  };

/** A connection to a list of `Block` values, with data from `AssetDocument`. */
export type AssetBlocksByAssetDocumentAssetIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByAssetDocumentAssetIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `AssetDocument`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByAssetDocumentAssetIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `AssetDocument`. */
export type AssetBlocksByAssetDocumentAssetIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AssetDocument`. */
export type AssetBlocksByAssetDocumentAssetIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByAssetDocumentAssetIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `AssetDocument`. */
  assetDocumentsByUpdatedBlockId: AssetDocumentsConnection;
};

/** A `Block` edge in the connection, with data from `AssetDocument`. */
export type AssetBlocksByAssetDocumentAssetIdAndUpdatedBlockIdManyToManyEdgeAssetDocumentsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AssetDocumentsOrderBy>>;
    filter?: Maybe<AssetDocumentFilter>;
  };

/** A connection to a list of `Block` values, with data from `AssetHolder`. */
export type AssetBlocksByAssetHolderAssetIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByAssetHolderAssetIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `AssetHolder`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByAssetHolderAssetIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `AssetHolder`. */
export type AssetBlocksByAssetHolderAssetIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AssetHolder`. */
export type AssetBlocksByAssetHolderAssetIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByAssetHolderAssetIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `AssetHolder`. */
  assetHoldersByCreatedBlockId: AssetHoldersConnection;
};

/** A `Block` edge in the connection, with data from `AssetHolder`. */
export type AssetBlocksByAssetHolderAssetIdAndCreatedBlockIdManyToManyEdgeAssetHoldersByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AssetHoldersOrderBy>>;
    filter?: Maybe<AssetHolderFilter>;
  };

/** A connection to a list of `Block` values, with data from `AssetHolder`. */
export type AssetBlocksByAssetHolderAssetIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByAssetHolderAssetIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `AssetHolder`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByAssetHolderAssetIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `AssetHolder`. */
export type AssetBlocksByAssetHolderAssetIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AssetHolder`. */
export type AssetBlocksByAssetHolderAssetIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByAssetHolderAssetIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `AssetHolder`. */
  assetHoldersByUpdatedBlockId: AssetHoldersConnection;
};

/** A `Block` edge in the connection, with data from `AssetHolder`. */
export type AssetBlocksByAssetHolderAssetIdAndUpdatedBlockIdManyToManyEdgeAssetHoldersByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AssetHoldersOrderBy>>;
    filter?: Maybe<AssetHolderFilter>;
  };

/** A connection to a list of `Block` values, with data from `Compliance`. */
export type AssetBlocksByComplianceAssetIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByComplianceAssetIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Compliance`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByComplianceAssetIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Compliance`. */
export type AssetBlocksByComplianceAssetIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Compliance`. */
export type AssetBlocksByComplianceAssetIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByComplianceAssetIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Compliance`. */
  compliancesByCreatedBlockId: CompliancesConnection;
};

/** A `Block` edge in the connection, with data from `Compliance`. */
export type AssetBlocksByComplianceAssetIdAndCreatedBlockIdManyToManyEdgeCompliancesByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<CompliancesOrderBy>>;
    filter?: Maybe<ComplianceFilter>;
  };

/** A connection to a list of `Block` values, with data from `Compliance`. */
export type AssetBlocksByComplianceAssetIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByComplianceAssetIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Compliance`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByComplianceAssetIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Compliance`. */
export type AssetBlocksByComplianceAssetIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Compliance`. */
export type AssetBlocksByComplianceAssetIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByComplianceAssetIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Compliance`. */
  compliancesByUpdatedBlockId: CompliancesConnection;
};

/** A `Block` edge in the connection, with data from `Compliance`. */
export type AssetBlocksByComplianceAssetIdAndUpdatedBlockIdManyToManyEdgeCompliancesByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<CompliancesOrderBy>>;
    filter?: Maybe<ComplianceFilter>;
  };

/** A connection to a list of `Block` values, with data from `Distribution`. */
export type AssetBlocksByDistributionAssetIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByDistributionAssetIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByDistributionAssetIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Distribution`. */
export type AssetBlocksByDistributionAssetIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Distribution`. */
export type AssetBlocksByDistributionAssetIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByDistributionAssetIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributionsByCreatedBlockId: DistributionsConnection;
};

/** A `Block` edge in the connection, with data from `Distribution`. */
export type AssetBlocksByDistributionAssetIdAndCreatedBlockIdManyToManyEdgeDistributionsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<DistributionsOrderBy>>;
    filter?: Maybe<DistributionFilter>;
  };

/** A connection to a list of `Block` values, with data from `Distribution`. */
export type AssetBlocksByDistributionAssetIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByDistributionAssetIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByDistributionAssetIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Distribution`. */
export type AssetBlocksByDistributionAssetIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Distribution`. */
export type AssetBlocksByDistributionAssetIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByDistributionAssetIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributionsByUpdatedBlockId: DistributionsConnection;
};

/** A `Block` edge in the connection, with data from `Distribution`. */
export type AssetBlocksByDistributionAssetIdAndUpdatedBlockIdManyToManyEdgeDistributionsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<DistributionsOrderBy>>;
    filter?: Maybe<DistributionFilter>;
  };

/** A connection to a list of `Block` values, with data from `Funding`. */
export type AssetBlocksByFundingAssetIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByFundingAssetIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Funding`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByFundingAssetIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Funding`. */
export type AssetBlocksByFundingAssetIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Funding`. */
export type AssetBlocksByFundingAssetIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByFundingAssetIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Funding`. */
  fundingsByCreatedBlockId: FundingsConnection;
};

/** A `Block` edge in the connection, with data from `Funding`. */
export type AssetBlocksByFundingAssetIdAndCreatedBlockIdManyToManyEdgeFundingsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<FundingsOrderBy>>;
    filter?: Maybe<FundingFilter>;
  };

/** A connection to a list of `Block` values, with data from `Funding`. */
export type AssetBlocksByFundingAssetIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByFundingAssetIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Funding`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByFundingAssetIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Funding`. */
export type AssetBlocksByFundingAssetIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Funding`. */
export type AssetBlocksByFundingAssetIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByFundingAssetIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Funding`. */
  fundingsByUpdatedBlockId: FundingsConnection;
};

/** A `Block` edge in the connection, with data from `Funding`. */
export type AssetBlocksByFundingAssetIdAndUpdatedBlockIdManyToManyEdgeFundingsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<FundingsOrderBy>>;
    filter?: Maybe<FundingFilter>;
  };

/** A connection to a list of `Block` values, with data from `PortfolioMovement`. */
export type AssetBlocksByPortfolioMovementAssetIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByPortfolioMovementAssetIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByPortfolioMovementAssetIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `PortfolioMovement`. */
export type AssetBlocksByPortfolioMovementAssetIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `PortfolioMovement`. */
export type AssetBlocksByPortfolioMovementAssetIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByPortfolioMovementAssetIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByCreatedBlockId: PortfolioMovementsConnection;
};

/** A `Block` edge in the connection, with data from `PortfolioMovement`. */
export type AssetBlocksByPortfolioMovementAssetIdAndCreatedBlockIdManyToManyEdgePortfolioMovementsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<PortfolioMovementsOrderBy>>;
    filter?: Maybe<PortfolioMovementFilter>;
  };

/** A connection to a list of `Block` values, with data from `PortfolioMovement`. */
export type AssetBlocksByPortfolioMovementAssetIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByPortfolioMovementAssetIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByPortfolioMovementAssetIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `PortfolioMovement`. */
export type AssetBlocksByPortfolioMovementAssetIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `PortfolioMovement`. */
export type AssetBlocksByPortfolioMovementAssetIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByPortfolioMovementAssetIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByUpdatedBlockId: PortfolioMovementsConnection;
};

/** A `Block` edge in the connection, with data from `PortfolioMovement`. */
export type AssetBlocksByPortfolioMovementAssetIdAndUpdatedBlockIdManyToManyEdgePortfolioMovementsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<PortfolioMovementsOrderBy>>;
    filter?: Maybe<PortfolioMovementFilter>;
  };

/** A connection to a list of `Block` values, with data from `StatType`. */
export type AssetBlocksByStatTypeAssetIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByStatTypeAssetIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `StatType`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByStatTypeAssetIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `StatType`. */
export type AssetBlocksByStatTypeAssetIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `StatType`. */
export type AssetBlocksByStatTypeAssetIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByStatTypeAssetIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypesByCreatedBlockId: StatTypesConnection;
};

/** A `Block` edge in the connection, with data from `StatType`. */
export type AssetBlocksByStatTypeAssetIdAndCreatedBlockIdManyToManyEdgeStatTypesByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<StatTypesOrderBy>>;
    filter?: Maybe<StatTypeFilter>;
  };

/** A connection to a list of `Block` values, with data from `StatType`. */
export type AssetBlocksByStatTypeAssetIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByStatTypeAssetIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `StatType`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByStatTypeAssetIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `StatType`. */
export type AssetBlocksByStatTypeAssetIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `StatType`. */
export type AssetBlocksByStatTypeAssetIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByStatTypeAssetIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypesByUpdatedBlockId: StatTypesConnection;
};

/** A `Block` edge in the connection, with data from `StatType`. */
export type AssetBlocksByStatTypeAssetIdAndUpdatedBlockIdManyToManyEdgeStatTypesByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<StatTypesOrderBy>>;
    filter?: Maybe<StatTypeFilter>;
  };

/** A connection to a list of `Block` values, with data from `Sto`. */
export type AssetBlocksByStoOfferingAssetIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByStoOfferingAssetIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByStoOfferingAssetIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Sto`. */
export type AssetBlocksByStoOfferingAssetIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Sto`. */
export type AssetBlocksByStoOfferingAssetIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByStoOfferingAssetIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByCreatedBlockId: StosConnection;
};

/** A `Block` edge in the connection, with data from `Sto`. */
export type AssetBlocksByStoOfferingAssetIdAndCreatedBlockIdManyToManyEdgeStosByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<StosOrderBy>>;
    filter?: Maybe<StoFilter>;
  };

/** A connection to a list of `Block` values, with data from `Sto`. */
export type AssetBlocksByStoOfferingAssetIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByStoOfferingAssetIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByStoOfferingAssetIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Sto`. */
export type AssetBlocksByStoOfferingAssetIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Sto`. */
export type AssetBlocksByStoOfferingAssetIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByStoOfferingAssetIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByUpdatedBlockId: StosConnection;
};

/** A `Block` edge in the connection, with data from `Sto`. */
export type AssetBlocksByStoOfferingAssetIdAndUpdatedBlockIdManyToManyEdgeStosByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<StosOrderBy>>;
    filter?: Maybe<StoFilter>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentAction`. */
export type AssetBlocksByTickerExternalAgentActionAssetIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByTickerExternalAgentActionAssetIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `TickerExternalAgentAction`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByTickerExternalAgentActionAssetIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `TickerExternalAgentAction`. */
export type AssetBlocksByTickerExternalAgentActionAssetIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TickerExternalAgentAction`. */
export type AssetBlocksByTickerExternalAgentActionAssetIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByTickerExternalAgentActionAssetIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TickerExternalAgentAction`. */
  tickerExternalAgentActionsByCreatedBlockId: TickerExternalAgentActionsConnection;
};

/** A `Block` edge in the connection, with data from `TickerExternalAgentAction`. */
export type AssetBlocksByTickerExternalAgentActionAssetIdAndCreatedBlockIdManyToManyEdgeTickerExternalAgentActionsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TickerExternalAgentActionsOrderBy>>;
    filter?: Maybe<TickerExternalAgentActionFilter>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentAction`. */
export type AssetBlocksByTickerExternalAgentActionAssetIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByTickerExternalAgentActionAssetIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `TickerExternalAgentAction`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByTickerExternalAgentActionAssetIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `TickerExternalAgentAction`. */
export type AssetBlocksByTickerExternalAgentActionAssetIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TickerExternalAgentAction`. */
export type AssetBlocksByTickerExternalAgentActionAssetIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByTickerExternalAgentActionAssetIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TickerExternalAgentAction`. */
  tickerExternalAgentActionsByUpdatedBlockId: TickerExternalAgentActionsConnection;
};

/** A `Block` edge in the connection, with data from `TickerExternalAgentAction`. */
export type AssetBlocksByTickerExternalAgentActionAssetIdAndUpdatedBlockIdManyToManyEdgeTickerExternalAgentActionsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TickerExternalAgentActionsOrderBy>>;
    filter?: Maybe<TickerExternalAgentActionFilter>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgent`. */
export type AssetBlocksByTickerExternalAgentAssetIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByTickerExternalAgentAssetIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `TickerExternalAgent`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByTickerExternalAgentAssetIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `TickerExternalAgent`. */
export type AssetBlocksByTickerExternalAgentAssetIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TickerExternalAgent`. */
export type AssetBlocksByTickerExternalAgentAssetIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByTickerExternalAgentAssetIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TickerExternalAgent`. */
  tickerExternalAgentsByCreatedBlockId: TickerExternalAgentsConnection;
};

/** A `Block` edge in the connection, with data from `TickerExternalAgent`. */
export type AssetBlocksByTickerExternalAgentAssetIdAndCreatedBlockIdManyToManyEdgeTickerExternalAgentsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TickerExternalAgentsOrderBy>>;
    filter?: Maybe<TickerExternalAgentFilter>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgent`. */
export type AssetBlocksByTickerExternalAgentAssetIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByTickerExternalAgentAssetIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `TickerExternalAgent`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByTickerExternalAgentAssetIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `TickerExternalAgent`. */
export type AssetBlocksByTickerExternalAgentAssetIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TickerExternalAgent`. */
export type AssetBlocksByTickerExternalAgentAssetIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByTickerExternalAgentAssetIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TickerExternalAgent`. */
  tickerExternalAgentsByUpdatedBlockId: TickerExternalAgentsConnection;
};

/** A `Block` edge in the connection, with data from `TickerExternalAgent`. */
export type AssetBlocksByTickerExternalAgentAssetIdAndUpdatedBlockIdManyToManyEdgeTickerExternalAgentsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TickerExternalAgentsOrderBy>>;
    filter?: Maybe<TickerExternalAgentFilter>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentHistory`. */
export type AssetBlocksByTickerExternalAgentHistoryAssetIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByTickerExternalAgentHistoryAssetIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `TickerExternalAgentHistory`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByTickerExternalAgentHistoryAssetIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `TickerExternalAgentHistory`. */
export type AssetBlocksByTickerExternalAgentHistoryAssetIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type AssetBlocksByTickerExternalAgentHistoryAssetIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByTickerExternalAgentHistoryAssetIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TickerExternalAgentHistory`. */
  tickerExternalAgentHistoriesByCreatedBlockId: TickerExternalAgentHistoriesConnection;
};

/** A `Block` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type AssetBlocksByTickerExternalAgentHistoryAssetIdAndCreatedBlockIdManyToManyEdgeTickerExternalAgentHistoriesByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TickerExternalAgentHistoriesOrderBy>>;
    filter?: Maybe<TickerExternalAgentHistoryFilter>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentHistory`. */
export type AssetBlocksByTickerExternalAgentHistoryAssetIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByTickerExternalAgentHistoryAssetIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `TickerExternalAgentHistory`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByTickerExternalAgentHistoryAssetIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `TickerExternalAgentHistory`. */
export type AssetBlocksByTickerExternalAgentHistoryAssetIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type AssetBlocksByTickerExternalAgentHistoryAssetIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByTickerExternalAgentHistoryAssetIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TickerExternalAgentHistory`. */
  tickerExternalAgentHistoriesByUpdatedBlockId: TickerExternalAgentHistoriesConnection;
};

/** A `Block` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type AssetBlocksByTickerExternalAgentHistoryAssetIdAndUpdatedBlockIdManyToManyEdgeTickerExternalAgentHistoriesByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TickerExternalAgentHistoriesOrderBy>>;
    filter?: Maybe<TickerExternalAgentHistoryFilter>;
  };

/** A connection to a list of `Block` values, with data from `TransferCompliance`. */
export type AssetBlocksByTransferComplianceAssetIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByTransferComplianceAssetIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByTransferComplianceAssetIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `TransferCompliance`. */
export type AssetBlocksByTransferComplianceAssetIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TransferCompliance`. */
export type AssetBlocksByTransferComplianceAssetIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByTransferComplianceAssetIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliancesByCreatedBlockId: TransferCompliancesConnection;
};

/** A `Block` edge in the connection, with data from `TransferCompliance`. */
export type AssetBlocksByTransferComplianceAssetIdAndCreatedBlockIdManyToManyEdgeTransferCompliancesByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TransferCompliancesOrderBy>>;
    filter?: Maybe<TransferComplianceFilter>;
  };

/** A connection to a list of `Block` values, with data from `TransferCompliance`. */
export type AssetBlocksByTransferComplianceAssetIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByTransferComplianceAssetIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByTransferComplianceAssetIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `TransferCompliance`. */
export type AssetBlocksByTransferComplianceAssetIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TransferCompliance`. */
export type AssetBlocksByTransferComplianceAssetIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByTransferComplianceAssetIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliancesByUpdatedBlockId: TransferCompliancesConnection;
};

/** A `Block` edge in the connection, with data from `TransferCompliance`. */
export type AssetBlocksByTransferComplianceAssetIdAndUpdatedBlockIdManyToManyEdgeTransferCompliancesByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TransferCompliancesOrderBy>>;
    filter?: Maybe<TransferComplianceFilter>;
  };

/** A connection to a list of `Block` values, with data from `TransferComplianceExemption`. */
export type AssetBlocksByTransferComplianceExemptionAssetIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByTransferComplianceExemptionAssetIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `TransferComplianceExemption`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByTransferComplianceExemptionAssetIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `TransferComplianceExemption`. */
export type AssetBlocksByTransferComplianceExemptionAssetIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TransferComplianceExemption`. */
export type AssetBlocksByTransferComplianceExemptionAssetIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByTransferComplianceExemptionAssetIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TransferComplianceExemption`. */
  transferComplianceExemptionsByCreatedBlockId: TransferComplianceExemptionsConnection;
};

/** A `Block` edge in the connection, with data from `TransferComplianceExemption`. */
export type AssetBlocksByTransferComplianceExemptionAssetIdAndCreatedBlockIdManyToManyEdgeTransferComplianceExemptionsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TransferComplianceExemptionsOrderBy>>;
    filter?: Maybe<TransferComplianceExemptionFilter>;
  };

/** A connection to a list of `Block` values, with data from `TransferComplianceExemption`. */
export type AssetBlocksByTransferComplianceExemptionAssetIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByTransferComplianceExemptionAssetIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `TransferComplianceExemption`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByTransferComplianceExemptionAssetIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `TransferComplianceExemption`. */
export type AssetBlocksByTransferComplianceExemptionAssetIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TransferComplianceExemption`. */
export type AssetBlocksByTransferComplianceExemptionAssetIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByTransferComplianceExemptionAssetIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TransferComplianceExemption`. */
  transferComplianceExemptionsByUpdatedBlockId: TransferComplianceExemptionsConnection;
};

/** A `Block` edge in the connection, with data from `TransferComplianceExemption`. */
export type AssetBlocksByTransferComplianceExemptionAssetIdAndUpdatedBlockIdManyToManyEdgeTransferComplianceExemptionsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TransferComplianceExemptionsOrderBy>>;
    filter?: Maybe<TransferComplianceExemptionFilter>;
  };

/** A connection to a list of `Block` values, with data from `TransferManager`. */
export type AssetBlocksByTransferManagerAssetIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByTransferManagerAssetIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `TransferManager`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByTransferManagerAssetIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `TransferManager`. */
export type AssetBlocksByTransferManagerAssetIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TransferManager`. */
export type AssetBlocksByTransferManagerAssetIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByTransferManagerAssetIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TransferManager`. */
  transferManagersByCreatedBlockId: TransferManagersConnection;
};

/** A `Block` edge in the connection, with data from `TransferManager`. */
export type AssetBlocksByTransferManagerAssetIdAndCreatedBlockIdManyToManyEdgeTransferManagersByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TransferManagersOrderBy>>;
    filter?: Maybe<TransferManagerFilter>;
  };

/** A connection to a list of `Block` values, with data from `TransferManager`. */
export type AssetBlocksByTransferManagerAssetIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByTransferManagerAssetIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `TransferManager`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByTransferManagerAssetIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `TransferManager`. */
export type AssetBlocksByTransferManagerAssetIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TransferManager`. */
export type AssetBlocksByTransferManagerAssetIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByTransferManagerAssetIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TransferManager`. */
  transferManagersByUpdatedBlockId: TransferManagersConnection;
};

/** A `Block` edge in the connection, with data from `TransferManager`. */
export type AssetBlocksByTransferManagerAssetIdAndUpdatedBlockIdManyToManyEdgeTransferManagersByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TransferManagersOrderBy>>;
    filter?: Maybe<TransferManagerFilter>;
  };

/** A connection to a list of `Block` values, with data from `TrustedClaimIssuer`. */
export type AssetBlocksByTrustedClaimIssuerAssetIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByTrustedClaimIssuerAssetIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `TrustedClaimIssuer`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByTrustedClaimIssuerAssetIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `TrustedClaimIssuer`. */
export type AssetBlocksByTrustedClaimIssuerAssetIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TrustedClaimIssuer`. */
export type AssetBlocksByTrustedClaimIssuerAssetIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByTrustedClaimIssuerAssetIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TrustedClaimIssuer`. */
  trustedClaimIssuersByCreatedBlockId: TrustedClaimIssuersConnection;
};

/** A `Block` edge in the connection, with data from `TrustedClaimIssuer`. */
export type AssetBlocksByTrustedClaimIssuerAssetIdAndCreatedBlockIdManyToManyEdgeTrustedClaimIssuersByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TrustedClaimIssuersOrderBy>>;
    filter?: Maybe<TrustedClaimIssuerFilter>;
  };

/** A connection to a list of `Block` values, with data from `TrustedClaimIssuer`. */
export type AssetBlocksByTrustedClaimIssuerAssetIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'AssetBlocksByTrustedClaimIssuerAssetIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `TrustedClaimIssuer`, and the cursor to aid in pagination. */
  edges: Array<AssetBlocksByTrustedClaimIssuerAssetIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `TrustedClaimIssuer`. */
export type AssetBlocksByTrustedClaimIssuerAssetIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TrustedClaimIssuer`. */
export type AssetBlocksByTrustedClaimIssuerAssetIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'AssetBlocksByTrustedClaimIssuerAssetIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TrustedClaimIssuer`. */
  trustedClaimIssuersByUpdatedBlockId: TrustedClaimIssuersConnection;
};

/** A `Block` edge in the connection, with data from `TrustedClaimIssuer`. */
export type AssetBlocksByTrustedClaimIssuerAssetIdAndUpdatedBlockIdManyToManyEdgeTrustedClaimIssuersByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TrustedClaimIssuersOrderBy>>;
    filter?: Maybe<TrustedClaimIssuerFilter>;
  };

export type AssetDocument = Node & {
  __typename?: 'AssetDocument';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  documentId: Scalars['Int'];
  name: Scalars['String'];
  link: Scalars['String'];
  contentHash?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  filedAt?: Maybe<Scalars['Datetime']>;
  assetId: Scalars['String'];
  createdBlockId: Scalars['String'];
  updatedBlockId: Scalars['String'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Asset` that is related to this `AssetDocument`. */
  asset?: Maybe<Asset>;
  /** Reads a single `Block` that is related to this `AssetDocument`. */
  createdBlock?: Maybe<Block>;
  /** Reads a single `Block` that is related to this `AssetDocument`. */
  updatedBlock?: Maybe<Block>;
};

export type AssetDocumentAggregates = {
  __typename?: 'AssetDocumentAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `AssetDocument` object types. All fields are combined with a logical ‘and.’ */
export type AssetDocumentFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `documentId` field. */
  documentId?: Maybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `link` field. */
  link?: Maybe<StringFilter>;
  /** Filter by the object’s `contentHash` field. */
  contentHash?: Maybe<StringFilter>;
  /** Filter by the object’s `type` field. */
  type?: Maybe<StringFilter>;
  /** Filter by the object’s `filedAt` field. */
  filedAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `assetId` field. */
  assetId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<AssetDocumentFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<AssetDocumentFilter>>;
  /** Negates the expression. */
  not?: Maybe<AssetDocumentFilter>;
};

/** A connection to a list of `AssetDocument` values. */
export type AssetDocumentsConnection = {
  __typename?: 'AssetDocumentsConnection';
  /** A list of `AssetDocument` objects. */
  nodes: Array<Maybe<AssetDocument>>;
  /** A list of edges which contains the `AssetDocument` and cursor to aid in pagination. */
  edges: Array<AssetDocumentsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AssetDocument` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetDocumentAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetDocumentAggregates>>;
};

/** A connection to a list of `AssetDocument` values. */
export type AssetDocumentsConnectionGroupedAggregatesArgs = {
  groupBy: Array<AssetDocumentsGroupBy>;
  having?: Maybe<AssetDocumentsHavingInput>;
};

/** A `AssetDocument` edge in the connection. */
export type AssetDocumentsEdge = {
  __typename?: 'AssetDocumentsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `AssetDocument` at the end of the edge. */
  node?: Maybe<AssetDocument>;
};

/** Grouping methods for `AssetDocument` for usage during aggregation. */
export enum AssetDocumentsGroupBy {
  DocumentId = 'DOCUMENT_ID',
  Name = 'NAME',
  Link = 'LINK',
  ContentHash = 'CONTENT_HASH',
  Type = 'TYPE',
  FiledAt = 'FILED_AT',
  AssetId = 'ASSET_ID',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `AssetDocument` aggregates. */
export type AssetDocumentsHavingInput = {
  AND?: Maybe<Array<AssetDocumentsHavingInput>>;
  OR?: Maybe<Array<AssetDocumentsHavingInput>>;
};

/** Methods to use when ordering `AssetDocument`. */
export enum AssetDocumentsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  DocumentIdAsc = 'DOCUMENT_ID_ASC',
  DocumentIdDesc = 'DOCUMENT_ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  LinkAsc = 'LINK_ASC',
  LinkDesc = 'LINK_DESC',
  ContentHashAsc = 'CONTENT_HASH_ASC',
  ContentHashDesc = 'CONTENT_HASH_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  FiledAtAsc = 'FILED_AT_ASC',
  FiledAtDesc = 'FILED_AT_DESC',
  AssetIdAsc = 'ASSET_ID_ASC',
  AssetIdDesc = 'ASSET_ID_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
}

/** A filter to be used against `Asset` object types. All fields are combined with a logical ‘and.’ */
export type AssetFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `ticker` field. */
  ticker?: Maybe<StringFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `type` field. */
  type?: Maybe<StringFilter>;
  /** Filter by the object’s `fundingRound` field. */
  fundingRound?: Maybe<StringFilter>;
  /** Filter by the object’s `isDivisible` field. */
  isDivisible?: Maybe<BooleanFilter>;
  /** Filter by the object’s `isFrozen` field. */
  isFrozen?: Maybe<BooleanFilter>;
  /** Filter by the object’s `isUniquenessRequired` field. */
  isUniquenessRequired?: Maybe<BooleanFilter>;
  /** Filter by the object’s `identifiers` field. */
  identifiers?: Maybe<JsonFilter>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: Maybe<StringFilter>;
  /** Filter by the object’s `totalSupply` field. */
  totalSupply?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `totalTransfers` field. */
  totalTransfers?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `isCompliancePaused` field. */
  isCompliancePaused?: Maybe<BooleanFilter>;
  /** Filter by the object’s `eventIdx` field. */
  eventIdx?: Maybe<IntFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<AssetFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<AssetFilter>>;
  /** Negates the expression. */
  not?: Maybe<AssetFilter>;
};

export type AssetHolder = Node & {
  __typename?: 'AssetHolder';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  identityId: Scalars['String'];
  assetId: Scalars['String'];
  amount: Scalars['BigFloat'];
  createdBlockId: Scalars['String'];
  updatedBlockId: Scalars['String'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Identity` that is related to this `AssetHolder`. */
  identity?: Maybe<Identity>;
  /** Reads a single `Asset` that is related to this `AssetHolder`. */
  asset?: Maybe<Asset>;
  /** Reads a single `Block` that is related to this `AssetHolder`. */
  createdBlock?: Maybe<Block>;
  /** Reads a single `Block` that is related to this `AssetHolder`. */
  updatedBlock?: Maybe<Block>;
};

export type AssetHolderAggregates = {
  __typename?: 'AssetHolderAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `AssetHolder` object types. All fields are combined with a logical ‘and.’ */
export type AssetHolderFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `identityId` field. */
  identityId?: Maybe<StringFilter>;
  /** Filter by the object’s `assetId` field. */
  assetId?: Maybe<StringFilter>;
  /** Filter by the object’s `amount` field. */
  amount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<AssetHolderFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<AssetHolderFilter>>;
  /** Negates the expression. */
  not?: Maybe<AssetHolderFilter>;
};

/** A connection to a list of `AssetHolder` values. */
export type AssetHoldersConnection = {
  __typename?: 'AssetHoldersConnection';
  /** A list of `AssetHolder` objects. */
  nodes: Array<Maybe<AssetHolder>>;
  /** A list of edges which contains the `AssetHolder` and cursor to aid in pagination. */
  edges: Array<AssetHoldersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AssetHolder` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetHolderAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetHolderAggregates>>;
};

/** A connection to a list of `AssetHolder` values. */
export type AssetHoldersConnectionGroupedAggregatesArgs = {
  groupBy: Array<AssetHoldersGroupBy>;
  having?: Maybe<AssetHoldersHavingInput>;
};

/** A `AssetHolder` edge in the connection. */
export type AssetHoldersEdge = {
  __typename?: 'AssetHoldersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `AssetHolder` at the end of the edge. */
  node?: Maybe<AssetHolder>;
};

/** Grouping methods for `AssetHolder` for usage during aggregation. */
export enum AssetHoldersGroupBy {
  IdentityId = 'IDENTITY_ID',
  AssetId = 'ASSET_ID',
  Amount = 'AMOUNT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `AssetHolder` aggregates. */
export type AssetHoldersHavingInput = {
  AND?: Maybe<Array<AssetHoldersHavingInput>>;
  OR?: Maybe<Array<AssetHoldersHavingInput>>;
};

/** Methods to use when ordering `AssetHolder`. */
export enum AssetHoldersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IdentityIdAsc = 'IDENTITY_ID_ASC',
  IdentityIdDesc = 'IDENTITY_ID_DESC',
  AssetIdAsc = 'ASSET_ID_ASC',
  AssetIdDesc = 'ASSET_ID_DESC',
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
}

/** A connection to a list of `Identity` values, with data from `AssetHolder`. */
export type AssetIdentitiesByAssetHolderAssetIdAndIdentityIdManyToManyConnection = {
  __typename?: 'AssetIdentitiesByAssetHolderAssetIdAndIdentityIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `AssetHolder`, and the cursor to aid in pagination. */
  edges: Array<AssetIdentitiesByAssetHolderAssetIdAndIdentityIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `AssetHolder`. */
export type AssetIdentitiesByAssetHolderAssetIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `AssetHolder`. */
export type AssetIdentitiesByAssetHolderAssetIdAndIdentityIdManyToManyEdge = {
  __typename?: 'AssetIdentitiesByAssetHolderAssetIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `AssetHolder`. */
  heldAssets: AssetHoldersConnection;
};

/** A `Identity` edge in the connection, with data from `AssetHolder`. */
export type AssetIdentitiesByAssetHolderAssetIdAndIdentityIdManyToManyEdgeHeldAssetsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetHoldersOrderBy>>;
  filter?: Maybe<AssetHolderFilter>;
};

/** A connection to a list of `Identity` values, with data from `Distribution`. */
export type AssetIdentitiesByDistributionAssetIdAndIdentityIdManyToManyConnection = {
  __typename?: 'AssetIdentitiesByDistributionAssetIdAndIdentityIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<AssetIdentitiesByDistributionAssetIdAndIdentityIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `Distribution`. */
export type AssetIdentitiesByDistributionAssetIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Distribution`. */
export type AssetIdentitiesByDistributionAssetIdAndIdentityIdManyToManyEdge = {
  __typename?: 'AssetIdentitiesByDistributionAssetIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributions: DistributionsConnection;
};

/** A `Identity` edge in the connection, with data from `Distribution`. */
export type AssetIdentitiesByDistributionAssetIdAndIdentityIdManyToManyEdgeDistributionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<DistributionsOrderBy>>;
  filter?: Maybe<DistributionFilter>;
};

/** A connection to a list of `Identity` values, with data from `StatType`. */
export type AssetIdentitiesByStatTypeAssetIdAndClaimIssuerIdManyToManyConnection = {
  __typename?: 'AssetIdentitiesByStatTypeAssetIdAndClaimIssuerIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `StatType`, and the cursor to aid in pagination. */
  edges: Array<AssetIdentitiesByStatTypeAssetIdAndClaimIssuerIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `StatType`. */
export type AssetIdentitiesByStatTypeAssetIdAndClaimIssuerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `StatType`. */
export type AssetIdentitiesByStatTypeAssetIdAndClaimIssuerIdManyToManyEdge = {
  __typename?: 'AssetIdentitiesByStatTypeAssetIdAndClaimIssuerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypesByClaimIssuerId: StatTypesConnection;
};

/** A `Identity` edge in the connection, with data from `StatType`. */
export type AssetIdentitiesByStatTypeAssetIdAndClaimIssuerIdManyToManyEdgeStatTypesByClaimIssuerIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<StatTypesOrderBy>>;
    filter?: Maybe<StatTypeFilter>;
  };

/** A connection to a list of `Identity` values, with data from `TickerExternalAgentAction`. */
export type AssetIdentitiesByTickerExternalAgentActionAssetIdAndCallerIdManyToManyConnection = {
  __typename?: 'AssetIdentitiesByTickerExternalAgentActionAssetIdAndCallerIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `TickerExternalAgentAction`, and the cursor to aid in pagination. */
  edges: Array<AssetIdentitiesByTickerExternalAgentActionAssetIdAndCallerIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `TickerExternalAgentAction`. */
export type AssetIdentitiesByTickerExternalAgentActionAssetIdAndCallerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `TickerExternalAgentAction`. */
export type AssetIdentitiesByTickerExternalAgentActionAssetIdAndCallerIdManyToManyEdge = {
  __typename?: 'AssetIdentitiesByTickerExternalAgentActionAssetIdAndCallerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `TickerExternalAgentAction`. */
  tickerExternalAgentActionsByCallerId: TickerExternalAgentActionsConnection;
};

/** A `Identity` edge in the connection, with data from `TickerExternalAgentAction`. */
export type AssetIdentitiesByTickerExternalAgentActionAssetIdAndCallerIdManyToManyEdgeTickerExternalAgentActionsByCallerIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TickerExternalAgentActionsOrderBy>>;
    filter?: Maybe<TickerExternalAgentActionFilter>;
  };

/** A connection to a list of `Identity` values, with data from `TickerExternalAgent`. */
export type AssetIdentitiesByTickerExternalAgentAssetIdAndCallerIdManyToManyConnection = {
  __typename?: 'AssetIdentitiesByTickerExternalAgentAssetIdAndCallerIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `TickerExternalAgent`, and the cursor to aid in pagination. */
  edges: Array<AssetIdentitiesByTickerExternalAgentAssetIdAndCallerIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `TickerExternalAgent`. */
export type AssetIdentitiesByTickerExternalAgentAssetIdAndCallerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `TickerExternalAgent`. */
export type AssetIdentitiesByTickerExternalAgentAssetIdAndCallerIdManyToManyEdge = {
  __typename?: 'AssetIdentitiesByTickerExternalAgentAssetIdAndCallerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `TickerExternalAgent`. */
  tickerExternalAgentsByCallerId: TickerExternalAgentsConnection;
};

/** A `Identity` edge in the connection, with data from `TickerExternalAgent`. */
export type AssetIdentitiesByTickerExternalAgentAssetIdAndCallerIdManyToManyEdgeTickerExternalAgentsByCallerIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TickerExternalAgentsOrderBy>>;
    filter?: Maybe<TickerExternalAgentFilter>;
  };

/** A connection to a list of `Identity` values, with data from `TickerExternalAgentHistory`. */
export type AssetIdentitiesByTickerExternalAgentHistoryAssetIdAndIdentityIdManyToManyConnection = {
  __typename?: 'AssetIdentitiesByTickerExternalAgentHistoryAssetIdAndIdentityIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `TickerExternalAgentHistory`, and the cursor to aid in pagination. */
  edges: Array<AssetIdentitiesByTickerExternalAgentHistoryAssetIdAndIdentityIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `TickerExternalAgentHistory`. */
export type AssetIdentitiesByTickerExternalAgentHistoryAssetIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type AssetIdentitiesByTickerExternalAgentHistoryAssetIdAndIdentityIdManyToManyEdge = {
  __typename?: 'AssetIdentitiesByTickerExternalAgentHistoryAssetIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `TickerExternalAgentHistory`. */
  tickerExternalAgentHistories: TickerExternalAgentHistoriesConnection;
};

/** A `Identity` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type AssetIdentitiesByTickerExternalAgentHistoryAssetIdAndIdentityIdManyToManyEdgeTickerExternalAgentHistoriesArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TickerExternalAgentHistoriesOrderBy>>;
    filter?: Maybe<TickerExternalAgentHistoryFilter>;
  };

/** A connection to a list of `Identity` values, with data from `TransferCompliance`. */
export type AssetIdentitiesByTransferComplianceAssetIdAndClaimIssuerIdManyToManyConnection = {
  __typename?: 'AssetIdentitiesByTransferComplianceAssetIdAndClaimIssuerIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
  edges: Array<AssetIdentitiesByTransferComplianceAssetIdAndClaimIssuerIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `TransferCompliance`. */
export type AssetIdentitiesByTransferComplianceAssetIdAndClaimIssuerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `TransferCompliance`. */
export type AssetIdentitiesByTransferComplianceAssetIdAndClaimIssuerIdManyToManyEdge = {
  __typename?: 'AssetIdentitiesByTransferComplianceAssetIdAndClaimIssuerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliancesByClaimIssuerId: TransferCompliancesConnection;
};

/** A `Identity` edge in the connection, with data from `TransferCompliance`. */
export type AssetIdentitiesByTransferComplianceAssetIdAndClaimIssuerIdManyToManyEdgeTransferCompliancesByClaimIssuerIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TransferCompliancesOrderBy>>;
    filter?: Maybe<TransferComplianceFilter>;
  };

export type AssetPendingOwnershipTransfer = Node & {
  __typename?: 'AssetPendingOwnershipTransfer';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  ticker: Scalars['String'];
  from: Scalars['String'];
  to: Scalars['String'];
  type: Scalars['String'];
  data?: Maybe<Scalars['String']>;
  createdBlockId: Scalars['String'];
  updatedBlockId: Scalars['String'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Block` that is related to this `AssetPendingOwnershipTransfer`. */
  createdBlock?: Maybe<Block>;
  /** Reads a single `Block` that is related to this `AssetPendingOwnershipTransfer`. */
  updatedBlock?: Maybe<Block>;
};

export type AssetPendingOwnershipTransferAggregates = {
  __typename?: 'AssetPendingOwnershipTransferAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `AssetPendingOwnershipTransfer` object types. All fields are combined with a logical ‘and.’ */
export type AssetPendingOwnershipTransferFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `ticker` field. */
  ticker?: Maybe<StringFilter>;
  /** Filter by the object’s `from` field. */
  from?: Maybe<StringFilter>;
  /** Filter by the object’s `to` field. */
  to?: Maybe<StringFilter>;
  /** Filter by the object’s `type` field. */
  type?: Maybe<StringFilter>;
  /** Filter by the object’s `data` field. */
  data?: Maybe<StringFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<AssetPendingOwnershipTransferFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<AssetPendingOwnershipTransferFilter>>;
  /** Negates the expression. */
  not?: Maybe<AssetPendingOwnershipTransferFilter>;
};

/** A connection to a list of `AssetPendingOwnershipTransfer` values. */
export type AssetPendingOwnershipTransfersConnection = {
  __typename?: 'AssetPendingOwnershipTransfersConnection';
  /** A list of `AssetPendingOwnershipTransfer` objects. */
  nodes: Array<Maybe<AssetPendingOwnershipTransfer>>;
  /** A list of edges which contains the `AssetPendingOwnershipTransfer` and cursor to aid in pagination. */
  edges: Array<AssetPendingOwnershipTransfersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AssetPendingOwnershipTransfer` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetPendingOwnershipTransferAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetPendingOwnershipTransferAggregates>>;
};

/** A connection to a list of `AssetPendingOwnershipTransfer` values. */
export type AssetPendingOwnershipTransfersConnectionGroupedAggregatesArgs = {
  groupBy: Array<AssetPendingOwnershipTransfersGroupBy>;
  having?: Maybe<AssetPendingOwnershipTransfersHavingInput>;
};

/** A `AssetPendingOwnershipTransfer` edge in the connection. */
export type AssetPendingOwnershipTransfersEdge = {
  __typename?: 'AssetPendingOwnershipTransfersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `AssetPendingOwnershipTransfer` at the end of the edge. */
  node?: Maybe<AssetPendingOwnershipTransfer>;
};

/** Grouping methods for `AssetPendingOwnershipTransfer` for usage during aggregation. */
export enum AssetPendingOwnershipTransfersGroupBy {
  Ticker = 'TICKER',
  From = 'FROM',
  To = 'TO',
  Type = 'TYPE',
  Data = 'DATA',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `AssetPendingOwnershipTransfer` aggregates. */
export type AssetPendingOwnershipTransfersHavingInput = {
  AND?: Maybe<Array<AssetPendingOwnershipTransfersHavingInput>>;
  OR?: Maybe<Array<AssetPendingOwnershipTransfersHavingInput>>;
};

/** Methods to use when ordering `AssetPendingOwnershipTransfer`. */
export enum AssetPendingOwnershipTransfersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  TickerAsc = 'TICKER_ASC',
  TickerDesc = 'TICKER_DESC',
  FromAsc = 'FROM_ASC',
  FromDesc = 'FROM_DESC',
  ToAsc = 'TO_ASC',
  ToDesc = 'TO_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  DataAsc = 'DATA_ASC',
  DataDesc = 'DATA_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
}

/** A connection to a list of `Portfolio` values, with data from `Distribution`. */
export type AssetPortfoliosByDistributionAssetIdAndPortfolioIdManyToManyConnection = {
  __typename?: 'AssetPortfoliosByDistributionAssetIdAndPortfolioIdManyToManyConnection';
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** A list of edges which contains the `Portfolio`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<AssetPortfoliosByDistributionAssetIdAndPortfolioIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
};

/** A connection to a list of `Portfolio` values, with data from `Distribution`. */
export type AssetPortfoliosByDistributionAssetIdAndPortfolioIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: Maybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `Distribution`. */
export type AssetPortfoliosByDistributionAssetIdAndPortfolioIdManyToManyEdge = {
  __typename?: 'AssetPortfoliosByDistributionAssetIdAndPortfolioIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributions: DistributionsConnection;
};

/** A `Portfolio` edge in the connection, with data from `Distribution`. */
export type AssetPortfoliosByDistributionAssetIdAndPortfolioIdManyToManyEdgeDistributionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<DistributionsOrderBy>>;
  filter?: Maybe<DistributionFilter>;
};

/** A connection to a list of `Portfolio` values, with data from `PortfolioMovement`. */
export type AssetPortfoliosByPortfolioMovementAssetIdAndFromIdManyToManyConnection = {
  __typename?: 'AssetPortfoliosByPortfolioMovementAssetIdAndFromIdManyToManyConnection';
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** A list of edges which contains the `Portfolio`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<AssetPortfoliosByPortfolioMovementAssetIdAndFromIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
};

/** A connection to a list of `Portfolio` values, with data from `PortfolioMovement`. */
export type AssetPortfoliosByPortfolioMovementAssetIdAndFromIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: Maybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `PortfolioMovement`. */
export type AssetPortfoliosByPortfolioMovementAssetIdAndFromIdManyToManyEdge = {
  __typename?: 'AssetPortfoliosByPortfolioMovementAssetIdAndFromIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByFromId: PortfolioMovementsConnection;
};

/** A `Portfolio` edge in the connection, with data from `PortfolioMovement`. */
export type AssetPortfoliosByPortfolioMovementAssetIdAndFromIdManyToManyEdgePortfolioMovementsByFromIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<PortfolioMovementsOrderBy>>;
    filter?: Maybe<PortfolioMovementFilter>;
  };

/** A connection to a list of `Portfolio` values, with data from `PortfolioMovement`. */
export type AssetPortfoliosByPortfolioMovementAssetIdAndToIdManyToManyConnection = {
  __typename?: 'AssetPortfoliosByPortfolioMovementAssetIdAndToIdManyToManyConnection';
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** A list of edges which contains the `Portfolio`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<AssetPortfoliosByPortfolioMovementAssetIdAndToIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
};

/** A connection to a list of `Portfolio` values, with data from `PortfolioMovement`. */
export type AssetPortfoliosByPortfolioMovementAssetIdAndToIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: Maybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `PortfolioMovement`. */
export type AssetPortfoliosByPortfolioMovementAssetIdAndToIdManyToManyEdge = {
  __typename?: 'AssetPortfoliosByPortfolioMovementAssetIdAndToIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByToId: PortfolioMovementsConnection;
};

/** A `Portfolio` edge in the connection, with data from `PortfolioMovement`. */
export type AssetPortfoliosByPortfolioMovementAssetIdAndToIdManyToManyEdgePortfolioMovementsByToIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<PortfolioMovementsOrderBy>>;
    filter?: Maybe<PortfolioMovementFilter>;
  };

/** A connection to a list of `StatType` values, with data from `TransferCompliance`. */
export type AssetStatTypesByTransferComplianceAssetIdAndStatTypeIdManyToManyConnection = {
  __typename?: 'AssetStatTypesByTransferComplianceAssetIdAndStatTypeIdManyToManyConnection';
  /** A list of `StatType` objects. */
  nodes: Array<Maybe<StatType>>;
  /** A list of edges which contains the `StatType`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
  edges: Array<AssetStatTypesByTransferComplianceAssetIdAndStatTypeIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `StatType` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<StatTypeAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<StatTypeAggregates>>;
};

/** A connection to a list of `StatType` values, with data from `TransferCompliance`. */
export type AssetStatTypesByTransferComplianceAssetIdAndStatTypeIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<StatTypesGroupBy>;
    having?: Maybe<StatTypesHavingInput>;
  };

/** A `StatType` edge in the connection, with data from `TransferCompliance`. */
export type AssetStatTypesByTransferComplianceAssetIdAndStatTypeIdManyToManyEdge = {
  __typename?: 'AssetStatTypesByTransferComplianceAssetIdAndStatTypeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `StatType` at the end of the edge. */
  node?: Maybe<StatType>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliances: TransferCompliancesConnection;
};

/** A `StatType` edge in the connection, with data from `TransferCompliance`. */
export type AssetStatTypesByTransferComplianceAssetIdAndStatTypeIdManyToManyEdgeTransferCompliancesArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TransferCompliancesOrderBy>>;
    filter?: Maybe<TransferComplianceFilter>;
  };

/** A connection to a list of `Asset` values. */
export type AssetsConnection = {
  __typename?: 'AssetsConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset` and cursor to aid in pagination. */
  edges: Array<AssetsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values. */
export type AssetsConnectionGroupedAggregatesArgs = {
  groupBy: Array<AssetsGroupBy>;
  having?: Maybe<AssetsHavingInput>;
};

/** A `Asset` edge in the connection. */
export type AssetsEdge = {
  __typename?: 'AssetsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
};

/** Grouping methods for `Asset` for usage during aggregation. */
export enum AssetsGroupBy {
  Name = 'NAME',
  Type = 'TYPE',
  FundingRound = 'FUNDING_ROUND',
  IsDivisible = 'IS_DIVISIBLE',
  IsFrozen = 'IS_FROZEN',
  IsUniquenessRequired = 'IS_UNIQUENESS_REQUIRED',
  Identifiers = 'IDENTIFIERS',
  OwnerId = 'OWNER_ID',
  TotalSupply = 'TOTAL_SUPPLY',
  TotalTransfers = 'TOTAL_TRANSFERS',
  IsCompliancePaused = 'IS_COMPLIANCE_PAUSED',
  EventIdx = 'EVENT_IDX',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `Asset` aggregates. */
export type AssetsHavingInput = {
  AND?: Maybe<Array<AssetsHavingInput>>;
  OR?: Maybe<Array<AssetsHavingInput>>;
};

/** Methods to use when ordering `Asset`. */
export enum AssetsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  TickerAsc = 'TICKER_ASC',
  TickerDesc = 'TICKER_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  FundingRoundAsc = 'FUNDING_ROUND_ASC',
  FundingRoundDesc = 'FUNDING_ROUND_DESC',
  IsDivisibleAsc = 'IS_DIVISIBLE_ASC',
  IsDivisibleDesc = 'IS_DIVISIBLE_DESC',
  IsFrozenAsc = 'IS_FROZEN_ASC',
  IsFrozenDesc = 'IS_FROZEN_DESC',
  IsUniquenessRequiredAsc = 'IS_UNIQUENESS_REQUIRED_ASC',
  IsUniquenessRequiredDesc = 'IS_UNIQUENESS_REQUIRED_DESC',
  IdentifiersAsc = 'IDENTIFIERS_ASC',
  IdentifiersDesc = 'IDENTIFIERS_DESC',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  TotalSupplyAsc = 'TOTAL_SUPPLY_ASC',
  TotalSupplyDesc = 'TOTAL_SUPPLY_DESC',
  TotalTransfersAsc = 'TOTAL_TRANSFERS_ASC',
  TotalTransfersDesc = 'TOTAL_TRANSFERS_DESC',
  IsCompliancePausedAsc = 'IS_COMPLIANCE_PAUSED_ASC',
  IsCompliancePausedDesc = 'IS_COMPLIANCE_PAUSED_DESC',
  EventIdxAsc = 'EVENT_IDX_ASC',
  EventIdxDesc = 'EVENT_IDX_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TickerExternalAgentActionsCountAsc = 'TICKER_EXTERNAL_AGENT_ACTIONS_COUNT_ASC',
  TickerExternalAgentActionsCountDesc = 'TICKER_EXTERNAL_AGENT_ACTIONS_COUNT_DESC',
  StosByOfferingAssetIdCountAsc = 'STOS_BY_OFFERING_ASSET_ID_COUNT_ASC',
  StosByOfferingAssetIdCountDesc = 'STOS_BY_OFFERING_ASSET_ID_COUNT_DESC',
  TickerExternalAgentsCountAsc = 'TICKER_EXTERNAL_AGENTS_COUNT_ASC',
  TickerExternalAgentsCountDesc = 'TICKER_EXTERNAL_AGENTS_COUNT_DESC',
  TickerExternalAgentHistoriesCountAsc = 'TICKER_EXTERNAL_AGENT_HISTORIES_COUNT_ASC',
  TickerExternalAgentHistoriesCountDesc = 'TICKER_EXTERNAL_AGENT_HISTORIES_COUNT_DESC',
  PortfolioMovementsCountAsc = 'PORTFOLIO_MOVEMENTS_COUNT_ASC',
  PortfolioMovementsCountDesc = 'PORTFOLIO_MOVEMENTS_COUNT_DESC',
  DistributionsCountAsc = 'DISTRIBUTIONS_COUNT_ASC',
  DistributionsCountDesc = 'DISTRIBUTIONS_COUNT_DESC',
  TrustedClaimIssuersCountAsc = 'TRUSTED_CLAIM_ISSUERS_COUNT_ASC',
  TrustedClaimIssuersCountDesc = 'TRUSTED_CLAIM_ISSUERS_COUNT_DESC',
  TransferManagersCountAsc = 'TRANSFER_MANAGERS_COUNT_ASC',
  TransferManagersCountDesc = 'TRANSFER_MANAGERS_COUNT_DESC',
  StatTypesCountAsc = 'STAT_TYPES_COUNT_ASC',
  StatTypesCountDesc = 'STAT_TYPES_COUNT_DESC',
  TransferCompliancesCountAsc = 'TRANSFER_COMPLIANCES_COUNT_ASC',
  TransferCompliancesCountDesc = 'TRANSFER_COMPLIANCES_COUNT_DESC',
  TransferComplianceExemptionsCountAsc = 'TRANSFER_COMPLIANCE_EXEMPTIONS_COUNT_ASC',
  TransferComplianceExemptionsCountDesc = 'TRANSFER_COMPLIANCE_EXEMPTIONS_COUNT_DESC',
  ComplianceCountAsc = 'COMPLIANCE_COUNT_ASC',
  ComplianceCountDesc = 'COMPLIANCE_COUNT_DESC',
  HoldersCountAsc = 'HOLDERS_COUNT_ASC',
  HoldersCountDesc = 'HOLDERS_COUNT_DESC',
  DocumentsCountAsc = 'DOCUMENTS_COUNT_ASC',
  DocumentsCountDesc = 'DOCUMENTS_COUNT_DESC',
  FundingsCountAsc = 'FUNDINGS_COUNT_ASC',
  FundingsCountDesc = 'FUNDINGS_COUNT_DESC',
}

export type Authorization = Node & {
  __typename?: 'Authorization';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  type: Scalars['String'];
  fromId: Scalars['String'];
  toId?: Maybe<Scalars['String']>;
  toKey?: Maybe<Scalars['String']>;
  data?: Maybe<Scalars['String']>;
  expiry?: Maybe<Scalars['Datetime']>;
  status: Scalars['String'];
  createdBlockId: Scalars['String'];
  updatedBlockId: Scalars['String'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Identity` that is related to this `Authorization`. */
  from?: Maybe<Identity>;
  /** Reads a single `Identity` that is related to this `Authorization`. */
  to?: Maybe<Identity>;
  /** Reads a single `Block` that is related to this `Authorization`. */
  createdBlock?: Maybe<Block>;
  /** Reads a single `Block` that is related to this `Authorization`. */
  updatedBlock?: Maybe<Block>;
};

export type AuthorizationAggregates = {
  __typename?: 'AuthorizationAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `Authorization` object types. All fields are combined with a logical ‘and.’ */
export type AuthorizationFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `type` field. */
  type?: Maybe<StringFilter>;
  /** Filter by the object’s `fromId` field. */
  fromId?: Maybe<StringFilter>;
  /** Filter by the object’s `toId` field. */
  toId?: Maybe<StringFilter>;
  /** Filter by the object’s `toKey` field. */
  toKey?: Maybe<StringFilter>;
  /** Filter by the object’s `data` field. */
  data?: Maybe<StringFilter>;
  /** Filter by the object’s `expiry` field. */
  expiry?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `status` field. */
  status?: Maybe<StringFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<AuthorizationFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<AuthorizationFilter>>;
  /** Negates the expression. */
  not?: Maybe<AuthorizationFilter>;
};

/** A connection to a list of `Authorization` values. */
export type AuthorizationsConnection = {
  __typename?: 'AuthorizationsConnection';
  /** A list of `Authorization` objects. */
  nodes: Array<Maybe<Authorization>>;
  /** A list of edges which contains the `Authorization` and cursor to aid in pagination. */
  edges: Array<AuthorizationsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Authorization` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AuthorizationAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AuthorizationAggregates>>;
};

/** A connection to a list of `Authorization` values. */
export type AuthorizationsConnectionGroupedAggregatesArgs = {
  groupBy: Array<AuthorizationsGroupBy>;
  having?: Maybe<AuthorizationsHavingInput>;
};

/** A `Authorization` edge in the connection. */
export type AuthorizationsEdge = {
  __typename?: 'AuthorizationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Authorization` at the end of the edge. */
  node?: Maybe<Authorization>;
};

/** Grouping methods for `Authorization` for usage during aggregation. */
export enum AuthorizationsGroupBy {
  Type = 'TYPE',
  FromId = 'FROM_ID',
  ToId = 'TO_ID',
  ToKey = 'TO_KEY',
  Data = 'DATA',
  Expiry = 'EXPIRY',
  Status = 'STATUS',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `Authorization` aggregates. */
export type AuthorizationsHavingInput = {
  AND?: Maybe<Array<AuthorizationsHavingInput>>;
  OR?: Maybe<Array<AuthorizationsHavingInput>>;
};

/** Methods to use when ordering `Authorization`. */
export enum AuthorizationsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  FromIdAsc = 'FROM_ID_ASC',
  FromIdDesc = 'FROM_ID_DESC',
  ToIdAsc = 'TO_ID_ASC',
  ToIdDesc = 'TO_ID_DESC',
  ToKeyAsc = 'TO_KEY_ASC',
  ToKeyDesc = 'TO_KEY_DESC',
  DataAsc = 'DATA_ASC',
  DataDesc = 'DATA_DESC',
  ExpiryAsc = 'EXPIRY_ASC',
  ExpiryDesc = 'EXPIRY_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
}

/** A filter to be used against BigFloat fields. All fields are combined with a logical ‘and.’ */
export type BigFloatFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['BigFloat']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['BigFloat']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['BigFloat']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['BigFloat']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['BigFloat']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['BigFloat']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['BigFloat']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['BigFloat']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['BigFloat']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['BigFloat']>;
};

export type Block = Node & {
  __typename?: 'Block';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  blockId: Scalars['Int'];
  parentId: Scalars['Int'];
  hash: Scalars['String'];
  parentHash: Scalars['String'];
  stateRoot: Scalars['String'];
  extrinsicsRoot: Scalars['String'];
  countExtrinsics: Scalars['Int'];
  countExtrinsicsUnsigned: Scalars['Int'];
  countExtrinsicsSigned: Scalars['Int'];
  countExtrinsicsError: Scalars['Int'];
  countExtrinsicsSuccess: Scalars['Int'];
  countEvents: Scalars['Int'];
  datetime: Scalars['Datetime'];
  specVersionId: Scalars['Int'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads and enables pagination through a set of `Event`. */
  events: EventsConnection;
  /** Reads and enables pagination through a set of `Extrinsic`. */
  extrinsics: ExtrinsicsConnection;
  /** Reads and enables pagination through a set of `Permission`. */
  permissionsByCreatedBlockId: PermissionsConnection;
  /** Reads and enables pagination through a set of `Permission`. */
  permissionsByUpdatedBlockId: PermissionsConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByCreatedBlockId: IdentitiesConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByUpdatedBlockId: IdentitiesConnection;
  /** Reads and enables pagination through a set of `Account`. */
  accountsByCreatedBlockId: AccountsConnection;
  /** Reads and enables pagination through a set of `Account`. */
  accountsByUpdatedBlockId: AccountsConnection;
  /** Reads and enables pagination through a set of `BridgeEvent`. */
  bridgeEventsByCreatedBlockId: BridgeEventsConnection;
  /** Reads and enables pagination through a set of `BridgeEvent`. */
  bridgeEventsByUpdatedBlockId: BridgeEventsConnection;
  /** Reads and enables pagination through a set of `StakingEvent`. */
  stakingEventsByCreatedBlockId: StakingEventsConnection;
  /** Reads and enables pagination through a set of `StakingEvent`. */
  stakingEventsByUpdatedBlockId: StakingEventsConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByCreatedBlockId: AssetsConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByUpdatedBlockId: AssetsConnection;
  /** Reads and enables pagination through a set of `TickerExternalAgentAction`. */
  tickerExternalAgentActionsByCreatedBlockId: TickerExternalAgentActionsConnection;
  /** Reads and enables pagination through a set of `TickerExternalAgentAction`. */
  tickerExternalAgentActionsByUpdatedBlockId: TickerExternalAgentActionsConnection;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByCreatedBlockId: StosConnection;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByUpdatedBlockId: StosConnection;
  /** Reads and enables pagination through a set of `Authorization`. */
  authorizationsByCreatedBlockId: AuthorizationsConnection;
  /** Reads and enables pagination through a set of `Authorization`. */
  authorizationsByUpdatedBlockId: AuthorizationsConnection;
  /** Reads and enables pagination through a set of `Investment`. */
  investmentsByCreatedBlockId: InvestmentsConnection;
  /** Reads and enables pagination through a set of `Investment`. */
  investmentsByUpdatedBlockId: InvestmentsConnection;
  /** Reads and enables pagination through a set of `TickerExternalAgent`. */
  tickerExternalAgentsByCreatedBlockId: TickerExternalAgentsConnection;
  /** Reads and enables pagination through a set of `TickerExternalAgent`. */
  tickerExternalAgentsByUpdatedBlockId: TickerExternalAgentsConnection;
  /** Reads and enables pagination through a set of `TickerExternalAgentHistory`. */
  tickerExternalAgentHistoriesByCreatedBlockId: TickerExternalAgentHistoriesConnection;
  /** Reads and enables pagination through a set of `TickerExternalAgentHistory`. */
  tickerExternalAgentHistoriesByUpdatedBlockId: TickerExternalAgentHistoriesConnection;
  /** Reads and enables pagination through a set of `AgentGroup`. */
  agentGroupsByCreatedBlockId: AgentGroupsConnection;
  /** Reads and enables pagination through a set of `AgentGroup`. */
  agentGroupsByUpdatedBlockId: AgentGroupsConnection;
  /** Reads and enables pagination through a set of `AgentGroupMembership`. */
  agentGroupMembershipsByCreatedBlockId: AgentGroupMembershipsConnection;
  /** Reads and enables pagination through a set of `AgentGroupMembership`. */
  agentGroupMembershipsByUpdatedBlockId: AgentGroupMembershipsConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByCreatedBlockId: PortfoliosConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByUpdatedBlockId: PortfoliosConnection;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByCreatedBlockId: PortfolioMovementsConnection;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByUpdatedBlockId: PortfolioMovementsConnection;
  /** Reads and enables pagination through a set of `Venue`. */
  venuesByCreatedBlockId: VenuesConnection;
  /** Reads and enables pagination through a set of `Venue`. */
  venuesByUpdatedBlockId: VenuesConnection;
  /** Reads and enables pagination through a set of `Instruction`. */
  instructionsByCreatedBlockId: InstructionsConnection;
  /** Reads and enables pagination through a set of `Instruction`. */
  instructionsByUpdatedBlockId: InstructionsConnection;
  /** Reads and enables pagination through a set of `Settlement`. */
  settlementsByCreatedBlockId: SettlementsConnection;
  /** Reads and enables pagination through a set of `Settlement`. */
  settlementsByUpdatedBlockId: SettlementsConnection;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByCreatedBlockId: LegsConnection;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByUpdatedBlockId: LegsConnection;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributionsByCreatedBlockId: DistributionsConnection;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributionsByUpdatedBlockId: DistributionsConnection;
  /** Reads and enables pagination through a set of `DistributionPayment`. */
  distributionPaymentsByCreatedBlockId: DistributionPaymentsConnection;
  /** Reads and enables pagination through a set of `DistributionPayment`. */
  distributionPaymentsByUpdatedBlockId: DistributionPaymentsConnection;
  /** Reads and enables pagination through a set of `Proposal`. */
  proposalsByCreatedBlockId: ProposalsConnection;
  /** Reads and enables pagination through a set of `Proposal`. */
  proposalsByUpdatedBlockId: ProposalsConnection;
  /** Reads and enables pagination through a set of `ProposalVote`. */
  proposalVotesByCreatedBlockId: ProposalVotesConnection;
  /** Reads and enables pagination through a set of `ProposalVote`. */
  proposalVotesByUpdatedBlockId: ProposalVotesConnection;
  /** Reads and enables pagination through a set of `ClaimScope`. */
  claimScopesByCreatedBlockId: ClaimScopesConnection;
  /** Reads and enables pagination through a set of `ClaimScope`. */
  claimScopesByUpdatedBlockId: ClaimScopesConnection;
  /** Reads and enables pagination through a set of `Claim`. */
  claimsByCreatedBlockId: ClaimsConnection;
  /** Reads and enables pagination through a set of `Claim`. */
  claimsByUpdatedBlockId: ClaimsConnection;
  /** Reads and enables pagination through a set of `TrustedClaimIssuer`. */
  trustedClaimIssuersByCreatedBlockId: TrustedClaimIssuersConnection;
  /** Reads and enables pagination through a set of `TrustedClaimIssuer`. */
  trustedClaimIssuersByUpdatedBlockId: TrustedClaimIssuersConnection;
  /** Reads and enables pagination through a set of `AssetPendingOwnershipTransfer`. */
  assetPendingOwnershipTransfersByCreatedBlockId: AssetPendingOwnershipTransfersConnection;
  /** Reads and enables pagination through a set of `AssetPendingOwnershipTransfer`. */
  assetPendingOwnershipTransfersByUpdatedBlockId: AssetPendingOwnershipTransfersConnection;
  /** Reads and enables pagination through a set of `TransferManager`. */
  transferManagersByCreatedBlockId: TransferManagersConnection;
  /** Reads and enables pagination through a set of `TransferManager`. */
  transferManagersByUpdatedBlockId: TransferManagersConnection;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypesByCreatedBlockId: StatTypesConnection;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypesByUpdatedBlockId: StatTypesConnection;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliancesByCreatedBlockId: TransferCompliancesConnection;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliancesByUpdatedBlockId: TransferCompliancesConnection;
  /** Reads and enables pagination through a set of `TransferComplianceExemption`. */
  transferComplianceExemptionsByCreatedBlockId: TransferComplianceExemptionsConnection;
  /** Reads and enables pagination through a set of `TransferComplianceExemption`. */
  transferComplianceExemptionsByUpdatedBlockId: TransferComplianceExemptionsConnection;
  /** Reads and enables pagination through a set of `Compliance`. */
  compliancesByCreatedBlockId: CompliancesConnection;
  /** Reads and enables pagination through a set of `Compliance`. */
  compliancesByUpdatedBlockId: CompliancesConnection;
  /** Reads and enables pagination through a set of `AssetHolder`. */
  assetHoldersByCreatedBlockId: AssetHoldersConnection;
  /** Reads and enables pagination through a set of `AssetHolder`. */
  assetHoldersByUpdatedBlockId: AssetHoldersConnection;
  /** Reads and enables pagination through a set of `AssetDocument`. */
  assetDocumentsByCreatedBlockId: AssetDocumentsConnection;
  /** Reads and enables pagination through a set of `AssetDocument`. */
  assetDocumentsByUpdatedBlockId: AssetDocumentsConnection;
  /** Reads and enables pagination through a set of `Funding`. */
  fundingsByCreatedBlockId: FundingsConnection;
  /** Reads and enables pagination through a set of `Funding`. */
  fundingsByUpdatedBlockId: FundingsConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByPermissionCreatedBlockIdAndUpdatedBlockId: BlockBlocksByPermissionCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByPermissionUpdatedBlockIdAndCreatedBlockId: BlockBlocksByPermissionUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByIdentityCreatedBlockIdAndUpdatedBlockId: BlockBlocksByIdentityCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByIdentityUpdatedBlockIdAndCreatedBlockId: BlockBlocksByIdentityUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByAccountCreatedBlockIdAndIdentityId: BlockIdentitiesByAccountCreatedBlockIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Permission`. */
  permissionsByAccountCreatedBlockIdAndPermissionsId: BlockPermissionsByAccountCreatedBlockIdAndPermissionsIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAccountCreatedBlockIdAndUpdatedBlockId: BlockBlocksByAccountCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByAccountUpdatedBlockIdAndIdentityId: BlockIdentitiesByAccountUpdatedBlockIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Permission`. */
  permissionsByAccountUpdatedBlockIdAndPermissionsId: BlockPermissionsByAccountUpdatedBlockIdAndPermissionsIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAccountUpdatedBlockIdAndCreatedBlockId: BlockBlocksByAccountUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByBridgeEventCreatedBlockIdAndIdentityId: BlockIdentitiesByBridgeEventCreatedBlockIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByBridgeEventCreatedBlockIdAndUpdatedBlockId: BlockBlocksByBridgeEventCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByBridgeEventUpdatedBlockIdAndIdentityId: BlockIdentitiesByBridgeEventUpdatedBlockIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByBridgeEventUpdatedBlockIdAndCreatedBlockId: BlockBlocksByBridgeEventUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByStakingEventCreatedBlockIdAndIdentityId: BlockIdentitiesByStakingEventCreatedBlockIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByStakingEventCreatedBlockIdAndUpdatedBlockId: BlockBlocksByStakingEventCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByStakingEventUpdatedBlockIdAndIdentityId: BlockIdentitiesByStakingEventUpdatedBlockIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByStakingEventUpdatedBlockIdAndCreatedBlockId: BlockBlocksByStakingEventUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByAssetCreatedBlockIdAndOwnerId: BlockIdentitiesByAssetCreatedBlockIdAndOwnerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetCreatedBlockIdAndUpdatedBlockId: BlockBlocksByAssetCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByAssetUpdatedBlockIdAndOwnerId: BlockIdentitiesByAssetUpdatedBlockIdAndOwnerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetUpdatedBlockIdAndCreatedBlockId: BlockBlocksByAssetUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTickerExternalAgentActionCreatedBlockIdAndAssetId: BlockAssetsByTickerExternalAgentActionCreatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByTickerExternalAgentActionCreatedBlockIdAndCallerId: BlockIdentitiesByTickerExternalAgentActionCreatedBlockIdAndCallerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTickerExternalAgentActionCreatedBlockIdAndUpdatedBlockId: BlockBlocksByTickerExternalAgentActionCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTickerExternalAgentActionUpdatedBlockIdAndAssetId: BlockAssetsByTickerExternalAgentActionUpdatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByTickerExternalAgentActionUpdatedBlockIdAndCallerId: BlockIdentitiesByTickerExternalAgentActionUpdatedBlockIdAndCallerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTickerExternalAgentActionUpdatedBlockIdAndCreatedBlockId: BlockBlocksByTickerExternalAgentActionUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByStoCreatedBlockIdAndOfferingAssetId: BlockAssetsByStoCreatedBlockIdAndOfferingAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByStoCreatedBlockIdAndUpdatedBlockId: BlockBlocksByStoCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByStoUpdatedBlockIdAndOfferingAssetId: BlockAssetsByStoUpdatedBlockIdAndOfferingAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByStoUpdatedBlockIdAndCreatedBlockId: BlockBlocksByStoUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByAuthorizationCreatedBlockIdAndFromId: BlockIdentitiesByAuthorizationCreatedBlockIdAndFromIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByAuthorizationCreatedBlockIdAndToId: BlockIdentitiesByAuthorizationCreatedBlockIdAndToIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAuthorizationCreatedBlockIdAndUpdatedBlockId: BlockBlocksByAuthorizationCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByAuthorizationUpdatedBlockIdAndFromId: BlockIdentitiesByAuthorizationUpdatedBlockIdAndFromIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByAuthorizationUpdatedBlockIdAndToId: BlockIdentitiesByAuthorizationUpdatedBlockIdAndToIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAuthorizationUpdatedBlockIdAndCreatedBlockId: BlockBlocksByAuthorizationUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByInvestmentCreatedBlockIdAndInvestorId: BlockIdentitiesByInvestmentCreatedBlockIdAndInvestorIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByInvestmentCreatedBlockIdAndUpdatedBlockId: BlockBlocksByInvestmentCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByInvestmentUpdatedBlockIdAndInvestorId: BlockIdentitiesByInvestmentUpdatedBlockIdAndInvestorIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByInvestmentUpdatedBlockIdAndCreatedBlockId: BlockBlocksByInvestmentUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTickerExternalAgentCreatedBlockIdAndAssetId: BlockAssetsByTickerExternalAgentCreatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByTickerExternalAgentCreatedBlockIdAndCallerId: BlockIdentitiesByTickerExternalAgentCreatedBlockIdAndCallerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTickerExternalAgentCreatedBlockIdAndUpdatedBlockId: BlockBlocksByTickerExternalAgentCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTickerExternalAgentUpdatedBlockIdAndAssetId: BlockAssetsByTickerExternalAgentUpdatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByTickerExternalAgentUpdatedBlockIdAndCallerId: BlockIdentitiesByTickerExternalAgentUpdatedBlockIdAndCallerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTickerExternalAgentUpdatedBlockIdAndCreatedBlockId: BlockBlocksByTickerExternalAgentUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTickerExternalAgentHistoryCreatedBlockIdAndAssetId: BlockAssetsByTickerExternalAgentHistoryCreatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByTickerExternalAgentHistoryCreatedBlockIdAndIdentityId: BlockIdentitiesByTickerExternalAgentHistoryCreatedBlockIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTickerExternalAgentHistoryCreatedBlockIdAndUpdatedBlockId: BlockBlocksByTickerExternalAgentHistoryCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTickerExternalAgentHistoryUpdatedBlockIdAndAssetId: BlockAssetsByTickerExternalAgentHistoryUpdatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByTickerExternalAgentHistoryUpdatedBlockIdAndIdentityId: BlockIdentitiesByTickerExternalAgentHistoryUpdatedBlockIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTickerExternalAgentHistoryUpdatedBlockIdAndCreatedBlockId: BlockBlocksByTickerExternalAgentHistoryUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAgentGroupCreatedBlockIdAndUpdatedBlockId: BlockBlocksByAgentGroupCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAgentGroupUpdatedBlockIdAndCreatedBlockId: BlockBlocksByAgentGroupUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `AgentGroup`. */
  agentGroupsByAgentGroupMembershipCreatedBlockIdAndGroupId: BlockAgentGroupsByAgentGroupMembershipCreatedBlockIdAndGroupIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAgentGroupMembershipCreatedBlockIdAndUpdatedBlockId: BlockBlocksByAgentGroupMembershipCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `AgentGroup`. */
  agentGroupsByAgentGroupMembershipUpdatedBlockIdAndGroupId: BlockAgentGroupsByAgentGroupMembershipUpdatedBlockIdAndGroupIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAgentGroupMembershipUpdatedBlockIdAndCreatedBlockId: BlockBlocksByAgentGroupMembershipUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByPortfolioCreatedBlockIdAndIdentityId: BlockIdentitiesByPortfolioCreatedBlockIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByPortfolioCreatedBlockIdAndCustodianId: BlockIdentitiesByPortfolioCreatedBlockIdAndCustodianIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByPortfolioCreatedBlockIdAndUpdatedBlockId: BlockBlocksByPortfolioCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByPortfolioUpdatedBlockIdAndIdentityId: BlockIdentitiesByPortfolioUpdatedBlockIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByPortfolioUpdatedBlockIdAndCustodianId: BlockIdentitiesByPortfolioUpdatedBlockIdAndCustodianIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByPortfolioUpdatedBlockIdAndCreatedBlockId: BlockBlocksByPortfolioUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByPortfolioMovementCreatedBlockIdAndFromId: BlockPortfoliosByPortfolioMovementCreatedBlockIdAndFromIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByPortfolioMovementCreatedBlockIdAndToId: BlockPortfoliosByPortfolioMovementCreatedBlockIdAndToIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByPortfolioMovementCreatedBlockIdAndAssetId: BlockAssetsByPortfolioMovementCreatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByPortfolioMovementCreatedBlockIdAndUpdatedBlockId: BlockBlocksByPortfolioMovementCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByPortfolioMovementUpdatedBlockIdAndFromId: BlockPortfoliosByPortfolioMovementUpdatedBlockIdAndFromIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByPortfolioMovementUpdatedBlockIdAndToId: BlockPortfoliosByPortfolioMovementUpdatedBlockIdAndToIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByPortfolioMovementUpdatedBlockIdAndAssetId: BlockAssetsByPortfolioMovementUpdatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByPortfolioMovementUpdatedBlockIdAndCreatedBlockId: BlockBlocksByPortfolioMovementUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByVenueCreatedBlockIdAndOwnerId: BlockIdentitiesByVenueCreatedBlockIdAndOwnerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByVenueCreatedBlockIdAndUpdatedBlockId: BlockBlocksByVenueCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByVenueUpdatedBlockIdAndOwnerId: BlockIdentitiesByVenueUpdatedBlockIdAndOwnerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByVenueUpdatedBlockIdAndCreatedBlockId: BlockBlocksByVenueUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Venue`. */
  venuesByInstructionCreatedBlockIdAndVenueId: BlockVenuesByInstructionCreatedBlockIdAndVenueIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByInstructionCreatedBlockIdAndUpdatedBlockId: BlockBlocksByInstructionCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Venue`. */
  venuesByInstructionUpdatedBlockIdAndVenueId: BlockVenuesByInstructionUpdatedBlockIdAndVenueIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByInstructionUpdatedBlockIdAndCreatedBlockId: BlockBlocksByInstructionUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksBySettlementCreatedBlockIdAndUpdatedBlockId: BlockBlocksBySettlementCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksBySettlementUpdatedBlockIdAndCreatedBlockId: BlockBlocksBySettlementUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByLegCreatedBlockIdAndFromId: BlockPortfoliosByLegCreatedBlockIdAndFromIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByLegCreatedBlockIdAndToId: BlockPortfoliosByLegCreatedBlockIdAndToIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Instruction`. */
  instructionsByLegCreatedBlockIdAndInstructionId: BlockInstructionsByLegCreatedBlockIdAndInstructionIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Settlement`. */
  settlementsByLegCreatedBlockIdAndSettlementId: BlockSettlementsByLegCreatedBlockIdAndSettlementIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByLegCreatedBlockIdAndUpdatedBlockId: BlockBlocksByLegCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByLegUpdatedBlockIdAndFromId: BlockPortfoliosByLegUpdatedBlockIdAndFromIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByLegUpdatedBlockIdAndToId: BlockPortfoliosByLegUpdatedBlockIdAndToIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Instruction`. */
  instructionsByLegUpdatedBlockIdAndInstructionId: BlockInstructionsByLegUpdatedBlockIdAndInstructionIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Settlement`. */
  settlementsByLegUpdatedBlockIdAndSettlementId: BlockSettlementsByLegUpdatedBlockIdAndSettlementIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByLegUpdatedBlockIdAndCreatedBlockId: BlockBlocksByLegUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByDistributionCreatedBlockIdAndIdentityId: BlockIdentitiesByDistributionCreatedBlockIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByDistributionCreatedBlockIdAndAssetId: BlockAssetsByDistributionCreatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByDistributionCreatedBlockIdAndPortfolioId: BlockPortfoliosByDistributionCreatedBlockIdAndPortfolioIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByDistributionCreatedBlockIdAndUpdatedBlockId: BlockBlocksByDistributionCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByDistributionUpdatedBlockIdAndIdentityId: BlockIdentitiesByDistributionUpdatedBlockIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByDistributionUpdatedBlockIdAndAssetId: BlockAssetsByDistributionUpdatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByDistributionUpdatedBlockIdAndPortfolioId: BlockPortfoliosByDistributionUpdatedBlockIdAndPortfolioIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByDistributionUpdatedBlockIdAndCreatedBlockId: BlockBlocksByDistributionUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributionsByDistributionPaymentCreatedBlockIdAndDistributionId: BlockDistributionsByDistributionPaymentCreatedBlockIdAndDistributionIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByDistributionPaymentCreatedBlockIdAndTargetId: BlockIdentitiesByDistributionPaymentCreatedBlockIdAndTargetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByDistributionPaymentCreatedBlockIdAndUpdatedBlockId: BlockBlocksByDistributionPaymentCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributionsByDistributionPaymentUpdatedBlockIdAndDistributionId: BlockDistributionsByDistributionPaymentUpdatedBlockIdAndDistributionIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByDistributionPaymentUpdatedBlockIdAndTargetId: BlockIdentitiesByDistributionPaymentUpdatedBlockIdAndTargetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByDistributionPaymentUpdatedBlockIdAndCreatedBlockId: BlockBlocksByDistributionPaymentUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByProposalCreatedBlockIdAndOwnerId: BlockIdentitiesByProposalCreatedBlockIdAndOwnerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByProposalCreatedBlockIdAndUpdatedBlockId: BlockBlocksByProposalCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByProposalUpdatedBlockIdAndOwnerId: BlockIdentitiesByProposalUpdatedBlockIdAndOwnerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByProposalUpdatedBlockIdAndCreatedBlockId: BlockBlocksByProposalUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Proposal`. */
  proposalsByProposalVoteCreatedBlockIdAndProposalId: BlockProposalsByProposalVoteCreatedBlockIdAndProposalIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByProposalVoteCreatedBlockIdAndUpdatedBlockId: BlockBlocksByProposalVoteCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Proposal`. */
  proposalsByProposalVoteUpdatedBlockIdAndProposalId: BlockProposalsByProposalVoteUpdatedBlockIdAndProposalIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByProposalVoteUpdatedBlockIdAndCreatedBlockId: BlockBlocksByProposalVoteUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByClaimScopeCreatedBlockIdAndUpdatedBlockId: BlockBlocksByClaimScopeCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByClaimScopeUpdatedBlockIdAndCreatedBlockId: BlockBlocksByClaimScopeUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByClaimCreatedBlockIdAndTargetId: BlockIdentitiesByClaimCreatedBlockIdAndTargetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByClaimCreatedBlockIdAndIssuerId: BlockIdentitiesByClaimCreatedBlockIdAndIssuerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByClaimCreatedBlockIdAndUpdatedBlockId: BlockBlocksByClaimCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByClaimUpdatedBlockIdAndTargetId: BlockIdentitiesByClaimUpdatedBlockIdAndTargetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByClaimUpdatedBlockIdAndIssuerId: BlockIdentitiesByClaimUpdatedBlockIdAndIssuerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByClaimUpdatedBlockIdAndCreatedBlockId: BlockBlocksByClaimUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTrustedClaimIssuerCreatedBlockIdAndAssetId: BlockAssetsByTrustedClaimIssuerCreatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTrustedClaimIssuerCreatedBlockIdAndUpdatedBlockId: BlockBlocksByTrustedClaimIssuerCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTrustedClaimIssuerUpdatedBlockIdAndAssetId: BlockAssetsByTrustedClaimIssuerUpdatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTrustedClaimIssuerUpdatedBlockIdAndCreatedBlockId: BlockBlocksByTrustedClaimIssuerUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetPendingOwnershipTransferCreatedBlockIdAndUpdatedBlockId: BlockBlocksByAssetPendingOwnershipTransferCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetPendingOwnershipTransferUpdatedBlockIdAndCreatedBlockId: BlockBlocksByAssetPendingOwnershipTransferUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTransferManagerCreatedBlockIdAndAssetId: BlockAssetsByTransferManagerCreatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTransferManagerCreatedBlockIdAndUpdatedBlockId: BlockBlocksByTransferManagerCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTransferManagerUpdatedBlockIdAndAssetId: BlockAssetsByTransferManagerUpdatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTransferManagerUpdatedBlockIdAndCreatedBlockId: BlockBlocksByTransferManagerUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByStatTypeCreatedBlockIdAndAssetId: BlockAssetsByStatTypeCreatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByStatTypeCreatedBlockIdAndClaimIssuerId: BlockIdentitiesByStatTypeCreatedBlockIdAndClaimIssuerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByStatTypeCreatedBlockIdAndUpdatedBlockId: BlockBlocksByStatTypeCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByStatTypeUpdatedBlockIdAndAssetId: BlockAssetsByStatTypeUpdatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByStatTypeUpdatedBlockIdAndClaimIssuerId: BlockIdentitiesByStatTypeUpdatedBlockIdAndClaimIssuerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByStatTypeUpdatedBlockIdAndCreatedBlockId: BlockBlocksByStatTypeUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTransferComplianceCreatedBlockIdAndAssetId: BlockAssetsByTransferComplianceCreatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypesByTransferComplianceCreatedBlockIdAndStatTypeId: BlockStatTypesByTransferComplianceCreatedBlockIdAndStatTypeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByTransferComplianceCreatedBlockIdAndClaimIssuerId: BlockIdentitiesByTransferComplianceCreatedBlockIdAndClaimIssuerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTransferComplianceCreatedBlockIdAndUpdatedBlockId: BlockBlocksByTransferComplianceCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTransferComplianceUpdatedBlockIdAndAssetId: BlockAssetsByTransferComplianceUpdatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypesByTransferComplianceUpdatedBlockIdAndStatTypeId: BlockStatTypesByTransferComplianceUpdatedBlockIdAndStatTypeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByTransferComplianceUpdatedBlockIdAndClaimIssuerId: BlockIdentitiesByTransferComplianceUpdatedBlockIdAndClaimIssuerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTransferComplianceUpdatedBlockIdAndCreatedBlockId: BlockBlocksByTransferComplianceUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTransferComplianceExemptionCreatedBlockIdAndAssetId: BlockAssetsByTransferComplianceExemptionCreatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTransferComplianceExemptionCreatedBlockIdAndUpdatedBlockId: BlockBlocksByTransferComplianceExemptionCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTransferComplianceExemptionUpdatedBlockIdAndAssetId: BlockAssetsByTransferComplianceExemptionUpdatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTransferComplianceExemptionUpdatedBlockIdAndCreatedBlockId: BlockBlocksByTransferComplianceExemptionUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByComplianceCreatedBlockIdAndAssetId: BlockAssetsByComplianceCreatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByComplianceCreatedBlockIdAndUpdatedBlockId: BlockBlocksByComplianceCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByComplianceUpdatedBlockIdAndAssetId: BlockAssetsByComplianceUpdatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByComplianceUpdatedBlockIdAndCreatedBlockId: BlockBlocksByComplianceUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByAssetHolderCreatedBlockIdAndIdentityId: BlockIdentitiesByAssetHolderCreatedBlockIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByAssetHolderCreatedBlockIdAndAssetId: BlockAssetsByAssetHolderCreatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetHolderCreatedBlockIdAndUpdatedBlockId: BlockBlocksByAssetHolderCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByAssetHolderUpdatedBlockIdAndIdentityId: BlockIdentitiesByAssetHolderUpdatedBlockIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByAssetHolderUpdatedBlockIdAndAssetId: BlockAssetsByAssetHolderUpdatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetHolderUpdatedBlockIdAndCreatedBlockId: BlockBlocksByAssetHolderUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByAssetDocumentCreatedBlockIdAndAssetId: BlockAssetsByAssetDocumentCreatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetDocumentCreatedBlockIdAndUpdatedBlockId: BlockBlocksByAssetDocumentCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByAssetDocumentUpdatedBlockIdAndAssetId: BlockAssetsByAssetDocumentUpdatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetDocumentUpdatedBlockIdAndCreatedBlockId: BlockBlocksByAssetDocumentUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByFundingCreatedBlockIdAndAssetId: BlockAssetsByFundingCreatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByFundingCreatedBlockIdAndUpdatedBlockId: BlockBlocksByFundingCreatedBlockIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByFundingUpdatedBlockIdAndAssetId: BlockAssetsByFundingUpdatedBlockIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByFundingUpdatedBlockIdAndCreatedBlockId: BlockBlocksByFundingUpdatedBlockIdAndCreatedBlockIdManyToManyConnection;
};

export type BlockEventsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<EventsOrderBy>>;
  filter?: Maybe<EventFilter>;
};

export type BlockExtrinsicsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ExtrinsicsOrderBy>>;
  filter?: Maybe<ExtrinsicFilter>;
};

export type BlockPermissionsByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PermissionsOrderBy>>;
  filter?: Maybe<PermissionFilter>;
};

export type BlockPermissionsByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PermissionsOrderBy>>;
  filter?: Maybe<PermissionFilter>;
};

export type BlockIdentitiesByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockIdentitiesByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockAccountsByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AccountsOrderBy>>;
  filter?: Maybe<AccountFilter>;
};

export type BlockAccountsByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AccountsOrderBy>>;
  filter?: Maybe<AccountFilter>;
};

export type BlockBridgeEventsByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BridgeEventsOrderBy>>;
  filter?: Maybe<BridgeEventFilter>;
};

export type BlockBridgeEventsByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BridgeEventsOrderBy>>;
  filter?: Maybe<BridgeEventFilter>;
};

export type BlockStakingEventsByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StakingEventsOrderBy>>;
  filter?: Maybe<StakingEventFilter>;
};

export type BlockStakingEventsByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StakingEventsOrderBy>>;
  filter?: Maybe<StakingEventFilter>;
};

export type BlockAssetsByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type BlockAssetsByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type BlockTickerExternalAgentActionsByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TickerExternalAgentActionsOrderBy>>;
  filter?: Maybe<TickerExternalAgentActionFilter>;
};

export type BlockTickerExternalAgentActionsByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TickerExternalAgentActionsOrderBy>>;
  filter?: Maybe<TickerExternalAgentActionFilter>;
};

export type BlockStosByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StosOrderBy>>;
  filter?: Maybe<StoFilter>;
};

export type BlockStosByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StosOrderBy>>;
  filter?: Maybe<StoFilter>;
};

export type BlockAuthorizationsByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AuthorizationsOrderBy>>;
  filter?: Maybe<AuthorizationFilter>;
};

export type BlockAuthorizationsByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AuthorizationsOrderBy>>;
  filter?: Maybe<AuthorizationFilter>;
};

export type BlockInvestmentsByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<InvestmentsOrderBy>>;
  filter?: Maybe<InvestmentFilter>;
};

export type BlockInvestmentsByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<InvestmentsOrderBy>>;
  filter?: Maybe<InvestmentFilter>;
};

export type BlockTickerExternalAgentsByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TickerExternalAgentsOrderBy>>;
  filter?: Maybe<TickerExternalAgentFilter>;
};

export type BlockTickerExternalAgentsByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TickerExternalAgentsOrderBy>>;
  filter?: Maybe<TickerExternalAgentFilter>;
};

export type BlockTickerExternalAgentHistoriesByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TickerExternalAgentHistoriesOrderBy>>;
  filter?: Maybe<TickerExternalAgentHistoryFilter>;
};

export type BlockTickerExternalAgentHistoriesByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TickerExternalAgentHistoriesOrderBy>>;
  filter?: Maybe<TickerExternalAgentHistoryFilter>;
};

export type BlockAgentGroupsByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AgentGroupsOrderBy>>;
  filter?: Maybe<AgentGroupFilter>;
};

export type BlockAgentGroupsByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AgentGroupsOrderBy>>;
  filter?: Maybe<AgentGroupFilter>;
};

export type BlockAgentGroupMembershipsByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AgentGroupMembershipsOrderBy>>;
  filter?: Maybe<AgentGroupMembershipFilter>;
};

export type BlockAgentGroupMembershipsByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AgentGroupMembershipsOrderBy>>;
  filter?: Maybe<AgentGroupMembershipFilter>;
};

export type BlockPortfoliosByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PortfoliosOrderBy>>;
  filter?: Maybe<PortfolioFilter>;
};

export type BlockPortfoliosByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PortfoliosOrderBy>>;
  filter?: Maybe<PortfolioFilter>;
};

export type BlockPortfolioMovementsByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PortfolioMovementsOrderBy>>;
  filter?: Maybe<PortfolioMovementFilter>;
};

export type BlockPortfolioMovementsByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PortfolioMovementsOrderBy>>;
  filter?: Maybe<PortfolioMovementFilter>;
};

export type BlockVenuesByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VenuesOrderBy>>;
  filter?: Maybe<VenueFilter>;
};

export type BlockVenuesByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VenuesOrderBy>>;
  filter?: Maybe<VenueFilter>;
};

export type BlockInstructionsByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<InstructionsOrderBy>>;
  filter?: Maybe<InstructionFilter>;
};

export type BlockInstructionsByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<InstructionsOrderBy>>;
  filter?: Maybe<InstructionFilter>;
};

export type BlockSettlementsByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<SettlementsOrderBy>>;
  filter?: Maybe<SettlementFilter>;
};

export type BlockSettlementsByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<SettlementsOrderBy>>;
  filter?: Maybe<SettlementFilter>;
};

export type BlockLegsByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<LegsOrderBy>>;
  filter?: Maybe<LegFilter>;
};

export type BlockLegsByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<LegsOrderBy>>;
  filter?: Maybe<LegFilter>;
};

export type BlockDistributionsByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<DistributionsOrderBy>>;
  filter?: Maybe<DistributionFilter>;
};

export type BlockDistributionsByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<DistributionsOrderBy>>;
  filter?: Maybe<DistributionFilter>;
};

export type BlockDistributionPaymentsByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<DistributionPaymentsOrderBy>>;
  filter?: Maybe<DistributionPaymentFilter>;
};

export type BlockDistributionPaymentsByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<DistributionPaymentsOrderBy>>;
  filter?: Maybe<DistributionPaymentFilter>;
};

export type BlockProposalsByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ProposalsOrderBy>>;
  filter?: Maybe<ProposalFilter>;
};

export type BlockProposalsByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ProposalsOrderBy>>;
  filter?: Maybe<ProposalFilter>;
};

export type BlockProposalVotesByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ProposalVotesOrderBy>>;
  filter?: Maybe<ProposalVoteFilter>;
};

export type BlockProposalVotesByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ProposalVotesOrderBy>>;
  filter?: Maybe<ProposalVoteFilter>;
};

export type BlockClaimScopesByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ClaimScopesOrderBy>>;
  filter?: Maybe<ClaimScopeFilter>;
};

export type BlockClaimScopesByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ClaimScopesOrderBy>>;
  filter?: Maybe<ClaimScopeFilter>;
};

export type BlockClaimsByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ClaimsOrderBy>>;
  filter?: Maybe<ClaimFilter>;
};

export type BlockClaimsByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ClaimsOrderBy>>;
  filter?: Maybe<ClaimFilter>;
};

export type BlockTrustedClaimIssuersByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TrustedClaimIssuersOrderBy>>;
  filter?: Maybe<TrustedClaimIssuerFilter>;
};

export type BlockTrustedClaimIssuersByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TrustedClaimIssuersOrderBy>>;
  filter?: Maybe<TrustedClaimIssuerFilter>;
};

export type BlockAssetPendingOwnershipTransfersByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetPendingOwnershipTransfersOrderBy>>;
  filter?: Maybe<AssetPendingOwnershipTransferFilter>;
};

export type BlockAssetPendingOwnershipTransfersByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetPendingOwnershipTransfersOrderBy>>;
  filter?: Maybe<AssetPendingOwnershipTransferFilter>;
};

export type BlockTransferManagersByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TransferManagersOrderBy>>;
  filter?: Maybe<TransferManagerFilter>;
};

export type BlockTransferManagersByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TransferManagersOrderBy>>;
  filter?: Maybe<TransferManagerFilter>;
};

export type BlockStatTypesByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StatTypesOrderBy>>;
  filter?: Maybe<StatTypeFilter>;
};

export type BlockStatTypesByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StatTypesOrderBy>>;
  filter?: Maybe<StatTypeFilter>;
};

export type BlockTransferCompliancesByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TransferCompliancesOrderBy>>;
  filter?: Maybe<TransferComplianceFilter>;
};

export type BlockTransferCompliancesByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TransferCompliancesOrderBy>>;
  filter?: Maybe<TransferComplianceFilter>;
};

export type BlockTransferComplianceExemptionsByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TransferComplianceExemptionsOrderBy>>;
  filter?: Maybe<TransferComplianceExemptionFilter>;
};

export type BlockTransferComplianceExemptionsByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TransferComplianceExemptionsOrderBy>>;
  filter?: Maybe<TransferComplianceExemptionFilter>;
};

export type BlockCompliancesByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CompliancesOrderBy>>;
  filter?: Maybe<ComplianceFilter>;
};

export type BlockCompliancesByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CompliancesOrderBy>>;
  filter?: Maybe<ComplianceFilter>;
};

export type BlockAssetHoldersByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetHoldersOrderBy>>;
  filter?: Maybe<AssetHolderFilter>;
};

export type BlockAssetHoldersByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetHoldersOrderBy>>;
  filter?: Maybe<AssetHolderFilter>;
};

export type BlockAssetDocumentsByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetDocumentsOrderBy>>;
  filter?: Maybe<AssetDocumentFilter>;
};

export type BlockAssetDocumentsByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetDocumentsOrderBy>>;
  filter?: Maybe<AssetDocumentFilter>;
};

export type BlockFundingsByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<FundingsOrderBy>>;
  filter?: Maybe<FundingFilter>;
};

export type BlockFundingsByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<FundingsOrderBy>>;
  filter?: Maybe<FundingFilter>;
};

export type BlockBlocksByPermissionCreatedBlockIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockBlocksByPermissionUpdatedBlockIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockBlocksByIdentityCreatedBlockIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockBlocksByIdentityUpdatedBlockIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockIdentitiesByAccountCreatedBlockIdAndIdentityIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockPermissionsByAccountCreatedBlockIdAndPermissionsIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PermissionsOrderBy>>;
  filter?: Maybe<PermissionFilter>;
};

export type BlockBlocksByAccountCreatedBlockIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockIdentitiesByAccountUpdatedBlockIdAndIdentityIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockPermissionsByAccountUpdatedBlockIdAndPermissionsIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PermissionsOrderBy>>;
  filter?: Maybe<PermissionFilter>;
};

export type BlockBlocksByAccountUpdatedBlockIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockIdentitiesByBridgeEventCreatedBlockIdAndIdentityIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockBlocksByBridgeEventCreatedBlockIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockIdentitiesByBridgeEventUpdatedBlockIdAndIdentityIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockBlocksByBridgeEventUpdatedBlockIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockIdentitiesByStakingEventCreatedBlockIdAndIdentityIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockBlocksByStakingEventCreatedBlockIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockIdentitiesByStakingEventUpdatedBlockIdAndIdentityIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockBlocksByStakingEventUpdatedBlockIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockIdentitiesByAssetCreatedBlockIdAndOwnerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockBlocksByAssetCreatedBlockIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockIdentitiesByAssetUpdatedBlockIdAndOwnerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockBlocksByAssetUpdatedBlockIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockAssetsByTickerExternalAgentActionCreatedBlockIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type BlockIdentitiesByTickerExternalAgentActionCreatedBlockIdAndCallerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockBlocksByTickerExternalAgentActionCreatedBlockIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockAssetsByTickerExternalAgentActionUpdatedBlockIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type BlockIdentitiesByTickerExternalAgentActionUpdatedBlockIdAndCallerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockBlocksByTickerExternalAgentActionUpdatedBlockIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockAssetsByStoCreatedBlockIdAndOfferingAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type BlockBlocksByStoCreatedBlockIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockAssetsByStoUpdatedBlockIdAndOfferingAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type BlockBlocksByStoUpdatedBlockIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockIdentitiesByAuthorizationCreatedBlockIdAndFromIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockIdentitiesByAuthorizationCreatedBlockIdAndToIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockBlocksByAuthorizationCreatedBlockIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockIdentitiesByAuthorizationUpdatedBlockIdAndFromIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockIdentitiesByAuthorizationUpdatedBlockIdAndToIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockBlocksByAuthorizationUpdatedBlockIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockIdentitiesByInvestmentCreatedBlockIdAndInvestorIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockBlocksByInvestmentCreatedBlockIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockIdentitiesByInvestmentUpdatedBlockIdAndInvestorIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockBlocksByInvestmentUpdatedBlockIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockAssetsByTickerExternalAgentCreatedBlockIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type BlockIdentitiesByTickerExternalAgentCreatedBlockIdAndCallerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockBlocksByTickerExternalAgentCreatedBlockIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockAssetsByTickerExternalAgentUpdatedBlockIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type BlockIdentitiesByTickerExternalAgentUpdatedBlockIdAndCallerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockBlocksByTickerExternalAgentUpdatedBlockIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockAssetsByTickerExternalAgentHistoryCreatedBlockIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type BlockIdentitiesByTickerExternalAgentHistoryCreatedBlockIdAndIdentityIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockBlocksByTickerExternalAgentHistoryCreatedBlockIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockAssetsByTickerExternalAgentHistoryUpdatedBlockIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type BlockIdentitiesByTickerExternalAgentHistoryUpdatedBlockIdAndIdentityIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockBlocksByTickerExternalAgentHistoryUpdatedBlockIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockBlocksByAgentGroupCreatedBlockIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockBlocksByAgentGroupUpdatedBlockIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockAgentGroupsByAgentGroupMembershipCreatedBlockIdAndGroupIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AgentGroupsOrderBy>>;
  filter?: Maybe<AgentGroupFilter>;
};

export type BlockBlocksByAgentGroupMembershipCreatedBlockIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockAgentGroupsByAgentGroupMembershipUpdatedBlockIdAndGroupIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AgentGroupsOrderBy>>;
  filter?: Maybe<AgentGroupFilter>;
};

export type BlockBlocksByAgentGroupMembershipUpdatedBlockIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockIdentitiesByPortfolioCreatedBlockIdAndIdentityIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockIdentitiesByPortfolioCreatedBlockIdAndCustodianIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockBlocksByPortfolioCreatedBlockIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockIdentitiesByPortfolioUpdatedBlockIdAndIdentityIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockIdentitiesByPortfolioUpdatedBlockIdAndCustodianIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockBlocksByPortfolioUpdatedBlockIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockPortfoliosByPortfolioMovementCreatedBlockIdAndFromIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PortfoliosOrderBy>>;
  filter?: Maybe<PortfolioFilter>;
};

export type BlockPortfoliosByPortfolioMovementCreatedBlockIdAndToIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PortfoliosOrderBy>>;
  filter?: Maybe<PortfolioFilter>;
};

export type BlockAssetsByPortfolioMovementCreatedBlockIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type BlockBlocksByPortfolioMovementCreatedBlockIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockPortfoliosByPortfolioMovementUpdatedBlockIdAndFromIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PortfoliosOrderBy>>;
  filter?: Maybe<PortfolioFilter>;
};

export type BlockPortfoliosByPortfolioMovementUpdatedBlockIdAndToIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PortfoliosOrderBy>>;
  filter?: Maybe<PortfolioFilter>;
};

export type BlockAssetsByPortfolioMovementUpdatedBlockIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type BlockBlocksByPortfolioMovementUpdatedBlockIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockIdentitiesByVenueCreatedBlockIdAndOwnerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockBlocksByVenueCreatedBlockIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockIdentitiesByVenueUpdatedBlockIdAndOwnerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockBlocksByVenueUpdatedBlockIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockVenuesByInstructionCreatedBlockIdAndVenueIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VenuesOrderBy>>;
  filter?: Maybe<VenueFilter>;
};

export type BlockBlocksByInstructionCreatedBlockIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockVenuesByInstructionUpdatedBlockIdAndVenueIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VenuesOrderBy>>;
  filter?: Maybe<VenueFilter>;
};

export type BlockBlocksByInstructionUpdatedBlockIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockBlocksBySettlementCreatedBlockIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockBlocksBySettlementUpdatedBlockIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockPortfoliosByLegCreatedBlockIdAndFromIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PortfoliosOrderBy>>;
  filter?: Maybe<PortfolioFilter>;
};

export type BlockPortfoliosByLegCreatedBlockIdAndToIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PortfoliosOrderBy>>;
  filter?: Maybe<PortfolioFilter>;
};

export type BlockInstructionsByLegCreatedBlockIdAndInstructionIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<InstructionsOrderBy>>;
  filter?: Maybe<InstructionFilter>;
};

export type BlockSettlementsByLegCreatedBlockIdAndSettlementIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<SettlementsOrderBy>>;
  filter?: Maybe<SettlementFilter>;
};

export type BlockBlocksByLegCreatedBlockIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockPortfoliosByLegUpdatedBlockIdAndFromIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PortfoliosOrderBy>>;
  filter?: Maybe<PortfolioFilter>;
};

export type BlockPortfoliosByLegUpdatedBlockIdAndToIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PortfoliosOrderBy>>;
  filter?: Maybe<PortfolioFilter>;
};

export type BlockInstructionsByLegUpdatedBlockIdAndInstructionIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<InstructionsOrderBy>>;
  filter?: Maybe<InstructionFilter>;
};

export type BlockSettlementsByLegUpdatedBlockIdAndSettlementIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<SettlementsOrderBy>>;
  filter?: Maybe<SettlementFilter>;
};

export type BlockBlocksByLegUpdatedBlockIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockIdentitiesByDistributionCreatedBlockIdAndIdentityIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockAssetsByDistributionCreatedBlockIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type BlockPortfoliosByDistributionCreatedBlockIdAndPortfolioIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PortfoliosOrderBy>>;
  filter?: Maybe<PortfolioFilter>;
};

export type BlockBlocksByDistributionCreatedBlockIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockIdentitiesByDistributionUpdatedBlockIdAndIdentityIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockAssetsByDistributionUpdatedBlockIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type BlockPortfoliosByDistributionUpdatedBlockIdAndPortfolioIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PortfoliosOrderBy>>;
  filter?: Maybe<PortfolioFilter>;
};

export type BlockBlocksByDistributionUpdatedBlockIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockDistributionsByDistributionPaymentCreatedBlockIdAndDistributionIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<DistributionsOrderBy>>;
  filter?: Maybe<DistributionFilter>;
};

export type BlockIdentitiesByDistributionPaymentCreatedBlockIdAndTargetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockBlocksByDistributionPaymentCreatedBlockIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockDistributionsByDistributionPaymentUpdatedBlockIdAndDistributionIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<DistributionsOrderBy>>;
  filter?: Maybe<DistributionFilter>;
};

export type BlockIdentitiesByDistributionPaymentUpdatedBlockIdAndTargetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockBlocksByDistributionPaymentUpdatedBlockIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockIdentitiesByProposalCreatedBlockIdAndOwnerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockBlocksByProposalCreatedBlockIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockIdentitiesByProposalUpdatedBlockIdAndOwnerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockBlocksByProposalUpdatedBlockIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockProposalsByProposalVoteCreatedBlockIdAndProposalIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ProposalsOrderBy>>;
  filter?: Maybe<ProposalFilter>;
};

export type BlockBlocksByProposalVoteCreatedBlockIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockProposalsByProposalVoteUpdatedBlockIdAndProposalIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ProposalsOrderBy>>;
  filter?: Maybe<ProposalFilter>;
};

export type BlockBlocksByProposalVoteUpdatedBlockIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockBlocksByClaimScopeCreatedBlockIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockBlocksByClaimScopeUpdatedBlockIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockIdentitiesByClaimCreatedBlockIdAndTargetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockIdentitiesByClaimCreatedBlockIdAndIssuerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockBlocksByClaimCreatedBlockIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockIdentitiesByClaimUpdatedBlockIdAndTargetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockIdentitiesByClaimUpdatedBlockIdAndIssuerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockBlocksByClaimUpdatedBlockIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockAssetsByTrustedClaimIssuerCreatedBlockIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type BlockBlocksByTrustedClaimIssuerCreatedBlockIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockAssetsByTrustedClaimIssuerUpdatedBlockIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type BlockBlocksByTrustedClaimIssuerUpdatedBlockIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockBlocksByAssetPendingOwnershipTransferCreatedBlockIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockBlocksByAssetPendingOwnershipTransferUpdatedBlockIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockAssetsByTransferManagerCreatedBlockIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type BlockBlocksByTransferManagerCreatedBlockIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockAssetsByTransferManagerUpdatedBlockIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type BlockBlocksByTransferManagerUpdatedBlockIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockAssetsByStatTypeCreatedBlockIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type BlockIdentitiesByStatTypeCreatedBlockIdAndClaimIssuerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockBlocksByStatTypeCreatedBlockIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockAssetsByStatTypeUpdatedBlockIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type BlockIdentitiesByStatTypeUpdatedBlockIdAndClaimIssuerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockBlocksByStatTypeUpdatedBlockIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockAssetsByTransferComplianceCreatedBlockIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type BlockStatTypesByTransferComplianceCreatedBlockIdAndStatTypeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StatTypesOrderBy>>;
  filter?: Maybe<StatTypeFilter>;
};

export type BlockIdentitiesByTransferComplianceCreatedBlockIdAndClaimIssuerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockBlocksByTransferComplianceCreatedBlockIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockAssetsByTransferComplianceUpdatedBlockIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type BlockStatTypesByTransferComplianceUpdatedBlockIdAndStatTypeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StatTypesOrderBy>>;
  filter?: Maybe<StatTypeFilter>;
};

export type BlockIdentitiesByTransferComplianceUpdatedBlockIdAndClaimIssuerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockBlocksByTransferComplianceUpdatedBlockIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockAssetsByTransferComplianceExemptionCreatedBlockIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type BlockBlocksByTransferComplianceExemptionCreatedBlockIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockAssetsByTransferComplianceExemptionUpdatedBlockIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type BlockBlocksByTransferComplianceExemptionUpdatedBlockIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockAssetsByComplianceCreatedBlockIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type BlockBlocksByComplianceCreatedBlockIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockAssetsByComplianceUpdatedBlockIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type BlockBlocksByComplianceUpdatedBlockIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockIdentitiesByAssetHolderCreatedBlockIdAndIdentityIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockAssetsByAssetHolderCreatedBlockIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type BlockBlocksByAssetHolderCreatedBlockIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockIdentitiesByAssetHolderUpdatedBlockIdAndIdentityIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type BlockAssetsByAssetHolderUpdatedBlockIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type BlockBlocksByAssetHolderUpdatedBlockIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockAssetsByAssetDocumentCreatedBlockIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type BlockBlocksByAssetDocumentCreatedBlockIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockAssetsByAssetDocumentUpdatedBlockIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type BlockBlocksByAssetDocumentUpdatedBlockIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockAssetsByFundingCreatedBlockIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type BlockBlocksByFundingCreatedBlockIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type BlockAssetsByFundingUpdatedBlockIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type BlockBlocksByFundingUpdatedBlockIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

/** A connection to a list of `AgentGroup` values, with data from `AgentGroupMembership`. */
export type BlockAgentGroupsByAgentGroupMembershipCreatedBlockIdAndGroupIdManyToManyConnection = {
  __typename?: 'BlockAgentGroupsByAgentGroupMembershipCreatedBlockIdAndGroupIdManyToManyConnection';
  /** A list of `AgentGroup` objects. */
  nodes: Array<Maybe<AgentGroup>>;
  /** A list of edges which contains the `AgentGroup`, info from the `AgentGroupMembership`, and the cursor to aid in pagination. */
  edges: Array<BlockAgentGroupsByAgentGroupMembershipCreatedBlockIdAndGroupIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AgentGroup` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AgentGroupAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AgentGroupAggregates>>;
};

/** A connection to a list of `AgentGroup` values, with data from `AgentGroupMembership`. */
export type BlockAgentGroupsByAgentGroupMembershipCreatedBlockIdAndGroupIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AgentGroupsGroupBy>;
    having?: Maybe<AgentGroupsHavingInput>;
  };

/** A `AgentGroup` edge in the connection, with data from `AgentGroupMembership`. */
export type BlockAgentGroupsByAgentGroupMembershipCreatedBlockIdAndGroupIdManyToManyEdge = {
  __typename?: 'BlockAgentGroupsByAgentGroupMembershipCreatedBlockIdAndGroupIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `AgentGroup` at the end of the edge. */
  node?: Maybe<AgentGroup>;
  /** Reads and enables pagination through a set of `AgentGroupMembership`. */
  members: AgentGroupMembershipsConnection;
};

/** A `AgentGroup` edge in the connection, with data from `AgentGroupMembership`. */
export type BlockAgentGroupsByAgentGroupMembershipCreatedBlockIdAndGroupIdManyToManyEdgeMembersArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AgentGroupMembershipsOrderBy>>;
    filter?: Maybe<AgentGroupMembershipFilter>;
  };

/** A connection to a list of `AgentGroup` values, with data from `AgentGroupMembership`. */
export type BlockAgentGroupsByAgentGroupMembershipUpdatedBlockIdAndGroupIdManyToManyConnection = {
  __typename?: 'BlockAgentGroupsByAgentGroupMembershipUpdatedBlockIdAndGroupIdManyToManyConnection';
  /** A list of `AgentGroup` objects. */
  nodes: Array<Maybe<AgentGroup>>;
  /** A list of edges which contains the `AgentGroup`, info from the `AgentGroupMembership`, and the cursor to aid in pagination. */
  edges: Array<BlockAgentGroupsByAgentGroupMembershipUpdatedBlockIdAndGroupIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AgentGroup` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AgentGroupAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AgentGroupAggregates>>;
};

/** A connection to a list of `AgentGroup` values, with data from `AgentGroupMembership`. */
export type BlockAgentGroupsByAgentGroupMembershipUpdatedBlockIdAndGroupIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AgentGroupsGroupBy>;
    having?: Maybe<AgentGroupsHavingInput>;
  };

/** A `AgentGroup` edge in the connection, with data from `AgentGroupMembership`. */
export type BlockAgentGroupsByAgentGroupMembershipUpdatedBlockIdAndGroupIdManyToManyEdge = {
  __typename?: 'BlockAgentGroupsByAgentGroupMembershipUpdatedBlockIdAndGroupIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `AgentGroup` at the end of the edge. */
  node?: Maybe<AgentGroup>;
  /** Reads and enables pagination through a set of `AgentGroupMembership`. */
  members: AgentGroupMembershipsConnection;
};

/** A `AgentGroup` edge in the connection, with data from `AgentGroupMembership`. */
export type BlockAgentGroupsByAgentGroupMembershipUpdatedBlockIdAndGroupIdManyToManyEdgeMembersArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AgentGroupMembershipsOrderBy>>;
    filter?: Maybe<AgentGroupMembershipFilter>;
  };

export type BlockAggregates = {
  __typename?: 'BlockAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A connection to a list of `Asset` values, with data from `AssetDocument`. */
export type BlockAssetsByAssetDocumentCreatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByAssetDocumentCreatedBlockIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `AssetDocument`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByAssetDocumentCreatedBlockIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `AssetDocument`. */
export type BlockAssetsByAssetDocumentCreatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `AssetDocument`. */
export type BlockAssetsByAssetDocumentCreatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByAssetDocumentCreatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `AssetDocument`. */
  documents: AssetDocumentsConnection;
};

/** A `Asset` edge in the connection, with data from `AssetDocument`. */
export type BlockAssetsByAssetDocumentCreatedBlockIdAndAssetIdManyToManyEdgeDocumentsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetDocumentsOrderBy>>;
  filter?: Maybe<AssetDocumentFilter>;
};

/** A connection to a list of `Asset` values, with data from `AssetDocument`. */
export type BlockAssetsByAssetDocumentUpdatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByAssetDocumentUpdatedBlockIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `AssetDocument`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByAssetDocumentUpdatedBlockIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `AssetDocument`. */
export type BlockAssetsByAssetDocumentUpdatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `AssetDocument`. */
export type BlockAssetsByAssetDocumentUpdatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByAssetDocumentUpdatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `AssetDocument`. */
  documents: AssetDocumentsConnection;
};

/** A `Asset` edge in the connection, with data from `AssetDocument`. */
export type BlockAssetsByAssetDocumentUpdatedBlockIdAndAssetIdManyToManyEdgeDocumentsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetDocumentsOrderBy>>;
  filter?: Maybe<AssetDocumentFilter>;
};

/** A connection to a list of `Asset` values, with data from `AssetHolder`. */
export type BlockAssetsByAssetHolderCreatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByAssetHolderCreatedBlockIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `AssetHolder`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByAssetHolderCreatedBlockIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `AssetHolder`. */
export type BlockAssetsByAssetHolderCreatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `AssetHolder`. */
export type BlockAssetsByAssetHolderCreatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByAssetHolderCreatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `AssetHolder`. */
  holders: AssetHoldersConnection;
};

/** A `Asset` edge in the connection, with data from `AssetHolder`. */
export type BlockAssetsByAssetHolderCreatedBlockIdAndAssetIdManyToManyEdgeHoldersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetHoldersOrderBy>>;
  filter?: Maybe<AssetHolderFilter>;
};

/** A connection to a list of `Asset` values, with data from `AssetHolder`. */
export type BlockAssetsByAssetHolderUpdatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByAssetHolderUpdatedBlockIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `AssetHolder`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByAssetHolderUpdatedBlockIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `AssetHolder`. */
export type BlockAssetsByAssetHolderUpdatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `AssetHolder`. */
export type BlockAssetsByAssetHolderUpdatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByAssetHolderUpdatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `AssetHolder`. */
  holders: AssetHoldersConnection;
};

/** A `Asset` edge in the connection, with data from `AssetHolder`. */
export type BlockAssetsByAssetHolderUpdatedBlockIdAndAssetIdManyToManyEdgeHoldersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetHoldersOrderBy>>;
  filter?: Maybe<AssetHolderFilter>;
};

/** A connection to a list of `Asset` values, with data from `Compliance`. */
export type BlockAssetsByComplianceCreatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByComplianceCreatedBlockIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `Compliance`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByComplianceCreatedBlockIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `Compliance`. */
export type BlockAssetsByComplianceCreatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `Compliance`. */
export type BlockAssetsByComplianceCreatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByComplianceCreatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `Compliance`. */
  compliance: CompliancesConnection;
};

/** A `Asset` edge in the connection, with data from `Compliance`. */
export type BlockAssetsByComplianceCreatedBlockIdAndAssetIdManyToManyEdgeComplianceArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CompliancesOrderBy>>;
  filter?: Maybe<ComplianceFilter>;
};

/** A connection to a list of `Asset` values, with data from `Compliance`. */
export type BlockAssetsByComplianceUpdatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByComplianceUpdatedBlockIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `Compliance`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByComplianceUpdatedBlockIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `Compliance`. */
export type BlockAssetsByComplianceUpdatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `Compliance`. */
export type BlockAssetsByComplianceUpdatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByComplianceUpdatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `Compliance`. */
  compliance: CompliancesConnection;
};

/** A `Asset` edge in the connection, with data from `Compliance`. */
export type BlockAssetsByComplianceUpdatedBlockIdAndAssetIdManyToManyEdgeComplianceArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CompliancesOrderBy>>;
  filter?: Maybe<ComplianceFilter>;
};

/** A connection to a list of `Asset` values, with data from `Distribution`. */
export type BlockAssetsByDistributionCreatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByDistributionCreatedBlockIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByDistributionCreatedBlockIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `Distribution`. */
export type BlockAssetsByDistributionCreatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `Distribution`. */
export type BlockAssetsByDistributionCreatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByDistributionCreatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributions: DistributionsConnection;
};

/** A `Asset` edge in the connection, with data from `Distribution`. */
export type BlockAssetsByDistributionCreatedBlockIdAndAssetIdManyToManyEdgeDistributionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<DistributionsOrderBy>>;
  filter?: Maybe<DistributionFilter>;
};

/** A connection to a list of `Asset` values, with data from `Distribution`. */
export type BlockAssetsByDistributionUpdatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByDistributionUpdatedBlockIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByDistributionUpdatedBlockIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `Distribution`. */
export type BlockAssetsByDistributionUpdatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `Distribution`. */
export type BlockAssetsByDistributionUpdatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByDistributionUpdatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributions: DistributionsConnection;
};

/** A `Asset` edge in the connection, with data from `Distribution`. */
export type BlockAssetsByDistributionUpdatedBlockIdAndAssetIdManyToManyEdgeDistributionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<DistributionsOrderBy>>;
  filter?: Maybe<DistributionFilter>;
};

/** A connection to a list of `Asset` values, with data from `Funding`. */
export type BlockAssetsByFundingCreatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByFundingCreatedBlockIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `Funding`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByFundingCreatedBlockIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `Funding`. */
export type BlockAssetsByFundingCreatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `Funding`. */
export type BlockAssetsByFundingCreatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByFundingCreatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `Funding`. */
  fundings: FundingsConnection;
};

/** A `Asset` edge in the connection, with data from `Funding`. */
export type BlockAssetsByFundingCreatedBlockIdAndAssetIdManyToManyEdgeFundingsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<FundingsOrderBy>>;
  filter?: Maybe<FundingFilter>;
};

/** A connection to a list of `Asset` values, with data from `Funding`. */
export type BlockAssetsByFundingUpdatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByFundingUpdatedBlockIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `Funding`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByFundingUpdatedBlockIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `Funding`. */
export type BlockAssetsByFundingUpdatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `Funding`. */
export type BlockAssetsByFundingUpdatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByFundingUpdatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `Funding`. */
  fundings: FundingsConnection;
};

/** A `Asset` edge in the connection, with data from `Funding`. */
export type BlockAssetsByFundingUpdatedBlockIdAndAssetIdManyToManyEdgeFundingsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<FundingsOrderBy>>;
  filter?: Maybe<FundingFilter>;
};

/** A connection to a list of `Asset` values, with data from `PortfolioMovement`. */
export type BlockAssetsByPortfolioMovementCreatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByPortfolioMovementCreatedBlockIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByPortfolioMovementCreatedBlockIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `PortfolioMovement`. */
export type BlockAssetsByPortfolioMovementCreatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `PortfolioMovement`. */
export type BlockAssetsByPortfolioMovementCreatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByPortfolioMovementCreatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovements: PortfolioMovementsConnection;
};

/** A `Asset` edge in the connection, with data from `PortfolioMovement`. */
export type BlockAssetsByPortfolioMovementCreatedBlockIdAndAssetIdManyToManyEdgePortfolioMovementsArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<PortfolioMovementsOrderBy>>;
    filter?: Maybe<PortfolioMovementFilter>;
  };

/** A connection to a list of `Asset` values, with data from `PortfolioMovement`. */
export type BlockAssetsByPortfolioMovementUpdatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByPortfolioMovementUpdatedBlockIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByPortfolioMovementUpdatedBlockIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `PortfolioMovement`. */
export type BlockAssetsByPortfolioMovementUpdatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `PortfolioMovement`. */
export type BlockAssetsByPortfolioMovementUpdatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByPortfolioMovementUpdatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovements: PortfolioMovementsConnection;
};

/** A `Asset` edge in the connection, with data from `PortfolioMovement`. */
export type BlockAssetsByPortfolioMovementUpdatedBlockIdAndAssetIdManyToManyEdgePortfolioMovementsArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<PortfolioMovementsOrderBy>>;
    filter?: Maybe<PortfolioMovementFilter>;
  };

/** A connection to a list of `Asset` values, with data from `StatType`. */
export type BlockAssetsByStatTypeCreatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByStatTypeCreatedBlockIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `StatType`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByStatTypeCreatedBlockIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `StatType`. */
export type BlockAssetsByStatTypeCreatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `StatType`. */
export type BlockAssetsByStatTypeCreatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByStatTypeCreatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypes: StatTypesConnection;
};

/** A `Asset` edge in the connection, with data from `StatType`. */
export type BlockAssetsByStatTypeCreatedBlockIdAndAssetIdManyToManyEdgeStatTypesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StatTypesOrderBy>>;
  filter?: Maybe<StatTypeFilter>;
};

/** A connection to a list of `Asset` values, with data from `StatType`. */
export type BlockAssetsByStatTypeUpdatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByStatTypeUpdatedBlockIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `StatType`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByStatTypeUpdatedBlockIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `StatType`. */
export type BlockAssetsByStatTypeUpdatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `StatType`. */
export type BlockAssetsByStatTypeUpdatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByStatTypeUpdatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypes: StatTypesConnection;
};

/** A `Asset` edge in the connection, with data from `StatType`. */
export type BlockAssetsByStatTypeUpdatedBlockIdAndAssetIdManyToManyEdgeStatTypesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StatTypesOrderBy>>;
  filter?: Maybe<StatTypeFilter>;
};

/** A connection to a list of `Asset` values, with data from `Sto`. */
export type BlockAssetsByStoCreatedBlockIdAndOfferingAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByStoCreatedBlockIdAndOfferingAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByStoCreatedBlockIdAndOfferingAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `Sto`. */
export type BlockAssetsByStoCreatedBlockIdAndOfferingAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `Sto`. */
export type BlockAssetsByStoCreatedBlockIdAndOfferingAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByStoCreatedBlockIdAndOfferingAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByOfferingAssetId: StosConnection;
};

/** A `Asset` edge in the connection, with data from `Sto`. */
export type BlockAssetsByStoCreatedBlockIdAndOfferingAssetIdManyToManyEdgeStosByOfferingAssetIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<StosOrderBy>>;
    filter?: Maybe<StoFilter>;
  };

/** A connection to a list of `Asset` values, with data from `Sto`. */
export type BlockAssetsByStoUpdatedBlockIdAndOfferingAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByStoUpdatedBlockIdAndOfferingAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByStoUpdatedBlockIdAndOfferingAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `Sto`. */
export type BlockAssetsByStoUpdatedBlockIdAndOfferingAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `Sto`. */
export type BlockAssetsByStoUpdatedBlockIdAndOfferingAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByStoUpdatedBlockIdAndOfferingAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByOfferingAssetId: StosConnection;
};

/** A `Asset` edge in the connection, with data from `Sto`. */
export type BlockAssetsByStoUpdatedBlockIdAndOfferingAssetIdManyToManyEdgeStosByOfferingAssetIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<StosOrderBy>>;
    filter?: Maybe<StoFilter>;
  };

/** A connection to a list of `Asset` values, with data from `TickerExternalAgentAction`. */
export type BlockAssetsByTickerExternalAgentActionCreatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByTickerExternalAgentActionCreatedBlockIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `TickerExternalAgentAction`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByTickerExternalAgentActionCreatedBlockIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `TickerExternalAgentAction`. */
export type BlockAssetsByTickerExternalAgentActionCreatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TickerExternalAgentAction`. */
export type BlockAssetsByTickerExternalAgentActionCreatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByTickerExternalAgentActionCreatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TickerExternalAgentAction`. */
  tickerExternalAgentActions: TickerExternalAgentActionsConnection;
};

/** A `Asset` edge in the connection, with data from `TickerExternalAgentAction`. */
export type BlockAssetsByTickerExternalAgentActionCreatedBlockIdAndAssetIdManyToManyEdgeTickerExternalAgentActionsArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TickerExternalAgentActionsOrderBy>>;
    filter?: Maybe<TickerExternalAgentActionFilter>;
  };

/** A connection to a list of `Asset` values, with data from `TickerExternalAgentAction`. */
export type BlockAssetsByTickerExternalAgentActionUpdatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByTickerExternalAgentActionUpdatedBlockIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `TickerExternalAgentAction`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByTickerExternalAgentActionUpdatedBlockIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `TickerExternalAgentAction`. */
export type BlockAssetsByTickerExternalAgentActionUpdatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TickerExternalAgentAction`. */
export type BlockAssetsByTickerExternalAgentActionUpdatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByTickerExternalAgentActionUpdatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TickerExternalAgentAction`. */
  tickerExternalAgentActions: TickerExternalAgentActionsConnection;
};

/** A `Asset` edge in the connection, with data from `TickerExternalAgentAction`. */
export type BlockAssetsByTickerExternalAgentActionUpdatedBlockIdAndAssetIdManyToManyEdgeTickerExternalAgentActionsArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TickerExternalAgentActionsOrderBy>>;
    filter?: Maybe<TickerExternalAgentActionFilter>;
  };

/** A connection to a list of `Asset` values, with data from `TickerExternalAgent`. */
export type BlockAssetsByTickerExternalAgentCreatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByTickerExternalAgentCreatedBlockIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `TickerExternalAgent`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByTickerExternalAgentCreatedBlockIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `TickerExternalAgent`. */
export type BlockAssetsByTickerExternalAgentCreatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TickerExternalAgent`. */
export type BlockAssetsByTickerExternalAgentCreatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByTickerExternalAgentCreatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TickerExternalAgent`. */
  tickerExternalAgents: TickerExternalAgentsConnection;
};

/** A `Asset` edge in the connection, with data from `TickerExternalAgent`. */
export type BlockAssetsByTickerExternalAgentCreatedBlockIdAndAssetIdManyToManyEdgeTickerExternalAgentsArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TickerExternalAgentsOrderBy>>;
    filter?: Maybe<TickerExternalAgentFilter>;
  };

/** A connection to a list of `Asset` values, with data from `TickerExternalAgentHistory`. */
export type BlockAssetsByTickerExternalAgentHistoryCreatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByTickerExternalAgentHistoryCreatedBlockIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `TickerExternalAgentHistory`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByTickerExternalAgentHistoryCreatedBlockIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `TickerExternalAgentHistory`. */
export type BlockAssetsByTickerExternalAgentHistoryCreatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type BlockAssetsByTickerExternalAgentHistoryCreatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByTickerExternalAgentHistoryCreatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TickerExternalAgentHistory`. */
  tickerExternalAgentHistories: TickerExternalAgentHistoriesConnection;
};

/** A `Asset` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type BlockAssetsByTickerExternalAgentHistoryCreatedBlockIdAndAssetIdManyToManyEdgeTickerExternalAgentHistoriesArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TickerExternalAgentHistoriesOrderBy>>;
    filter?: Maybe<TickerExternalAgentHistoryFilter>;
  };

/** A connection to a list of `Asset` values, with data from `TickerExternalAgentHistory`. */
export type BlockAssetsByTickerExternalAgentHistoryUpdatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByTickerExternalAgentHistoryUpdatedBlockIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `TickerExternalAgentHistory`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByTickerExternalAgentHistoryUpdatedBlockIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `TickerExternalAgentHistory`. */
export type BlockAssetsByTickerExternalAgentHistoryUpdatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type BlockAssetsByTickerExternalAgentHistoryUpdatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByTickerExternalAgentHistoryUpdatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TickerExternalAgentHistory`. */
  tickerExternalAgentHistories: TickerExternalAgentHistoriesConnection;
};

/** A `Asset` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type BlockAssetsByTickerExternalAgentHistoryUpdatedBlockIdAndAssetIdManyToManyEdgeTickerExternalAgentHistoriesArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TickerExternalAgentHistoriesOrderBy>>;
    filter?: Maybe<TickerExternalAgentHistoryFilter>;
  };

/** A connection to a list of `Asset` values, with data from `TickerExternalAgent`. */
export type BlockAssetsByTickerExternalAgentUpdatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByTickerExternalAgentUpdatedBlockIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `TickerExternalAgent`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByTickerExternalAgentUpdatedBlockIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `TickerExternalAgent`. */
export type BlockAssetsByTickerExternalAgentUpdatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TickerExternalAgent`. */
export type BlockAssetsByTickerExternalAgentUpdatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByTickerExternalAgentUpdatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TickerExternalAgent`. */
  tickerExternalAgents: TickerExternalAgentsConnection;
};

/** A `Asset` edge in the connection, with data from `TickerExternalAgent`. */
export type BlockAssetsByTickerExternalAgentUpdatedBlockIdAndAssetIdManyToManyEdgeTickerExternalAgentsArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TickerExternalAgentsOrderBy>>;
    filter?: Maybe<TickerExternalAgentFilter>;
  };

/** A connection to a list of `Asset` values, with data from `TransferCompliance`. */
export type BlockAssetsByTransferComplianceCreatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByTransferComplianceCreatedBlockIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByTransferComplianceCreatedBlockIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `TransferCompliance`. */
export type BlockAssetsByTransferComplianceCreatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TransferCompliance`. */
export type BlockAssetsByTransferComplianceCreatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByTransferComplianceCreatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliances: TransferCompliancesConnection;
};

/** A `Asset` edge in the connection, with data from `TransferCompliance`. */
export type BlockAssetsByTransferComplianceCreatedBlockIdAndAssetIdManyToManyEdgeTransferCompliancesArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TransferCompliancesOrderBy>>;
    filter?: Maybe<TransferComplianceFilter>;
  };

/** A connection to a list of `Asset` values, with data from `TransferComplianceExemption`. */
export type BlockAssetsByTransferComplianceExemptionCreatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByTransferComplianceExemptionCreatedBlockIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `TransferComplianceExemption`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByTransferComplianceExemptionCreatedBlockIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `TransferComplianceExemption`. */
export type BlockAssetsByTransferComplianceExemptionCreatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TransferComplianceExemption`. */
export type BlockAssetsByTransferComplianceExemptionCreatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByTransferComplianceExemptionCreatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TransferComplianceExemption`. */
  transferComplianceExemptions: TransferComplianceExemptionsConnection;
};

/** A `Asset` edge in the connection, with data from `TransferComplianceExemption`. */
export type BlockAssetsByTransferComplianceExemptionCreatedBlockIdAndAssetIdManyToManyEdgeTransferComplianceExemptionsArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TransferComplianceExemptionsOrderBy>>;
    filter?: Maybe<TransferComplianceExemptionFilter>;
  };

/** A connection to a list of `Asset` values, with data from `TransferComplianceExemption`. */
export type BlockAssetsByTransferComplianceExemptionUpdatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByTransferComplianceExemptionUpdatedBlockIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `TransferComplianceExemption`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByTransferComplianceExemptionUpdatedBlockIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `TransferComplianceExemption`. */
export type BlockAssetsByTransferComplianceExemptionUpdatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TransferComplianceExemption`. */
export type BlockAssetsByTransferComplianceExemptionUpdatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByTransferComplianceExemptionUpdatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TransferComplianceExemption`. */
  transferComplianceExemptions: TransferComplianceExemptionsConnection;
};

/** A `Asset` edge in the connection, with data from `TransferComplianceExemption`. */
export type BlockAssetsByTransferComplianceExemptionUpdatedBlockIdAndAssetIdManyToManyEdgeTransferComplianceExemptionsArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TransferComplianceExemptionsOrderBy>>;
    filter?: Maybe<TransferComplianceExemptionFilter>;
  };

/** A connection to a list of `Asset` values, with data from `TransferCompliance`. */
export type BlockAssetsByTransferComplianceUpdatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByTransferComplianceUpdatedBlockIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByTransferComplianceUpdatedBlockIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `TransferCompliance`. */
export type BlockAssetsByTransferComplianceUpdatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TransferCompliance`. */
export type BlockAssetsByTransferComplianceUpdatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByTransferComplianceUpdatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliances: TransferCompliancesConnection;
};

/** A `Asset` edge in the connection, with data from `TransferCompliance`. */
export type BlockAssetsByTransferComplianceUpdatedBlockIdAndAssetIdManyToManyEdgeTransferCompliancesArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TransferCompliancesOrderBy>>;
    filter?: Maybe<TransferComplianceFilter>;
  };

/** A connection to a list of `Asset` values, with data from `TransferManager`. */
export type BlockAssetsByTransferManagerCreatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByTransferManagerCreatedBlockIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `TransferManager`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByTransferManagerCreatedBlockIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `TransferManager`. */
export type BlockAssetsByTransferManagerCreatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TransferManager`. */
export type BlockAssetsByTransferManagerCreatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByTransferManagerCreatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TransferManager`. */
  transferManagers: TransferManagersConnection;
};

/** A `Asset` edge in the connection, with data from `TransferManager`. */
export type BlockAssetsByTransferManagerCreatedBlockIdAndAssetIdManyToManyEdgeTransferManagersArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TransferManagersOrderBy>>;
    filter?: Maybe<TransferManagerFilter>;
  };

/** A connection to a list of `Asset` values, with data from `TransferManager`. */
export type BlockAssetsByTransferManagerUpdatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByTransferManagerUpdatedBlockIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `TransferManager`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByTransferManagerUpdatedBlockIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `TransferManager`. */
export type BlockAssetsByTransferManagerUpdatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TransferManager`. */
export type BlockAssetsByTransferManagerUpdatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByTransferManagerUpdatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TransferManager`. */
  transferManagers: TransferManagersConnection;
};

/** A `Asset` edge in the connection, with data from `TransferManager`. */
export type BlockAssetsByTransferManagerUpdatedBlockIdAndAssetIdManyToManyEdgeTransferManagersArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TransferManagersOrderBy>>;
    filter?: Maybe<TransferManagerFilter>;
  };

/** A connection to a list of `Asset` values, with data from `TrustedClaimIssuer`. */
export type BlockAssetsByTrustedClaimIssuerCreatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByTrustedClaimIssuerCreatedBlockIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `TrustedClaimIssuer`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByTrustedClaimIssuerCreatedBlockIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `TrustedClaimIssuer`. */
export type BlockAssetsByTrustedClaimIssuerCreatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TrustedClaimIssuer`. */
export type BlockAssetsByTrustedClaimIssuerCreatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByTrustedClaimIssuerCreatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TrustedClaimIssuer`. */
  trustedClaimIssuers: TrustedClaimIssuersConnection;
};

/** A `Asset` edge in the connection, with data from `TrustedClaimIssuer`. */
export type BlockAssetsByTrustedClaimIssuerCreatedBlockIdAndAssetIdManyToManyEdgeTrustedClaimIssuersArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TrustedClaimIssuersOrderBy>>;
    filter?: Maybe<TrustedClaimIssuerFilter>;
  };

/** A connection to a list of `Asset` values, with data from `TrustedClaimIssuer`. */
export type BlockAssetsByTrustedClaimIssuerUpdatedBlockIdAndAssetIdManyToManyConnection = {
  __typename?: 'BlockAssetsByTrustedClaimIssuerUpdatedBlockIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `TrustedClaimIssuer`, and the cursor to aid in pagination. */
  edges: Array<BlockAssetsByTrustedClaimIssuerUpdatedBlockIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `TrustedClaimIssuer`. */
export type BlockAssetsByTrustedClaimIssuerUpdatedBlockIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TrustedClaimIssuer`. */
export type BlockAssetsByTrustedClaimIssuerUpdatedBlockIdAndAssetIdManyToManyEdge = {
  __typename?: 'BlockAssetsByTrustedClaimIssuerUpdatedBlockIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TrustedClaimIssuer`. */
  trustedClaimIssuers: TrustedClaimIssuersConnection;
};

/** A `Asset` edge in the connection, with data from `TrustedClaimIssuer`. */
export type BlockAssetsByTrustedClaimIssuerUpdatedBlockIdAndAssetIdManyToManyEdgeTrustedClaimIssuersArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TrustedClaimIssuersOrderBy>>;
    filter?: Maybe<TrustedClaimIssuerFilter>;
  };

/** A connection to a list of `Block` values, with data from `Account`. */
export type BlockBlocksByAccountCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByAccountCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Account`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByAccountCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Account`. */
export type BlockBlocksByAccountCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Account`. */
export type BlockBlocksByAccountCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByAccountCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Account`. */
  accountsByUpdatedBlockId: AccountsConnection;
};

/** A `Block` edge in the connection, with data from `Account`. */
export type BlockBlocksByAccountCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeAccountsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AccountsOrderBy>>;
    filter?: Maybe<AccountFilter>;
  };

/** A connection to a list of `Block` values, with data from `Account`. */
export type BlockBlocksByAccountUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByAccountUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Account`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByAccountUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Account`. */
export type BlockBlocksByAccountUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Account`. */
export type BlockBlocksByAccountUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByAccountUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Account`. */
  accountsByCreatedBlockId: AccountsConnection;
};

/** A `Block` edge in the connection, with data from `Account`. */
export type BlockBlocksByAccountUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeAccountsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AccountsOrderBy>>;
    filter?: Maybe<AccountFilter>;
  };

/** A connection to a list of `Block` values, with data from `AgentGroup`. */
export type BlockBlocksByAgentGroupCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByAgentGroupCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `AgentGroup`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByAgentGroupCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `AgentGroup`. */
export type BlockBlocksByAgentGroupCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AgentGroup`. */
export type BlockBlocksByAgentGroupCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByAgentGroupCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `AgentGroup`. */
  agentGroupsByUpdatedBlockId: AgentGroupsConnection;
};

/** A `Block` edge in the connection, with data from `AgentGroup`. */
export type BlockBlocksByAgentGroupCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeAgentGroupsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AgentGroupsOrderBy>>;
    filter?: Maybe<AgentGroupFilter>;
  };

/** A connection to a list of `Block` values, with data from `AgentGroupMembership`. */
export type BlockBlocksByAgentGroupMembershipCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByAgentGroupMembershipCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `AgentGroupMembership`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByAgentGroupMembershipCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `AgentGroupMembership`. */
export type BlockBlocksByAgentGroupMembershipCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AgentGroupMembership`. */
export type BlockBlocksByAgentGroupMembershipCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByAgentGroupMembershipCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `AgentGroupMembership`. */
  agentGroupMembershipsByUpdatedBlockId: AgentGroupMembershipsConnection;
};

/** A `Block` edge in the connection, with data from `AgentGroupMembership`. */
export type BlockBlocksByAgentGroupMembershipCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeAgentGroupMembershipsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AgentGroupMembershipsOrderBy>>;
    filter?: Maybe<AgentGroupMembershipFilter>;
  };

/** A connection to a list of `Block` values, with data from `AgentGroupMembership`. */
export type BlockBlocksByAgentGroupMembershipUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByAgentGroupMembershipUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `AgentGroupMembership`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByAgentGroupMembershipUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `AgentGroupMembership`. */
export type BlockBlocksByAgentGroupMembershipUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AgentGroupMembership`. */
export type BlockBlocksByAgentGroupMembershipUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByAgentGroupMembershipUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `AgentGroupMembership`. */
  agentGroupMembershipsByCreatedBlockId: AgentGroupMembershipsConnection;
};

/** A `Block` edge in the connection, with data from `AgentGroupMembership`. */
export type BlockBlocksByAgentGroupMembershipUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeAgentGroupMembershipsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AgentGroupMembershipsOrderBy>>;
    filter?: Maybe<AgentGroupMembershipFilter>;
  };

/** A connection to a list of `Block` values, with data from `AgentGroup`. */
export type BlockBlocksByAgentGroupUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByAgentGroupUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `AgentGroup`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByAgentGroupUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `AgentGroup`. */
export type BlockBlocksByAgentGroupUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AgentGroup`. */
export type BlockBlocksByAgentGroupUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByAgentGroupUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `AgentGroup`. */
  agentGroupsByCreatedBlockId: AgentGroupsConnection;
};

/** A `Block` edge in the connection, with data from `AgentGroup`. */
export type BlockBlocksByAgentGroupUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeAgentGroupsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AgentGroupsOrderBy>>;
    filter?: Maybe<AgentGroupFilter>;
  };

/** A connection to a list of `Block` values, with data from `Asset`. */
export type BlockBlocksByAssetCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByAssetCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Asset`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByAssetCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Asset`. */
export type BlockBlocksByAssetCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Asset`. */
export type BlockBlocksByAssetCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByAssetCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByUpdatedBlockId: AssetsConnection;
};

/** A `Block` edge in the connection, with data from `Asset`. */
export type BlockBlocksByAssetCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeAssetsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AssetsOrderBy>>;
    filter?: Maybe<AssetFilter>;
  };

/** A connection to a list of `Block` values, with data from `AssetDocument`. */
export type BlockBlocksByAssetDocumentCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByAssetDocumentCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `AssetDocument`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByAssetDocumentCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `AssetDocument`. */
export type BlockBlocksByAssetDocumentCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AssetDocument`. */
export type BlockBlocksByAssetDocumentCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByAssetDocumentCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `AssetDocument`. */
  assetDocumentsByUpdatedBlockId: AssetDocumentsConnection;
};

/** A `Block` edge in the connection, with data from `AssetDocument`. */
export type BlockBlocksByAssetDocumentCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeAssetDocumentsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AssetDocumentsOrderBy>>;
    filter?: Maybe<AssetDocumentFilter>;
  };

/** A connection to a list of `Block` values, with data from `AssetDocument`. */
export type BlockBlocksByAssetDocumentUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByAssetDocumentUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `AssetDocument`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByAssetDocumentUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `AssetDocument`. */
export type BlockBlocksByAssetDocumentUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AssetDocument`. */
export type BlockBlocksByAssetDocumentUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByAssetDocumentUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `AssetDocument`. */
  assetDocumentsByCreatedBlockId: AssetDocumentsConnection;
};

/** A `Block` edge in the connection, with data from `AssetDocument`. */
export type BlockBlocksByAssetDocumentUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeAssetDocumentsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AssetDocumentsOrderBy>>;
    filter?: Maybe<AssetDocumentFilter>;
  };

/** A connection to a list of `Block` values, with data from `AssetHolder`. */
export type BlockBlocksByAssetHolderCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByAssetHolderCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `AssetHolder`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByAssetHolderCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `AssetHolder`. */
export type BlockBlocksByAssetHolderCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AssetHolder`. */
export type BlockBlocksByAssetHolderCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByAssetHolderCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `AssetHolder`. */
  assetHoldersByUpdatedBlockId: AssetHoldersConnection;
};

/** A `Block` edge in the connection, with data from `AssetHolder`. */
export type BlockBlocksByAssetHolderCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeAssetHoldersByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AssetHoldersOrderBy>>;
    filter?: Maybe<AssetHolderFilter>;
  };

/** A connection to a list of `Block` values, with data from `AssetHolder`. */
export type BlockBlocksByAssetHolderUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByAssetHolderUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `AssetHolder`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByAssetHolderUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `AssetHolder`. */
export type BlockBlocksByAssetHolderUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AssetHolder`. */
export type BlockBlocksByAssetHolderUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByAssetHolderUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `AssetHolder`. */
  assetHoldersByCreatedBlockId: AssetHoldersConnection;
};

/** A `Block` edge in the connection, with data from `AssetHolder`. */
export type BlockBlocksByAssetHolderUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeAssetHoldersByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AssetHoldersOrderBy>>;
    filter?: Maybe<AssetHolderFilter>;
  };

/** A connection to a list of `Block` values, with data from `AssetPendingOwnershipTransfer`. */
export type BlockBlocksByAssetPendingOwnershipTransferCreatedBlockIdAndUpdatedBlockIdManyToManyConnection =
  {
    __typename?: 'BlockBlocksByAssetPendingOwnershipTransferCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
    /** A list of `Block` objects. */
    nodes: Array<Maybe<Block>>;
    /** A list of edges which contains the `Block`, info from the `AssetPendingOwnershipTransfer`, and the cursor to aid in pagination. */
    edges: Array<BlockBlocksByAssetPendingOwnershipTransferCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Block` you could get from the connection. */
    totalCount: Scalars['Int'];
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<BlockAggregates>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<BlockAggregates>>;
  };

/** A connection to a list of `Block` values, with data from `AssetPendingOwnershipTransfer`. */
export type BlockBlocksByAssetPendingOwnershipTransferCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AssetPendingOwnershipTransfer`. */
export type BlockBlocksByAssetPendingOwnershipTransferCreatedBlockIdAndUpdatedBlockIdManyToManyEdge =
  {
    __typename?: 'BlockBlocksByAssetPendingOwnershipTransferCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']>;
    /** The `Block` at the end of the edge. */
    node?: Maybe<Block>;
    /** Reads and enables pagination through a set of `AssetPendingOwnershipTransfer`. */
    assetPendingOwnershipTransfersByUpdatedBlockId: AssetPendingOwnershipTransfersConnection;
  };

/** A `Block` edge in the connection, with data from `AssetPendingOwnershipTransfer`. */
export type BlockBlocksByAssetPendingOwnershipTransferCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeAssetPendingOwnershipTransfersByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AssetPendingOwnershipTransfersOrderBy>>;
    filter?: Maybe<AssetPendingOwnershipTransferFilter>;
  };

/** A connection to a list of `Block` values, with data from `AssetPendingOwnershipTransfer`. */
export type BlockBlocksByAssetPendingOwnershipTransferUpdatedBlockIdAndCreatedBlockIdManyToManyConnection =
  {
    __typename?: 'BlockBlocksByAssetPendingOwnershipTransferUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
    /** A list of `Block` objects. */
    nodes: Array<Maybe<Block>>;
    /** A list of edges which contains the `Block`, info from the `AssetPendingOwnershipTransfer`, and the cursor to aid in pagination. */
    edges: Array<BlockBlocksByAssetPendingOwnershipTransferUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Block` you could get from the connection. */
    totalCount: Scalars['Int'];
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<BlockAggregates>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<BlockAggregates>>;
  };

/** A connection to a list of `Block` values, with data from `AssetPendingOwnershipTransfer`. */
export type BlockBlocksByAssetPendingOwnershipTransferUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AssetPendingOwnershipTransfer`. */
export type BlockBlocksByAssetPendingOwnershipTransferUpdatedBlockIdAndCreatedBlockIdManyToManyEdge =
  {
    __typename?: 'BlockBlocksByAssetPendingOwnershipTransferUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']>;
    /** The `Block` at the end of the edge. */
    node?: Maybe<Block>;
    /** Reads and enables pagination through a set of `AssetPendingOwnershipTransfer`. */
    assetPendingOwnershipTransfersByCreatedBlockId: AssetPendingOwnershipTransfersConnection;
  };

/** A `Block` edge in the connection, with data from `AssetPendingOwnershipTransfer`. */
export type BlockBlocksByAssetPendingOwnershipTransferUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeAssetPendingOwnershipTransfersByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AssetPendingOwnershipTransfersOrderBy>>;
    filter?: Maybe<AssetPendingOwnershipTransferFilter>;
  };

/** A connection to a list of `Block` values, with data from `Asset`. */
export type BlockBlocksByAssetUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByAssetUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Asset`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByAssetUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Asset`. */
export type BlockBlocksByAssetUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Asset`. */
export type BlockBlocksByAssetUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByAssetUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByCreatedBlockId: AssetsConnection;
};

/** A `Block` edge in the connection, with data from `Asset`. */
export type BlockBlocksByAssetUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeAssetsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AssetsOrderBy>>;
    filter?: Maybe<AssetFilter>;
  };

/** A connection to a list of `Block` values, with data from `Authorization`. */
export type BlockBlocksByAuthorizationCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByAuthorizationCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Authorization`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByAuthorizationCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Authorization`. */
export type BlockBlocksByAuthorizationCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Authorization`. */
export type BlockBlocksByAuthorizationCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByAuthorizationCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Authorization`. */
  authorizationsByUpdatedBlockId: AuthorizationsConnection;
};

/** A `Block` edge in the connection, with data from `Authorization`. */
export type BlockBlocksByAuthorizationCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeAuthorizationsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AuthorizationsOrderBy>>;
    filter?: Maybe<AuthorizationFilter>;
  };

/** A connection to a list of `Block` values, with data from `Authorization`. */
export type BlockBlocksByAuthorizationUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByAuthorizationUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Authorization`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByAuthorizationUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Authorization`. */
export type BlockBlocksByAuthorizationUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Authorization`. */
export type BlockBlocksByAuthorizationUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByAuthorizationUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Authorization`. */
  authorizationsByCreatedBlockId: AuthorizationsConnection;
};

/** A `Block` edge in the connection, with data from `Authorization`. */
export type BlockBlocksByAuthorizationUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeAuthorizationsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AuthorizationsOrderBy>>;
    filter?: Maybe<AuthorizationFilter>;
  };

/** A connection to a list of `Block` values, with data from `BridgeEvent`. */
export type BlockBlocksByBridgeEventCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByBridgeEventCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `BridgeEvent`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByBridgeEventCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `BridgeEvent`. */
export type BlockBlocksByBridgeEventCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `BridgeEvent`. */
export type BlockBlocksByBridgeEventCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByBridgeEventCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `BridgeEvent`. */
  bridgeEventsByUpdatedBlockId: BridgeEventsConnection;
};

/** A `Block` edge in the connection, with data from `BridgeEvent`. */
export type BlockBlocksByBridgeEventCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeBridgeEventsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<BridgeEventsOrderBy>>;
    filter?: Maybe<BridgeEventFilter>;
  };

/** A connection to a list of `Block` values, with data from `BridgeEvent`. */
export type BlockBlocksByBridgeEventUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByBridgeEventUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `BridgeEvent`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByBridgeEventUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `BridgeEvent`. */
export type BlockBlocksByBridgeEventUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `BridgeEvent`. */
export type BlockBlocksByBridgeEventUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByBridgeEventUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `BridgeEvent`. */
  bridgeEventsByCreatedBlockId: BridgeEventsConnection;
};

/** A `Block` edge in the connection, with data from `BridgeEvent`. */
export type BlockBlocksByBridgeEventUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeBridgeEventsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<BridgeEventsOrderBy>>;
    filter?: Maybe<BridgeEventFilter>;
  };

/** A connection to a list of `Block` values, with data from `Claim`. */
export type BlockBlocksByClaimCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByClaimCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Claim`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByClaimCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Claim`. */
export type BlockBlocksByClaimCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Claim`. */
export type BlockBlocksByClaimCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByClaimCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Claim`. */
  claimsByUpdatedBlockId: ClaimsConnection;
};

/** A `Block` edge in the connection, with data from `Claim`. */
export type BlockBlocksByClaimCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeClaimsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<ClaimsOrderBy>>;
    filter?: Maybe<ClaimFilter>;
  };

/** A connection to a list of `Block` values, with data from `ClaimScope`. */
export type BlockBlocksByClaimScopeCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByClaimScopeCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `ClaimScope`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByClaimScopeCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `ClaimScope`. */
export type BlockBlocksByClaimScopeCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `ClaimScope`. */
export type BlockBlocksByClaimScopeCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByClaimScopeCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `ClaimScope`. */
  claimScopesByUpdatedBlockId: ClaimScopesConnection;
};

/** A `Block` edge in the connection, with data from `ClaimScope`. */
export type BlockBlocksByClaimScopeCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeClaimScopesByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<ClaimScopesOrderBy>>;
    filter?: Maybe<ClaimScopeFilter>;
  };

/** A connection to a list of `Block` values, with data from `ClaimScope`. */
export type BlockBlocksByClaimScopeUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByClaimScopeUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `ClaimScope`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByClaimScopeUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `ClaimScope`. */
export type BlockBlocksByClaimScopeUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `ClaimScope`. */
export type BlockBlocksByClaimScopeUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByClaimScopeUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `ClaimScope`. */
  claimScopesByCreatedBlockId: ClaimScopesConnection;
};

/** A `Block` edge in the connection, with data from `ClaimScope`. */
export type BlockBlocksByClaimScopeUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeClaimScopesByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<ClaimScopesOrderBy>>;
    filter?: Maybe<ClaimScopeFilter>;
  };

/** A connection to a list of `Block` values, with data from `Claim`. */
export type BlockBlocksByClaimUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByClaimUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Claim`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByClaimUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Claim`. */
export type BlockBlocksByClaimUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Claim`. */
export type BlockBlocksByClaimUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByClaimUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Claim`. */
  claimsByCreatedBlockId: ClaimsConnection;
};

/** A `Block` edge in the connection, with data from `Claim`. */
export type BlockBlocksByClaimUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeClaimsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<ClaimsOrderBy>>;
    filter?: Maybe<ClaimFilter>;
  };

/** A connection to a list of `Block` values, with data from `Compliance`. */
export type BlockBlocksByComplianceCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByComplianceCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Compliance`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByComplianceCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Compliance`. */
export type BlockBlocksByComplianceCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Compliance`. */
export type BlockBlocksByComplianceCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByComplianceCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Compliance`. */
  compliancesByUpdatedBlockId: CompliancesConnection;
};

/** A `Block` edge in the connection, with data from `Compliance`. */
export type BlockBlocksByComplianceCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeCompliancesByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<CompliancesOrderBy>>;
    filter?: Maybe<ComplianceFilter>;
  };

/** A connection to a list of `Block` values, with data from `Compliance`. */
export type BlockBlocksByComplianceUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByComplianceUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Compliance`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByComplianceUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Compliance`. */
export type BlockBlocksByComplianceUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Compliance`. */
export type BlockBlocksByComplianceUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByComplianceUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Compliance`. */
  compliancesByCreatedBlockId: CompliancesConnection;
};

/** A `Block` edge in the connection, with data from `Compliance`. */
export type BlockBlocksByComplianceUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeCompliancesByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<CompliancesOrderBy>>;
    filter?: Maybe<ComplianceFilter>;
  };

/** A connection to a list of `Block` values, with data from `Distribution`. */
export type BlockBlocksByDistributionCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByDistributionCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByDistributionCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Distribution`. */
export type BlockBlocksByDistributionCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Distribution`. */
export type BlockBlocksByDistributionCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByDistributionCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributionsByUpdatedBlockId: DistributionsConnection;
};

/** A `Block` edge in the connection, with data from `Distribution`. */
export type BlockBlocksByDistributionCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeDistributionsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<DistributionsOrderBy>>;
    filter?: Maybe<DistributionFilter>;
  };

/** A connection to a list of `Block` values, with data from `DistributionPayment`. */
export type BlockBlocksByDistributionPaymentCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByDistributionPaymentCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `DistributionPayment`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByDistributionPaymentCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `DistributionPayment`. */
export type BlockBlocksByDistributionPaymentCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `DistributionPayment`. */
export type BlockBlocksByDistributionPaymentCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByDistributionPaymentCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `DistributionPayment`. */
  distributionPaymentsByUpdatedBlockId: DistributionPaymentsConnection;
};

/** A `Block` edge in the connection, with data from `DistributionPayment`. */
export type BlockBlocksByDistributionPaymentCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeDistributionPaymentsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<DistributionPaymentsOrderBy>>;
    filter?: Maybe<DistributionPaymentFilter>;
  };

/** A connection to a list of `Block` values, with data from `DistributionPayment`. */
export type BlockBlocksByDistributionPaymentUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByDistributionPaymentUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `DistributionPayment`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByDistributionPaymentUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `DistributionPayment`. */
export type BlockBlocksByDistributionPaymentUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `DistributionPayment`. */
export type BlockBlocksByDistributionPaymentUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByDistributionPaymentUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `DistributionPayment`. */
  distributionPaymentsByCreatedBlockId: DistributionPaymentsConnection;
};

/** A `Block` edge in the connection, with data from `DistributionPayment`. */
export type BlockBlocksByDistributionPaymentUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeDistributionPaymentsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<DistributionPaymentsOrderBy>>;
    filter?: Maybe<DistributionPaymentFilter>;
  };

/** A connection to a list of `Block` values, with data from `Distribution`. */
export type BlockBlocksByDistributionUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByDistributionUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByDistributionUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Distribution`. */
export type BlockBlocksByDistributionUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Distribution`. */
export type BlockBlocksByDistributionUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByDistributionUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributionsByCreatedBlockId: DistributionsConnection;
};

/** A `Block` edge in the connection, with data from `Distribution`. */
export type BlockBlocksByDistributionUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeDistributionsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<DistributionsOrderBy>>;
    filter?: Maybe<DistributionFilter>;
  };

/** A connection to a list of `Block` values, with data from `Funding`. */
export type BlockBlocksByFundingCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByFundingCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Funding`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByFundingCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Funding`. */
export type BlockBlocksByFundingCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Funding`. */
export type BlockBlocksByFundingCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByFundingCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Funding`. */
  fundingsByUpdatedBlockId: FundingsConnection;
};

/** A `Block` edge in the connection, with data from `Funding`. */
export type BlockBlocksByFundingCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeFundingsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<FundingsOrderBy>>;
    filter?: Maybe<FundingFilter>;
  };

/** A connection to a list of `Block` values, with data from `Funding`. */
export type BlockBlocksByFundingUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByFundingUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Funding`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByFundingUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Funding`. */
export type BlockBlocksByFundingUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Funding`. */
export type BlockBlocksByFundingUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByFundingUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Funding`. */
  fundingsByCreatedBlockId: FundingsConnection;
};

/** A `Block` edge in the connection, with data from `Funding`. */
export type BlockBlocksByFundingUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeFundingsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<FundingsOrderBy>>;
    filter?: Maybe<FundingFilter>;
  };

/** A connection to a list of `Block` values, with data from `Identity`. */
export type BlockBlocksByIdentityCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByIdentityCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Identity`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByIdentityCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Identity`. */
export type BlockBlocksByIdentityCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Identity`. */
export type BlockBlocksByIdentityCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByIdentityCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByUpdatedBlockId: IdentitiesConnection;
};

/** A `Block` edge in the connection, with data from `Identity`. */
export type BlockBlocksByIdentityCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeIdentitiesByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<IdentitiesOrderBy>>;
    filter?: Maybe<IdentityFilter>;
  };

/** A connection to a list of `Block` values, with data from `Identity`. */
export type BlockBlocksByIdentityUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByIdentityUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Identity`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByIdentityUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Identity`. */
export type BlockBlocksByIdentityUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Identity`. */
export type BlockBlocksByIdentityUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByIdentityUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByCreatedBlockId: IdentitiesConnection;
};

/** A `Block` edge in the connection, with data from `Identity`. */
export type BlockBlocksByIdentityUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeIdentitiesByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<IdentitiesOrderBy>>;
    filter?: Maybe<IdentityFilter>;
  };

/** A connection to a list of `Block` values, with data from `Instruction`. */
export type BlockBlocksByInstructionCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByInstructionCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Instruction`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByInstructionCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Instruction`. */
export type BlockBlocksByInstructionCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Instruction`. */
export type BlockBlocksByInstructionCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByInstructionCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Instruction`. */
  instructionsByUpdatedBlockId: InstructionsConnection;
};

/** A `Block` edge in the connection, with data from `Instruction`. */
export type BlockBlocksByInstructionCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeInstructionsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<InstructionsOrderBy>>;
    filter?: Maybe<InstructionFilter>;
  };

/** A connection to a list of `Block` values, with data from `Instruction`. */
export type BlockBlocksByInstructionUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByInstructionUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Instruction`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByInstructionUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Instruction`. */
export type BlockBlocksByInstructionUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Instruction`. */
export type BlockBlocksByInstructionUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByInstructionUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Instruction`. */
  instructionsByCreatedBlockId: InstructionsConnection;
};

/** A `Block` edge in the connection, with data from `Instruction`. */
export type BlockBlocksByInstructionUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeInstructionsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<InstructionsOrderBy>>;
    filter?: Maybe<InstructionFilter>;
  };

/** A connection to a list of `Block` values, with data from `Investment`. */
export type BlockBlocksByInvestmentCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByInvestmentCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Investment`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByInvestmentCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Investment`. */
export type BlockBlocksByInvestmentCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Investment`. */
export type BlockBlocksByInvestmentCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByInvestmentCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Investment`. */
  investmentsByUpdatedBlockId: InvestmentsConnection;
};

/** A `Block` edge in the connection, with data from `Investment`. */
export type BlockBlocksByInvestmentCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeInvestmentsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<InvestmentsOrderBy>>;
    filter?: Maybe<InvestmentFilter>;
  };

/** A connection to a list of `Block` values, with data from `Investment`. */
export type BlockBlocksByInvestmentUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByInvestmentUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Investment`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByInvestmentUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Investment`. */
export type BlockBlocksByInvestmentUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Investment`. */
export type BlockBlocksByInvestmentUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByInvestmentUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Investment`. */
  investmentsByCreatedBlockId: InvestmentsConnection;
};

/** A `Block` edge in the connection, with data from `Investment`. */
export type BlockBlocksByInvestmentUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeInvestmentsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<InvestmentsOrderBy>>;
    filter?: Maybe<InvestmentFilter>;
  };

/** A connection to a list of `Block` values, with data from `Leg`. */
export type BlockBlocksByLegCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByLegCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByLegCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Leg`. */
export type BlockBlocksByLegCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Leg`. */
export type BlockBlocksByLegCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByLegCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByUpdatedBlockId: LegsConnection;
};

/** A `Block` edge in the connection, with data from `Leg`. */
export type BlockBlocksByLegCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeLegsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<LegsOrderBy>>;
    filter?: Maybe<LegFilter>;
  };

/** A connection to a list of `Block` values, with data from `Leg`. */
export type BlockBlocksByLegUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByLegUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByLegUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Leg`. */
export type BlockBlocksByLegUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Leg`. */
export type BlockBlocksByLegUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByLegUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByCreatedBlockId: LegsConnection;
};

/** A `Block` edge in the connection, with data from `Leg`. */
export type BlockBlocksByLegUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeLegsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<LegsOrderBy>>;
    filter?: Maybe<LegFilter>;
  };

/** A connection to a list of `Block` values, with data from `Permission`. */
export type BlockBlocksByPermissionCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByPermissionCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Permission`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByPermissionCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Permission`. */
export type BlockBlocksByPermissionCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Permission`. */
export type BlockBlocksByPermissionCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByPermissionCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Permission`. */
  permissionsByUpdatedBlockId: PermissionsConnection;
};

/** A `Block` edge in the connection, with data from `Permission`. */
export type BlockBlocksByPermissionCreatedBlockIdAndUpdatedBlockIdManyToManyEdgePermissionsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<PermissionsOrderBy>>;
    filter?: Maybe<PermissionFilter>;
  };

/** A connection to a list of `Block` values, with data from `Permission`. */
export type BlockBlocksByPermissionUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByPermissionUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Permission`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByPermissionUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Permission`. */
export type BlockBlocksByPermissionUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Permission`. */
export type BlockBlocksByPermissionUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByPermissionUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Permission`. */
  permissionsByCreatedBlockId: PermissionsConnection;
};

/** A `Block` edge in the connection, with data from `Permission`. */
export type BlockBlocksByPermissionUpdatedBlockIdAndCreatedBlockIdManyToManyEdgePermissionsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<PermissionsOrderBy>>;
    filter?: Maybe<PermissionFilter>;
  };

/** A connection to a list of `Block` values, with data from `Portfolio`. */
export type BlockBlocksByPortfolioCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByPortfolioCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Portfolio`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByPortfolioCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Portfolio`. */
export type BlockBlocksByPortfolioCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Portfolio`. */
export type BlockBlocksByPortfolioCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByPortfolioCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByUpdatedBlockId: PortfoliosConnection;
};

/** A `Block` edge in the connection, with data from `Portfolio`. */
export type BlockBlocksByPortfolioCreatedBlockIdAndUpdatedBlockIdManyToManyEdgePortfoliosByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<PortfoliosOrderBy>>;
    filter?: Maybe<PortfolioFilter>;
  };

/** A connection to a list of `Block` values, with data from `PortfolioMovement`. */
export type BlockBlocksByPortfolioMovementCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByPortfolioMovementCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByPortfolioMovementCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `PortfolioMovement`. */
export type BlockBlocksByPortfolioMovementCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `PortfolioMovement`. */
export type BlockBlocksByPortfolioMovementCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByPortfolioMovementCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByUpdatedBlockId: PortfolioMovementsConnection;
};

/** A `Block` edge in the connection, with data from `PortfolioMovement`. */
export type BlockBlocksByPortfolioMovementCreatedBlockIdAndUpdatedBlockIdManyToManyEdgePortfolioMovementsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<PortfolioMovementsOrderBy>>;
    filter?: Maybe<PortfolioMovementFilter>;
  };

/** A connection to a list of `Block` values, with data from `PortfolioMovement`. */
export type BlockBlocksByPortfolioMovementUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByPortfolioMovementUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByPortfolioMovementUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `PortfolioMovement`. */
export type BlockBlocksByPortfolioMovementUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `PortfolioMovement`. */
export type BlockBlocksByPortfolioMovementUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByPortfolioMovementUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByCreatedBlockId: PortfolioMovementsConnection;
};

/** A `Block` edge in the connection, with data from `PortfolioMovement`. */
export type BlockBlocksByPortfolioMovementUpdatedBlockIdAndCreatedBlockIdManyToManyEdgePortfolioMovementsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<PortfolioMovementsOrderBy>>;
    filter?: Maybe<PortfolioMovementFilter>;
  };

/** A connection to a list of `Block` values, with data from `Portfolio`. */
export type BlockBlocksByPortfolioUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByPortfolioUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Portfolio`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByPortfolioUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Portfolio`. */
export type BlockBlocksByPortfolioUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Portfolio`. */
export type BlockBlocksByPortfolioUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByPortfolioUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByCreatedBlockId: PortfoliosConnection;
};

/** A `Block` edge in the connection, with data from `Portfolio`. */
export type BlockBlocksByPortfolioUpdatedBlockIdAndCreatedBlockIdManyToManyEdgePortfoliosByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<PortfoliosOrderBy>>;
    filter?: Maybe<PortfolioFilter>;
  };

/** A connection to a list of `Block` values, with data from `Proposal`. */
export type BlockBlocksByProposalCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByProposalCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Proposal`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByProposalCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Proposal`. */
export type BlockBlocksByProposalCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Proposal`. */
export type BlockBlocksByProposalCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByProposalCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Proposal`. */
  proposalsByUpdatedBlockId: ProposalsConnection;
};

/** A `Block` edge in the connection, with data from `Proposal`. */
export type BlockBlocksByProposalCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeProposalsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<ProposalsOrderBy>>;
    filter?: Maybe<ProposalFilter>;
  };

/** A connection to a list of `Block` values, with data from `Proposal`. */
export type BlockBlocksByProposalUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByProposalUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Proposal`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByProposalUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Proposal`. */
export type BlockBlocksByProposalUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Proposal`. */
export type BlockBlocksByProposalUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByProposalUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Proposal`. */
  proposalsByCreatedBlockId: ProposalsConnection;
};

/** A `Block` edge in the connection, with data from `Proposal`. */
export type BlockBlocksByProposalUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeProposalsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<ProposalsOrderBy>>;
    filter?: Maybe<ProposalFilter>;
  };

/** A connection to a list of `Block` values, with data from `ProposalVote`. */
export type BlockBlocksByProposalVoteCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByProposalVoteCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `ProposalVote`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByProposalVoteCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `ProposalVote`. */
export type BlockBlocksByProposalVoteCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `ProposalVote`. */
export type BlockBlocksByProposalVoteCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByProposalVoteCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `ProposalVote`. */
  proposalVotesByUpdatedBlockId: ProposalVotesConnection;
};

/** A `Block` edge in the connection, with data from `ProposalVote`. */
export type BlockBlocksByProposalVoteCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeProposalVotesByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<ProposalVotesOrderBy>>;
    filter?: Maybe<ProposalVoteFilter>;
  };

/** A connection to a list of `Block` values, with data from `ProposalVote`. */
export type BlockBlocksByProposalVoteUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByProposalVoteUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `ProposalVote`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByProposalVoteUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `ProposalVote`. */
export type BlockBlocksByProposalVoteUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `ProposalVote`. */
export type BlockBlocksByProposalVoteUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByProposalVoteUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `ProposalVote`. */
  proposalVotesByCreatedBlockId: ProposalVotesConnection;
};

/** A `Block` edge in the connection, with data from `ProposalVote`. */
export type BlockBlocksByProposalVoteUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeProposalVotesByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<ProposalVotesOrderBy>>;
    filter?: Maybe<ProposalVoteFilter>;
  };

/** A connection to a list of `Block` values, with data from `Settlement`. */
export type BlockBlocksBySettlementCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksBySettlementCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Settlement`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksBySettlementCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Settlement`. */
export type BlockBlocksBySettlementCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Settlement`. */
export type BlockBlocksBySettlementCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksBySettlementCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Settlement`. */
  settlementsByUpdatedBlockId: SettlementsConnection;
};

/** A `Block` edge in the connection, with data from `Settlement`. */
export type BlockBlocksBySettlementCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeSettlementsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<SettlementsOrderBy>>;
    filter?: Maybe<SettlementFilter>;
  };

/** A connection to a list of `Block` values, with data from `Settlement`. */
export type BlockBlocksBySettlementUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksBySettlementUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Settlement`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksBySettlementUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Settlement`. */
export type BlockBlocksBySettlementUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Settlement`. */
export type BlockBlocksBySettlementUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksBySettlementUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Settlement`. */
  settlementsByCreatedBlockId: SettlementsConnection;
};

/** A `Block` edge in the connection, with data from `Settlement`. */
export type BlockBlocksBySettlementUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeSettlementsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<SettlementsOrderBy>>;
    filter?: Maybe<SettlementFilter>;
  };

/** A connection to a list of `Block` values, with data from `StakingEvent`. */
export type BlockBlocksByStakingEventCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByStakingEventCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `StakingEvent`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByStakingEventCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `StakingEvent`. */
export type BlockBlocksByStakingEventCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `StakingEvent`. */
export type BlockBlocksByStakingEventCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByStakingEventCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `StakingEvent`. */
  stakingEventsByUpdatedBlockId: StakingEventsConnection;
};

/** A `Block` edge in the connection, with data from `StakingEvent`. */
export type BlockBlocksByStakingEventCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeStakingEventsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<StakingEventsOrderBy>>;
    filter?: Maybe<StakingEventFilter>;
  };

/** A connection to a list of `Block` values, with data from `StakingEvent`. */
export type BlockBlocksByStakingEventUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByStakingEventUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `StakingEvent`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByStakingEventUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `StakingEvent`. */
export type BlockBlocksByStakingEventUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `StakingEvent`. */
export type BlockBlocksByStakingEventUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByStakingEventUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `StakingEvent`. */
  stakingEventsByCreatedBlockId: StakingEventsConnection;
};

/** A `Block` edge in the connection, with data from `StakingEvent`. */
export type BlockBlocksByStakingEventUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeStakingEventsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<StakingEventsOrderBy>>;
    filter?: Maybe<StakingEventFilter>;
  };

/** A connection to a list of `Block` values, with data from `StatType`. */
export type BlockBlocksByStatTypeCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByStatTypeCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `StatType`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByStatTypeCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `StatType`. */
export type BlockBlocksByStatTypeCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `StatType`. */
export type BlockBlocksByStatTypeCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByStatTypeCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypesByUpdatedBlockId: StatTypesConnection;
};

/** A `Block` edge in the connection, with data from `StatType`. */
export type BlockBlocksByStatTypeCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeStatTypesByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<StatTypesOrderBy>>;
    filter?: Maybe<StatTypeFilter>;
  };

/** A connection to a list of `Block` values, with data from `StatType`. */
export type BlockBlocksByStatTypeUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByStatTypeUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `StatType`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByStatTypeUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `StatType`. */
export type BlockBlocksByStatTypeUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `StatType`. */
export type BlockBlocksByStatTypeUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByStatTypeUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypesByCreatedBlockId: StatTypesConnection;
};

/** A `Block` edge in the connection, with data from `StatType`. */
export type BlockBlocksByStatTypeUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeStatTypesByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<StatTypesOrderBy>>;
    filter?: Maybe<StatTypeFilter>;
  };

/** A connection to a list of `Block` values, with data from `Sto`. */
export type BlockBlocksByStoCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByStoCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByStoCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Sto`. */
export type BlockBlocksByStoCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Sto`. */
export type BlockBlocksByStoCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByStoCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByUpdatedBlockId: StosConnection;
};

/** A `Block` edge in the connection, with data from `Sto`. */
export type BlockBlocksByStoCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeStosByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<StosOrderBy>>;
    filter?: Maybe<StoFilter>;
  };

/** A connection to a list of `Block` values, with data from `Sto`. */
export type BlockBlocksByStoUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByStoUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Sto`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByStoUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Sto`. */
export type BlockBlocksByStoUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Sto`. */
export type BlockBlocksByStoUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByStoUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Sto`. */
  stosByCreatedBlockId: StosConnection;
};

/** A `Block` edge in the connection, with data from `Sto`. */
export type BlockBlocksByStoUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeStosByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<StosOrderBy>>;
    filter?: Maybe<StoFilter>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentAction`. */
export type BlockBlocksByTickerExternalAgentActionCreatedBlockIdAndUpdatedBlockIdManyToManyConnection =
  {
    __typename?: 'BlockBlocksByTickerExternalAgentActionCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
    /** A list of `Block` objects. */
    nodes: Array<Maybe<Block>>;
    /** A list of edges which contains the `Block`, info from the `TickerExternalAgentAction`, and the cursor to aid in pagination. */
    edges: Array<BlockBlocksByTickerExternalAgentActionCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Block` you could get from the connection. */
    totalCount: Scalars['Int'];
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<BlockAggregates>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<BlockAggregates>>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentAction`. */
export type BlockBlocksByTickerExternalAgentActionCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TickerExternalAgentAction`. */
export type BlockBlocksByTickerExternalAgentActionCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByTickerExternalAgentActionCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TickerExternalAgentAction`. */
  tickerExternalAgentActionsByUpdatedBlockId: TickerExternalAgentActionsConnection;
};

/** A `Block` edge in the connection, with data from `TickerExternalAgentAction`. */
export type BlockBlocksByTickerExternalAgentActionCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeTickerExternalAgentActionsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TickerExternalAgentActionsOrderBy>>;
    filter?: Maybe<TickerExternalAgentActionFilter>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentAction`. */
export type BlockBlocksByTickerExternalAgentActionUpdatedBlockIdAndCreatedBlockIdManyToManyConnection =
  {
    __typename?: 'BlockBlocksByTickerExternalAgentActionUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
    /** A list of `Block` objects. */
    nodes: Array<Maybe<Block>>;
    /** A list of edges which contains the `Block`, info from the `TickerExternalAgentAction`, and the cursor to aid in pagination. */
    edges: Array<BlockBlocksByTickerExternalAgentActionUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Block` you could get from the connection. */
    totalCount: Scalars['Int'];
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<BlockAggregates>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<BlockAggregates>>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentAction`. */
export type BlockBlocksByTickerExternalAgentActionUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TickerExternalAgentAction`. */
export type BlockBlocksByTickerExternalAgentActionUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByTickerExternalAgentActionUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TickerExternalAgentAction`. */
  tickerExternalAgentActionsByCreatedBlockId: TickerExternalAgentActionsConnection;
};

/** A `Block` edge in the connection, with data from `TickerExternalAgentAction`. */
export type BlockBlocksByTickerExternalAgentActionUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeTickerExternalAgentActionsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TickerExternalAgentActionsOrderBy>>;
    filter?: Maybe<TickerExternalAgentActionFilter>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgent`. */
export type BlockBlocksByTickerExternalAgentCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByTickerExternalAgentCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `TickerExternalAgent`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByTickerExternalAgentCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `TickerExternalAgent`. */
export type BlockBlocksByTickerExternalAgentCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TickerExternalAgent`. */
export type BlockBlocksByTickerExternalAgentCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByTickerExternalAgentCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TickerExternalAgent`. */
  tickerExternalAgentsByUpdatedBlockId: TickerExternalAgentsConnection;
};

/** A `Block` edge in the connection, with data from `TickerExternalAgent`. */
export type BlockBlocksByTickerExternalAgentCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeTickerExternalAgentsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TickerExternalAgentsOrderBy>>;
    filter?: Maybe<TickerExternalAgentFilter>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentHistory`. */
export type BlockBlocksByTickerExternalAgentHistoryCreatedBlockIdAndUpdatedBlockIdManyToManyConnection =
  {
    __typename?: 'BlockBlocksByTickerExternalAgentHistoryCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
    /** A list of `Block` objects. */
    nodes: Array<Maybe<Block>>;
    /** A list of edges which contains the `Block`, info from the `TickerExternalAgentHistory`, and the cursor to aid in pagination. */
    edges: Array<BlockBlocksByTickerExternalAgentHistoryCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Block` you could get from the connection. */
    totalCount: Scalars['Int'];
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<BlockAggregates>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<BlockAggregates>>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentHistory`. */
export type BlockBlocksByTickerExternalAgentHistoryCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type BlockBlocksByTickerExternalAgentHistoryCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByTickerExternalAgentHistoryCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TickerExternalAgentHistory`. */
  tickerExternalAgentHistoriesByUpdatedBlockId: TickerExternalAgentHistoriesConnection;
};

/** A `Block` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type BlockBlocksByTickerExternalAgentHistoryCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeTickerExternalAgentHistoriesByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TickerExternalAgentHistoriesOrderBy>>;
    filter?: Maybe<TickerExternalAgentHistoryFilter>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentHistory`. */
export type BlockBlocksByTickerExternalAgentHistoryUpdatedBlockIdAndCreatedBlockIdManyToManyConnection =
  {
    __typename?: 'BlockBlocksByTickerExternalAgentHistoryUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
    /** A list of `Block` objects. */
    nodes: Array<Maybe<Block>>;
    /** A list of edges which contains the `Block`, info from the `TickerExternalAgentHistory`, and the cursor to aid in pagination. */
    edges: Array<BlockBlocksByTickerExternalAgentHistoryUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Block` you could get from the connection. */
    totalCount: Scalars['Int'];
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<BlockAggregates>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<BlockAggregates>>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentHistory`. */
export type BlockBlocksByTickerExternalAgentHistoryUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type BlockBlocksByTickerExternalAgentHistoryUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByTickerExternalAgentHistoryUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TickerExternalAgentHistory`. */
  tickerExternalAgentHistoriesByCreatedBlockId: TickerExternalAgentHistoriesConnection;
};

/** A `Block` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type BlockBlocksByTickerExternalAgentHistoryUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeTickerExternalAgentHistoriesByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TickerExternalAgentHistoriesOrderBy>>;
    filter?: Maybe<TickerExternalAgentHistoryFilter>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgent`. */
export type BlockBlocksByTickerExternalAgentUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByTickerExternalAgentUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `TickerExternalAgent`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByTickerExternalAgentUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `TickerExternalAgent`. */
export type BlockBlocksByTickerExternalAgentUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TickerExternalAgent`. */
export type BlockBlocksByTickerExternalAgentUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByTickerExternalAgentUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TickerExternalAgent`. */
  tickerExternalAgentsByCreatedBlockId: TickerExternalAgentsConnection;
};

/** A `Block` edge in the connection, with data from `TickerExternalAgent`. */
export type BlockBlocksByTickerExternalAgentUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeTickerExternalAgentsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TickerExternalAgentsOrderBy>>;
    filter?: Maybe<TickerExternalAgentFilter>;
  };

/** A connection to a list of `Block` values, with data from `TransferCompliance`. */
export type BlockBlocksByTransferComplianceCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByTransferComplianceCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByTransferComplianceCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `TransferCompliance`. */
export type BlockBlocksByTransferComplianceCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TransferCompliance`. */
export type BlockBlocksByTransferComplianceCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByTransferComplianceCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliancesByUpdatedBlockId: TransferCompliancesConnection;
};

/** A `Block` edge in the connection, with data from `TransferCompliance`. */
export type BlockBlocksByTransferComplianceCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeTransferCompliancesByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TransferCompliancesOrderBy>>;
    filter?: Maybe<TransferComplianceFilter>;
  };

/** A connection to a list of `Block` values, with data from `TransferComplianceExemption`. */
export type BlockBlocksByTransferComplianceExemptionCreatedBlockIdAndUpdatedBlockIdManyToManyConnection =
  {
    __typename?: 'BlockBlocksByTransferComplianceExemptionCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
    /** A list of `Block` objects. */
    nodes: Array<Maybe<Block>>;
    /** A list of edges which contains the `Block`, info from the `TransferComplianceExemption`, and the cursor to aid in pagination. */
    edges: Array<BlockBlocksByTransferComplianceExemptionCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Block` you could get from the connection. */
    totalCount: Scalars['Int'];
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<BlockAggregates>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<BlockAggregates>>;
  };

/** A connection to a list of `Block` values, with data from `TransferComplianceExemption`. */
export type BlockBlocksByTransferComplianceExemptionCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TransferComplianceExemption`. */
export type BlockBlocksByTransferComplianceExemptionCreatedBlockIdAndUpdatedBlockIdManyToManyEdge =
  {
    __typename?: 'BlockBlocksByTransferComplianceExemptionCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']>;
    /** The `Block` at the end of the edge. */
    node?: Maybe<Block>;
    /** Reads and enables pagination through a set of `TransferComplianceExemption`. */
    transferComplianceExemptionsByUpdatedBlockId: TransferComplianceExemptionsConnection;
  };

/** A `Block` edge in the connection, with data from `TransferComplianceExemption`. */
export type BlockBlocksByTransferComplianceExemptionCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeTransferComplianceExemptionsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TransferComplianceExemptionsOrderBy>>;
    filter?: Maybe<TransferComplianceExemptionFilter>;
  };

/** A connection to a list of `Block` values, with data from `TransferComplianceExemption`. */
export type BlockBlocksByTransferComplianceExemptionUpdatedBlockIdAndCreatedBlockIdManyToManyConnection =
  {
    __typename?: 'BlockBlocksByTransferComplianceExemptionUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
    /** A list of `Block` objects. */
    nodes: Array<Maybe<Block>>;
    /** A list of edges which contains the `Block`, info from the `TransferComplianceExemption`, and the cursor to aid in pagination. */
    edges: Array<BlockBlocksByTransferComplianceExemptionUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Block` you could get from the connection. */
    totalCount: Scalars['Int'];
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<BlockAggregates>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<BlockAggregates>>;
  };

/** A connection to a list of `Block` values, with data from `TransferComplianceExemption`. */
export type BlockBlocksByTransferComplianceExemptionUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TransferComplianceExemption`. */
export type BlockBlocksByTransferComplianceExemptionUpdatedBlockIdAndCreatedBlockIdManyToManyEdge =
  {
    __typename?: 'BlockBlocksByTransferComplianceExemptionUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
    /** A cursor for use in pagination. */
    cursor?: Maybe<Scalars['Cursor']>;
    /** The `Block` at the end of the edge. */
    node?: Maybe<Block>;
    /** Reads and enables pagination through a set of `TransferComplianceExemption`. */
    transferComplianceExemptionsByCreatedBlockId: TransferComplianceExemptionsConnection;
  };

/** A `Block` edge in the connection, with data from `TransferComplianceExemption`. */
export type BlockBlocksByTransferComplianceExemptionUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeTransferComplianceExemptionsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TransferComplianceExemptionsOrderBy>>;
    filter?: Maybe<TransferComplianceExemptionFilter>;
  };

/** A connection to a list of `Block` values, with data from `TransferCompliance`. */
export type BlockBlocksByTransferComplianceUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByTransferComplianceUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByTransferComplianceUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `TransferCompliance`. */
export type BlockBlocksByTransferComplianceUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TransferCompliance`. */
export type BlockBlocksByTransferComplianceUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByTransferComplianceUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliancesByCreatedBlockId: TransferCompliancesConnection;
};

/** A `Block` edge in the connection, with data from `TransferCompliance`. */
export type BlockBlocksByTransferComplianceUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeTransferCompliancesByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TransferCompliancesOrderBy>>;
    filter?: Maybe<TransferComplianceFilter>;
  };

/** A connection to a list of `Block` values, with data from `TransferManager`. */
export type BlockBlocksByTransferManagerCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByTransferManagerCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `TransferManager`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByTransferManagerCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `TransferManager`. */
export type BlockBlocksByTransferManagerCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TransferManager`. */
export type BlockBlocksByTransferManagerCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByTransferManagerCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TransferManager`. */
  transferManagersByUpdatedBlockId: TransferManagersConnection;
};

/** A `Block` edge in the connection, with data from `TransferManager`. */
export type BlockBlocksByTransferManagerCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeTransferManagersByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TransferManagersOrderBy>>;
    filter?: Maybe<TransferManagerFilter>;
  };

/** A connection to a list of `Block` values, with data from `TransferManager`. */
export type BlockBlocksByTransferManagerUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByTransferManagerUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `TransferManager`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByTransferManagerUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `TransferManager`. */
export type BlockBlocksByTransferManagerUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TransferManager`. */
export type BlockBlocksByTransferManagerUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByTransferManagerUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TransferManager`. */
  transferManagersByCreatedBlockId: TransferManagersConnection;
};

/** A `Block` edge in the connection, with data from `TransferManager`. */
export type BlockBlocksByTransferManagerUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeTransferManagersByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TransferManagersOrderBy>>;
    filter?: Maybe<TransferManagerFilter>;
  };

/** A connection to a list of `Block` values, with data from `TrustedClaimIssuer`. */
export type BlockBlocksByTrustedClaimIssuerCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByTrustedClaimIssuerCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `TrustedClaimIssuer`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByTrustedClaimIssuerCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `TrustedClaimIssuer`. */
export type BlockBlocksByTrustedClaimIssuerCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TrustedClaimIssuer`. */
export type BlockBlocksByTrustedClaimIssuerCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByTrustedClaimIssuerCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TrustedClaimIssuer`. */
  trustedClaimIssuersByUpdatedBlockId: TrustedClaimIssuersConnection;
};

/** A `Block` edge in the connection, with data from `TrustedClaimIssuer`. */
export type BlockBlocksByTrustedClaimIssuerCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeTrustedClaimIssuersByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TrustedClaimIssuersOrderBy>>;
    filter?: Maybe<TrustedClaimIssuerFilter>;
  };

/** A connection to a list of `Block` values, with data from `TrustedClaimIssuer`. */
export type BlockBlocksByTrustedClaimIssuerUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByTrustedClaimIssuerUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `TrustedClaimIssuer`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByTrustedClaimIssuerUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `TrustedClaimIssuer`. */
export type BlockBlocksByTrustedClaimIssuerUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TrustedClaimIssuer`. */
export type BlockBlocksByTrustedClaimIssuerUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByTrustedClaimIssuerUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TrustedClaimIssuer`. */
  trustedClaimIssuersByCreatedBlockId: TrustedClaimIssuersConnection;
};

/** A `Block` edge in the connection, with data from `TrustedClaimIssuer`. */
export type BlockBlocksByTrustedClaimIssuerUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeTrustedClaimIssuersByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TrustedClaimIssuersOrderBy>>;
    filter?: Maybe<TrustedClaimIssuerFilter>;
  };

/** A connection to a list of `Block` values, with data from `Venue`. */
export type BlockBlocksByVenueCreatedBlockIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByVenueCreatedBlockIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Venue`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByVenueCreatedBlockIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Venue`. */
export type BlockBlocksByVenueCreatedBlockIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Venue`. */
export type BlockBlocksByVenueCreatedBlockIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByVenueCreatedBlockIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Venue`. */
  venuesByUpdatedBlockId: VenuesConnection;
};

/** A `Block` edge in the connection, with data from `Venue`. */
export type BlockBlocksByVenueCreatedBlockIdAndUpdatedBlockIdManyToManyEdgeVenuesByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<VenuesOrderBy>>;
    filter?: Maybe<VenueFilter>;
  };

/** A connection to a list of `Block` values, with data from `Venue`. */
export type BlockBlocksByVenueUpdatedBlockIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'BlockBlocksByVenueUpdatedBlockIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Venue`, and the cursor to aid in pagination. */
  edges: Array<BlockBlocksByVenueUpdatedBlockIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Venue`. */
export type BlockBlocksByVenueUpdatedBlockIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Venue`. */
export type BlockBlocksByVenueUpdatedBlockIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'BlockBlocksByVenueUpdatedBlockIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Venue`. */
  venuesByCreatedBlockId: VenuesConnection;
};

/** A `Block` edge in the connection, with data from `Venue`. */
export type BlockBlocksByVenueUpdatedBlockIdAndCreatedBlockIdManyToManyEdgeVenuesByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<VenuesOrderBy>>;
    filter?: Maybe<VenueFilter>;
  };

/** A connection to a list of `Distribution` values, with data from `DistributionPayment`. */
export type BlockDistributionsByDistributionPaymentCreatedBlockIdAndDistributionIdManyToManyConnection =
  {
    __typename?: 'BlockDistributionsByDistributionPaymentCreatedBlockIdAndDistributionIdManyToManyConnection';
    /** A list of `Distribution` objects. */
    nodes: Array<Maybe<Distribution>>;
    /** A list of edges which contains the `Distribution`, info from the `DistributionPayment`, and the cursor to aid in pagination. */
    edges: Array<BlockDistributionsByDistributionPaymentCreatedBlockIdAndDistributionIdManyToManyEdge>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Distribution` you could get from the connection. */
    totalCount: Scalars['Int'];
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<DistributionAggregates>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<DistributionAggregates>>;
  };

/** A connection to a list of `Distribution` values, with data from `DistributionPayment`. */
export type BlockDistributionsByDistributionPaymentCreatedBlockIdAndDistributionIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<DistributionsGroupBy>;
    having?: Maybe<DistributionsHavingInput>;
  };

/** A `Distribution` edge in the connection, with data from `DistributionPayment`. */
export type BlockDistributionsByDistributionPaymentCreatedBlockIdAndDistributionIdManyToManyEdge = {
  __typename?: 'BlockDistributionsByDistributionPaymentCreatedBlockIdAndDistributionIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Distribution` at the end of the edge. */
  node?: Maybe<Distribution>;
  /** Reads and enables pagination through a set of `DistributionPayment`. */
  distributionPayments: DistributionPaymentsConnection;
};

/** A `Distribution` edge in the connection, with data from `DistributionPayment`. */
export type BlockDistributionsByDistributionPaymentCreatedBlockIdAndDistributionIdManyToManyEdgeDistributionPaymentsArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<DistributionPaymentsOrderBy>>;
    filter?: Maybe<DistributionPaymentFilter>;
  };

/** A connection to a list of `Distribution` values, with data from `DistributionPayment`. */
export type BlockDistributionsByDistributionPaymentUpdatedBlockIdAndDistributionIdManyToManyConnection =
  {
    __typename?: 'BlockDistributionsByDistributionPaymentUpdatedBlockIdAndDistributionIdManyToManyConnection';
    /** A list of `Distribution` objects. */
    nodes: Array<Maybe<Distribution>>;
    /** A list of edges which contains the `Distribution`, info from the `DistributionPayment`, and the cursor to aid in pagination. */
    edges: Array<BlockDistributionsByDistributionPaymentUpdatedBlockIdAndDistributionIdManyToManyEdge>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Distribution` you could get from the connection. */
    totalCount: Scalars['Int'];
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<DistributionAggregates>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<DistributionAggregates>>;
  };

/** A connection to a list of `Distribution` values, with data from `DistributionPayment`. */
export type BlockDistributionsByDistributionPaymentUpdatedBlockIdAndDistributionIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<DistributionsGroupBy>;
    having?: Maybe<DistributionsHavingInput>;
  };

/** A `Distribution` edge in the connection, with data from `DistributionPayment`. */
export type BlockDistributionsByDistributionPaymentUpdatedBlockIdAndDistributionIdManyToManyEdge = {
  __typename?: 'BlockDistributionsByDistributionPaymentUpdatedBlockIdAndDistributionIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Distribution` at the end of the edge. */
  node?: Maybe<Distribution>;
  /** Reads and enables pagination through a set of `DistributionPayment`. */
  distributionPayments: DistributionPaymentsConnection;
};

/** A `Distribution` edge in the connection, with data from `DistributionPayment`. */
export type BlockDistributionsByDistributionPaymentUpdatedBlockIdAndDistributionIdManyToManyEdgeDistributionPaymentsArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<DistributionPaymentsOrderBy>>;
    filter?: Maybe<DistributionPaymentFilter>;
  };

/** A filter to be used against `Block` object types. All fields are combined with a logical ‘and.’ */
export type BlockFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `blockId` field. */
  blockId?: Maybe<IntFilter>;
  /** Filter by the object’s `parentId` field. */
  parentId?: Maybe<IntFilter>;
  /** Filter by the object’s `hash` field. */
  hash?: Maybe<StringFilter>;
  /** Filter by the object’s `parentHash` field. */
  parentHash?: Maybe<StringFilter>;
  /** Filter by the object’s `stateRoot` field. */
  stateRoot?: Maybe<StringFilter>;
  /** Filter by the object’s `extrinsicsRoot` field. */
  extrinsicsRoot?: Maybe<StringFilter>;
  /** Filter by the object’s `countExtrinsics` field. */
  countExtrinsics?: Maybe<IntFilter>;
  /** Filter by the object’s `countExtrinsicsUnsigned` field. */
  countExtrinsicsUnsigned?: Maybe<IntFilter>;
  /** Filter by the object’s `countExtrinsicsSigned` field. */
  countExtrinsicsSigned?: Maybe<IntFilter>;
  /** Filter by the object’s `countExtrinsicsError` field. */
  countExtrinsicsError?: Maybe<IntFilter>;
  /** Filter by the object’s `countExtrinsicsSuccess` field. */
  countExtrinsicsSuccess?: Maybe<IntFilter>;
  /** Filter by the object’s `countEvents` field. */
  countEvents?: Maybe<IntFilter>;
  /** Filter by the object’s `datetime` field. */
  datetime?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `specVersionId` field. */
  specVersionId?: Maybe<IntFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<BlockFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<BlockFilter>>;
  /** Negates the expression. */
  not?: Maybe<BlockFilter>;
};

/** A connection to a list of `Identity` values, with data from `Account`. */
export type BlockIdentitiesByAccountCreatedBlockIdAndIdentityIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByAccountCreatedBlockIdAndIdentityIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `Account`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByAccountCreatedBlockIdAndIdentityIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `Account`. */
export type BlockIdentitiesByAccountCreatedBlockIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Account`. */
export type BlockIdentitiesByAccountCreatedBlockIdAndIdentityIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByAccountCreatedBlockIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Account`. */
  secondaryAccounts: AccountsConnection;
};

/** A `Identity` edge in the connection, with data from `Account`. */
export type BlockIdentitiesByAccountCreatedBlockIdAndIdentityIdManyToManyEdgeSecondaryAccountsArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AccountsOrderBy>>;
    filter?: Maybe<AccountFilter>;
  };

/** A connection to a list of `Identity` values, with data from `Account`. */
export type BlockIdentitiesByAccountUpdatedBlockIdAndIdentityIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByAccountUpdatedBlockIdAndIdentityIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `Account`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByAccountUpdatedBlockIdAndIdentityIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `Account`. */
export type BlockIdentitiesByAccountUpdatedBlockIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Account`. */
export type BlockIdentitiesByAccountUpdatedBlockIdAndIdentityIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByAccountUpdatedBlockIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Account`. */
  secondaryAccounts: AccountsConnection;
};

/** A `Identity` edge in the connection, with data from `Account`. */
export type BlockIdentitiesByAccountUpdatedBlockIdAndIdentityIdManyToManyEdgeSecondaryAccountsArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AccountsOrderBy>>;
    filter?: Maybe<AccountFilter>;
  };

/** A connection to a list of `Identity` values, with data from `Asset`. */
export type BlockIdentitiesByAssetCreatedBlockIdAndOwnerIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByAssetCreatedBlockIdAndOwnerIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `Asset`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByAssetCreatedBlockIdAndOwnerIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `Asset`. */
export type BlockIdentitiesByAssetCreatedBlockIdAndOwnerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Asset`. */
export type BlockIdentitiesByAssetCreatedBlockIdAndOwnerIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByAssetCreatedBlockIdAndOwnerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByOwnerId: AssetsConnection;
};

/** A `Identity` edge in the connection, with data from `Asset`. */
export type BlockIdentitiesByAssetCreatedBlockIdAndOwnerIdManyToManyEdgeAssetsByOwnerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

/** A connection to a list of `Identity` values, with data from `AssetHolder`. */
export type BlockIdentitiesByAssetHolderCreatedBlockIdAndIdentityIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByAssetHolderCreatedBlockIdAndIdentityIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `AssetHolder`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByAssetHolderCreatedBlockIdAndIdentityIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `AssetHolder`. */
export type BlockIdentitiesByAssetHolderCreatedBlockIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `AssetHolder`. */
export type BlockIdentitiesByAssetHolderCreatedBlockIdAndIdentityIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByAssetHolderCreatedBlockIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `AssetHolder`. */
  heldAssets: AssetHoldersConnection;
};

/** A `Identity` edge in the connection, with data from `AssetHolder`. */
export type BlockIdentitiesByAssetHolderCreatedBlockIdAndIdentityIdManyToManyEdgeHeldAssetsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetHoldersOrderBy>>;
  filter?: Maybe<AssetHolderFilter>;
};

/** A connection to a list of `Identity` values, with data from `AssetHolder`. */
export type BlockIdentitiesByAssetHolderUpdatedBlockIdAndIdentityIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByAssetHolderUpdatedBlockIdAndIdentityIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `AssetHolder`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByAssetHolderUpdatedBlockIdAndIdentityIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `AssetHolder`. */
export type BlockIdentitiesByAssetHolderUpdatedBlockIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `AssetHolder`. */
export type BlockIdentitiesByAssetHolderUpdatedBlockIdAndIdentityIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByAssetHolderUpdatedBlockIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `AssetHolder`. */
  heldAssets: AssetHoldersConnection;
};

/** A `Identity` edge in the connection, with data from `AssetHolder`. */
export type BlockIdentitiesByAssetHolderUpdatedBlockIdAndIdentityIdManyToManyEdgeHeldAssetsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetHoldersOrderBy>>;
  filter?: Maybe<AssetHolderFilter>;
};

/** A connection to a list of `Identity` values, with data from `Asset`. */
export type BlockIdentitiesByAssetUpdatedBlockIdAndOwnerIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByAssetUpdatedBlockIdAndOwnerIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `Asset`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByAssetUpdatedBlockIdAndOwnerIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `Asset`. */
export type BlockIdentitiesByAssetUpdatedBlockIdAndOwnerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Asset`. */
export type BlockIdentitiesByAssetUpdatedBlockIdAndOwnerIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByAssetUpdatedBlockIdAndOwnerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByOwnerId: AssetsConnection;
};

/** A `Identity` edge in the connection, with data from `Asset`. */
export type BlockIdentitiesByAssetUpdatedBlockIdAndOwnerIdManyToManyEdgeAssetsByOwnerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

/** A connection to a list of `Identity` values, with data from `Authorization`. */
export type BlockIdentitiesByAuthorizationCreatedBlockIdAndFromIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByAuthorizationCreatedBlockIdAndFromIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `Authorization`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByAuthorizationCreatedBlockIdAndFromIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `Authorization`. */
export type BlockIdentitiesByAuthorizationCreatedBlockIdAndFromIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Authorization`. */
export type BlockIdentitiesByAuthorizationCreatedBlockIdAndFromIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByAuthorizationCreatedBlockIdAndFromIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Authorization`. */
  authorizationsByFromId: AuthorizationsConnection;
};

/** A `Identity` edge in the connection, with data from `Authorization`. */
export type BlockIdentitiesByAuthorizationCreatedBlockIdAndFromIdManyToManyEdgeAuthorizationsByFromIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AuthorizationsOrderBy>>;
    filter?: Maybe<AuthorizationFilter>;
  };

/** A connection to a list of `Identity` values, with data from `Authorization`. */
export type BlockIdentitiesByAuthorizationCreatedBlockIdAndToIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByAuthorizationCreatedBlockIdAndToIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `Authorization`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByAuthorizationCreatedBlockIdAndToIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `Authorization`. */
export type BlockIdentitiesByAuthorizationCreatedBlockIdAndToIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Authorization`. */
export type BlockIdentitiesByAuthorizationCreatedBlockIdAndToIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByAuthorizationCreatedBlockIdAndToIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Authorization`. */
  authorizationsByToId: AuthorizationsConnection;
};

/** A `Identity` edge in the connection, with data from `Authorization`. */
export type BlockIdentitiesByAuthorizationCreatedBlockIdAndToIdManyToManyEdgeAuthorizationsByToIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AuthorizationsOrderBy>>;
    filter?: Maybe<AuthorizationFilter>;
  };

/** A connection to a list of `Identity` values, with data from `Authorization`. */
export type BlockIdentitiesByAuthorizationUpdatedBlockIdAndFromIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByAuthorizationUpdatedBlockIdAndFromIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `Authorization`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByAuthorizationUpdatedBlockIdAndFromIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `Authorization`. */
export type BlockIdentitiesByAuthorizationUpdatedBlockIdAndFromIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Authorization`. */
export type BlockIdentitiesByAuthorizationUpdatedBlockIdAndFromIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByAuthorizationUpdatedBlockIdAndFromIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Authorization`. */
  authorizationsByFromId: AuthorizationsConnection;
};

/** A `Identity` edge in the connection, with data from `Authorization`. */
export type BlockIdentitiesByAuthorizationUpdatedBlockIdAndFromIdManyToManyEdgeAuthorizationsByFromIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AuthorizationsOrderBy>>;
    filter?: Maybe<AuthorizationFilter>;
  };

/** A connection to a list of `Identity` values, with data from `Authorization`. */
export type BlockIdentitiesByAuthorizationUpdatedBlockIdAndToIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByAuthorizationUpdatedBlockIdAndToIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `Authorization`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByAuthorizationUpdatedBlockIdAndToIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `Authorization`. */
export type BlockIdentitiesByAuthorizationUpdatedBlockIdAndToIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Authorization`. */
export type BlockIdentitiesByAuthorizationUpdatedBlockIdAndToIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByAuthorizationUpdatedBlockIdAndToIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Authorization`. */
  authorizationsByToId: AuthorizationsConnection;
};

/** A `Identity` edge in the connection, with data from `Authorization`. */
export type BlockIdentitiesByAuthorizationUpdatedBlockIdAndToIdManyToManyEdgeAuthorizationsByToIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AuthorizationsOrderBy>>;
    filter?: Maybe<AuthorizationFilter>;
  };

/** A connection to a list of `Identity` values, with data from `BridgeEvent`. */
export type BlockIdentitiesByBridgeEventCreatedBlockIdAndIdentityIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByBridgeEventCreatedBlockIdAndIdentityIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `BridgeEvent`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByBridgeEventCreatedBlockIdAndIdentityIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `BridgeEvent`. */
export type BlockIdentitiesByBridgeEventCreatedBlockIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `BridgeEvent`. */
export type BlockIdentitiesByBridgeEventCreatedBlockIdAndIdentityIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByBridgeEventCreatedBlockIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `BridgeEvent`. */
  bridgeEvents: BridgeEventsConnection;
};

/** A `Identity` edge in the connection, with data from `BridgeEvent`. */
export type BlockIdentitiesByBridgeEventCreatedBlockIdAndIdentityIdManyToManyEdgeBridgeEventsArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<BridgeEventsOrderBy>>;
    filter?: Maybe<BridgeEventFilter>;
  };

/** A connection to a list of `Identity` values, with data from `BridgeEvent`. */
export type BlockIdentitiesByBridgeEventUpdatedBlockIdAndIdentityIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByBridgeEventUpdatedBlockIdAndIdentityIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `BridgeEvent`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByBridgeEventUpdatedBlockIdAndIdentityIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `BridgeEvent`. */
export type BlockIdentitiesByBridgeEventUpdatedBlockIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `BridgeEvent`. */
export type BlockIdentitiesByBridgeEventUpdatedBlockIdAndIdentityIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByBridgeEventUpdatedBlockIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `BridgeEvent`. */
  bridgeEvents: BridgeEventsConnection;
};

/** A `Identity` edge in the connection, with data from `BridgeEvent`. */
export type BlockIdentitiesByBridgeEventUpdatedBlockIdAndIdentityIdManyToManyEdgeBridgeEventsArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<BridgeEventsOrderBy>>;
    filter?: Maybe<BridgeEventFilter>;
  };

/** A connection to a list of `Identity` values, with data from `Claim`. */
export type BlockIdentitiesByClaimCreatedBlockIdAndIssuerIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByClaimCreatedBlockIdAndIssuerIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `Claim`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByClaimCreatedBlockIdAndIssuerIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `Claim`. */
export type BlockIdentitiesByClaimCreatedBlockIdAndIssuerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Claim`. */
export type BlockIdentitiesByClaimCreatedBlockIdAndIssuerIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByClaimCreatedBlockIdAndIssuerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Claim`. */
  claimsByIssuerId: ClaimsConnection;
};

/** A `Identity` edge in the connection, with data from `Claim`. */
export type BlockIdentitiesByClaimCreatedBlockIdAndIssuerIdManyToManyEdgeClaimsByIssuerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ClaimsOrderBy>>;
  filter?: Maybe<ClaimFilter>;
};

/** A connection to a list of `Identity` values, with data from `Claim`. */
export type BlockIdentitiesByClaimCreatedBlockIdAndTargetIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByClaimCreatedBlockIdAndTargetIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `Claim`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByClaimCreatedBlockIdAndTargetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `Claim`. */
export type BlockIdentitiesByClaimCreatedBlockIdAndTargetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Claim`. */
export type BlockIdentitiesByClaimCreatedBlockIdAndTargetIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByClaimCreatedBlockIdAndTargetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Claim`. */
  claimsByTargetId: ClaimsConnection;
};

/** A `Identity` edge in the connection, with data from `Claim`. */
export type BlockIdentitiesByClaimCreatedBlockIdAndTargetIdManyToManyEdgeClaimsByTargetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ClaimsOrderBy>>;
  filter?: Maybe<ClaimFilter>;
};

/** A connection to a list of `Identity` values, with data from `Claim`. */
export type BlockIdentitiesByClaimUpdatedBlockIdAndIssuerIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByClaimUpdatedBlockIdAndIssuerIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `Claim`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByClaimUpdatedBlockIdAndIssuerIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `Claim`. */
export type BlockIdentitiesByClaimUpdatedBlockIdAndIssuerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Claim`. */
export type BlockIdentitiesByClaimUpdatedBlockIdAndIssuerIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByClaimUpdatedBlockIdAndIssuerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Claim`. */
  claimsByIssuerId: ClaimsConnection;
};

/** A `Identity` edge in the connection, with data from `Claim`. */
export type BlockIdentitiesByClaimUpdatedBlockIdAndIssuerIdManyToManyEdgeClaimsByIssuerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ClaimsOrderBy>>;
  filter?: Maybe<ClaimFilter>;
};

/** A connection to a list of `Identity` values, with data from `Claim`. */
export type BlockIdentitiesByClaimUpdatedBlockIdAndTargetIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByClaimUpdatedBlockIdAndTargetIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `Claim`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByClaimUpdatedBlockIdAndTargetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `Claim`. */
export type BlockIdentitiesByClaimUpdatedBlockIdAndTargetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Claim`. */
export type BlockIdentitiesByClaimUpdatedBlockIdAndTargetIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByClaimUpdatedBlockIdAndTargetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Claim`. */
  claimsByTargetId: ClaimsConnection;
};

/** A `Identity` edge in the connection, with data from `Claim`. */
export type BlockIdentitiesByClaimUpdatedBlockIdAndTargetIdManyToManyEdgeClaimsByTargetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ClaimsOrderBy>>;
  filter?: Maybe<ClaimFilter>;
};

/** A connection to a list of `Identity` values, with data from `Distribution`. */
export type BlockIdentitiesByDistributionCreatedBlockIdAndIdentityIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByDistributionCreatedBlockIdAndIdentityIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByDistributionCreatedBlockIdAndIdentityIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `Distribution`. */
export type BlockIdentitiesByDistributionCreatedBlockIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Distribution`. */
export type BlockIdentitiesByDistributionCreatedBlockIdAndIdentityIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByDistributionCreatedBlockIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributions: DistributionsConnection;
};

/** A `Identity` edge in the connection, with data from `Distribution`. */
export type BlockIdentitiesByDistributionCreatedBlockIdAndIdentityIdManyToManyEdgeDistributionsArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<DistributionsOrderBy>>;
    filter?: Maybe<DistributionFilter>;
  };

/** A connection to a list of `Identity` values, with data from `DistributionPayment`. */
export type BlockIdentitiesByDistributionPaymentCreatedBlockIdAndTargetIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByDistributionPaymentCreatedBlockIdAndTargetIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `DistributionPayment`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByDistributionPaymentCreatedBlockIdAndTargetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `DistributionPayment`. */
export type BlockIdentitiesByDistributionPaymentCreatedBlockIdAndTargetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `DistributionPayment`. */
export type BlockIdentitiesByDistributionPaymentCreatedBlockIdAndTargetIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByDistributionPaymentCreatedBlockIdAndTargetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `DistributionPayment`. */
  distributionPaymentsByTargetId: DistributionPaymentsConnection;
};

/** A `Identity` edge in the connection, with data from `DistributionPayment`. */
export type BlockIdentitiesByDistributionPaymentCreatedBlockIdAndTargetIdManyToManyEdgeDistributionPaymentsByTargetIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<DistributionPaymentsOrderBy>>;
    filter?: Maybe<DistributionPaymentFilter>;
  };

/** A connection to a list of `Identity` values, with data from `DistributionPayment`. */
export type BlockIdentitiesByDistributionPaymentUpdatedBlockIdAndTargetIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByDistributionPaymentUpdatedBlockIdAndTargetIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `DistributionPayment`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByDistributionPaymentUpdatedBlockIdAndTargetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `DistributionPayment`. */
export type BlockIdentitiesByDistributionPaymentUpdatedBlockIdAndTargetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `DistributionPayment`. */
export type BlockIdentitiesByDistributionPaymentUpdatedBlockIdAndTargetIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByDistributionPaymentUpdatedBlockIdAndTargetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `DistributionPayment`. */
  distributionPaymentsByTargetId: DistributionPaymentsConnection;
};

/** A `Identity` edge in the connection, with data from `DistributionPayment`. */
export type BlockIdentitiesByDistributionPaymentUpdatedBlockIdAndTargetIdManyToManyEdgeDistributionPaymentsByTargetIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<DistributionPaymentsOrderBy>>;
    filter?: Maybe<DistributionPaymentFilter>;
  };

/** A connection to a list of `Identity` values, with data from `Distribution`. */
export type BlockIdentitiesByDistributionUpdatedBlockIdAndIdentityIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByDistributionUpdatedBlockIdAndIdentityIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByDistributionUpdatedBlockIdAndIdentityIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `Distribution`. */
export type BlockIdentitiesByDistributionUpdatedBlockIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Distribution`. */
export type BlockIdentitiesByDistributionUpdatedBlockIdAndIdentityIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByDistributionUpdatedBlockIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributions: DistributionsConnection;
};

/** A `Identity` edge in the connection, with data from `Distribution`. */
export type BlockIdentitiesByDistributionUpdatedBlockIdAndIdentityIdManyToManyEdgeDistributionsArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<DistributionsOrderBy>>;
    filter?: Maybe<DistributionFilter>;
  };

/** A connection to a list of `Identity` values, with data from `Investment`. */
export type BlockIdentitiesByInvestmentCreatedBlockIdAndInvestorIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByInvestmentCreatedBlockIdAndInvestorIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `Investment`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByInvestmentCreatedBlockIdAndInvestorIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `Investment`. */
export type BlockIdentitiesByInvestmentCreatedBlockIdAndInvestorIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Investment`. */
export type BlockIdentitiesByInvestmentCreatedBlockIdAndInvestorIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByInvestmentCreatedBlockIdAndInvestorIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Investment`. */
  investmentsByInvestorId: InvestmentsConnection;
};

/** A `Identity` edge in the connection, with data from `Investment`. */
export type BlockIdentitiesByInvestmentCreatedBlockIdAndInvestorIdManyToManyEdgeInvestmentsByInvestorIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<InvestmentsOrderBy>>;
    filter?: Maybe<InvestmentFilter>;
  };

/** A connection to a list of `Identity` values, with data from `Investment`. */
export type BlockIdentitiesByInvestmentUpdatedBlockIdAndInvestorIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByInvestmentUpdatedBlockIdAndInvestorIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `Investment`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByInvestmentUpdatedBlockIdAndInvestorIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `Investment`. */
export type BlockIdentitiesByInvestmentUpdatedBlockIdAndInvestorIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Investment`. */
export type BlockIdentitiesByInvestmentUpdatedBlockIdAndInvestorIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByInvestmentUpdatedBlockIdAndInvestorIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Investment`. */
  investmentsByInvestorId: InvestmentsConnection;
};

/** A `Identity` edge in the connection, with data from `Investment`. */
export type BlockIdentitiesByInvestmentUpdatedBlockIdAndInvestorIdManyToManyEdgeInvestmentsByInvestorIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<InvestmentsOrderBy>>;
    filter?: Maybe<InvestmentFilter>;
  };

/** A connection to a list of `Identity` values, with data from `Portfolio`. */
export type BlockIdentitiesByPortfolioCreatedBlockIdAndCustodianIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByPortfolioCreatedBlockIdAndCustodianIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `Portfolio`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByPortfolioCreatedBlockIdAndCustodianIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `Portfolio`. */
export type BlockIdentitiesByPortfolioCreatedBlockIdAndCustodianIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Portfolio`. */
export type BlockIdentitiesByPortfolioCreatedBlockIdAndCustodianIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByPortfolioCreatedBlockIdAndCustodianIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByCustodianId: PortfoliosConnection;
};

/** A `Identity` edge in the connection, with data from `Portfolio`. */
export type BlockIdentitiesByPortfolioCreatedBlockIdAndCustodianIdManyToManyEdgePortfoliosByCustodianIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<PortfoliosOrderBy>>;
    filter?: Maybe<PortfolioFilter>;
  };

/** A connection to a list of `Identity` values, with data from `Portfolio`. */
export type BlockIdentitiesByPortfolioCreatedBlockIdAndIdentityIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByPortfolioCreatedBlockIdAndIdentityIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `Portfolio`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByPortfolioCreatedBlockIdAndIdentityIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `Portfolio`. */
export type BlockIdentitiesByPortfolioCreatedBlockIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Portfolio`. */
export type BlockIdentitiesByPortfolioCreatedBlockIdAndIdentityIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByPortfolioCreatedBlockIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfolios: PortfoliosConnection;
};

/** A `Identity` edge in the connection, with data from `Portfolio`. */
export type BlockIdentitiesByPortfolioCreatedBlockIdAndIdentityIdManyToManyEdgePortfoliosArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PortfoliosOrderBy>>;
  filter?: Maybe<PortfolioFilter>;
};

/** A connection to a list of `Identity` values, with data from `Portfolio`. */
export type BlockIdentitiesByPortfolioUpdatedBlockIdAndCustodianIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByPortfolioUpdatedBlockIdAndCustodianIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `Portfolio`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByPortfolioUpdatedBlockIdAndCustodianIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `Portfolio`. */
export type BlockIdentitiesByPortfolioUpdatedBlockIdAndCustodianIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Portfolio`. */
export type BlockIdentitiesByPortfolioUpdatedBlockIdAndCustodianIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByPortfolioUpdatedBlockIdAndCustodianIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByCustodianId: PortfoliosConnection;
};

/** A `Identity` edge in the connection, with data from `Portfolio`. */
export type BlockIdentitiesByPortfolioUpdatedBlockIdAndCustodianIdManyToManyEdgePortfoliosByCustodianIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<PortfoliosOrderBy>>;
    filter?: Maybe<PortfolioFilter>;
  };

/** A connection to a list of `Identity` values, with data from `Portfolio`. */
export type BlockIdentitiesByPortfolioUpdatedBlockIdAndIdentityIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByPortfolioUpdatedBlockIdAndIdentityIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `Portfolio`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByPortfolioUpdatedBlockIdAndIdentityIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `Portfolio`. */
export type BlockIdentitiesByPortfolioUpdatedBlockIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Portfolio`. */
export type BlockIdentitiesByPortfolioUpdatedBlockIdAndIdentityIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByPortfolioUpdatedBlockIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfolios: PortfoliosConnection;
};

/** A `Identity` edge in the connection, with data from `Portfolio`. */
export type BlockIdentitiesByPortfolioUpdatedBlockIdAndIdentityIdManyToManyEdgePortfoliosArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PortfoliosOrderBy>>;
  filter?: Maybe<PortfolioFilter>;
};

/** A connection to a list of `Identity` values, with data from `Proposal`. */
export type BlockIdentitiesByProposalCreatedBlockIdAndOwnerIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByProposalCreatedBlockIdAndOwnerIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `Proposal`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByProposalCreatedBlockIdAndOwnerIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `Proposal`. */
export type BlockIdentitiesByProposalCreatedBlockIdAndOwnerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Proposal`. */
export type BlockIdentitiesByProposalCreatedBlockIdAndOwnerIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByProposalCreatedBlockIdAndOwnerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Proposal`. */
  proposalsByOwnerId: ProposalsConnection;
};

/** A `Identity` edge in the connection, with data from `Proposal`. */
export type BlockIdentitiesByProposalCreatedBlockIdAndOwnerIdManyToManyEdgeProposalsByOwnerIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<ProposalsOrderBy>>;
    filter?: Maybe<ProposalFilter>;
  };

/** A connection to a list of `Identity` values, with data from `Proposal`. */
export type BlockIdentitiesByProposalUpdatedBlockIdAndOwnerIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByProposalUpdatedBlockIdAndOwnerIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `Proposal`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByProposalUpdatedBlockIdAndOwnerIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `Proposal`. */
export type BlockIdentitiesByProposalUpdatedBlockIdAndOwnerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Proposal`. */
export type BlockIdentitiesByProposalUpdatedBlockIdAndOwnerIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByProposalUpdatedBlockIdAndOwnerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Proposal`. */
  proposalsByOwnerId: ProposalsConnection;
};

/** A `Identity` edge in the connection, with data from `Proposal`. */
export type BlockIdentitiesByProposalUpdatedBlockIdAndOwnerIdManyToManyEdgeProposalsByOwnerIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<ProposalsOrderBy>>;
    filter?: Maybe<ProposalFilter>;
  };

/** A connection to a list of `Identity` values, with data from `StakingEvent`. */
export type BlockIdentitiesByStakingEventCreatedBlockIdAndIdentityIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByStakingEventCreatedBlockIdAndIdentityIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `StakingEvent`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByStakingEventCreatedBlockIdAndIdentityIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `StakingEvent`. */
export type BlockIdentitiesByStakingEventCreatedBlockIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `StakingEvent`. */
export type BlockIdentitiesByStakingEventCreatedBlockIdAndIdentityIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByStakingEventCreatedBlockIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `StakingEvent`. */
  stakingEvents: StakingEventsConnection;
};

/** A `Identity` edge in the connection, with data from `StakingEvent`. */
export type BlockIdentitiesByStakingEventCreatedBlockIdAndIdentityIdManyToManyEdgeStakingEventsArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<StakingEventsOrderBy>>;
    filter?: Maybe<StakingEventFilter>;
  };

/** A connection to a list of `Identity` values, with data from `StakingEvent`. */
export type BlockIdentitiesByStakingEventUpdatedBlockIdAndIdentityIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByStakingEventUpdatedBlockIdAndIdentityIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `StakingEvent`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByStakingEventUpdatedBlockIdAndIdentityIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `StakingEvent`. */
export type BlockIdentitiesByStakingEventUpdatedBlockIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `StakingEvent`. */
export type BlockIdentitiesByStakingEventUpdatedBlockIdAndIdentityIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByStakingEventUpdatedBlockIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `StakingEvent`. */
  stakingEvents: StakingEventsConnection;
};

/** A `Identity` edge in the connection, with data from `StakingEvent`. */
export type BlockIdentitiesByStakingEventUpdatedBlockIdAndIdentityIdManyToManyEdgeStakingEventsArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<StakingEventsOrderBy>>;
    filter?: Maybe<StakingEventFilter>;
  };

/** A connection to a list of `Identity` values, with data from `StatType`. */
export type BlockIdentitiesByStatTypeCreatedBlockIdAndClaimIssuerIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByStatTypeCreatedBlockIdAndClaimIssuerIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `StatType`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByStatTypeCreatedBlockIdAndClaimIssuerIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `StatType`. */
export type BlockIdentitiesByStatTypeCreatedBlockIdAndClaimIssuerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `StatType`. */
export type BlockIdentitiesByStatTypeCreatedBlockIdAndClaimIssuerIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByStatTypeCreatedBlockIdAndClaimIssuerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypesByClaimIssuerId: StatTypesConnection;
};

/** A `Identity` edge in the connection, with data from `StatType`. */
export type BlockIdentitiesByStatTypeCreatedBlockIdAndClaimIssuerIdManyToManyEdgeStatTypesByClaimIssuerIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<StatTypesOrderBy>>;
    filter?: Maybe<StatTypeFilter>;
  };

/** A connection to a list of `Identity` values, with data from `StatType`. */
export type BlockIdentitiesByStatTypeUpdatedBlockIdAndClaimIssuerIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByStatTypeUpdatedBlockIdAndClaimIssuerIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `StatType`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByStatTypeUpdatedBlockIdAndClaimIssuerIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `StatType`. */
export type BlockIdentitiesByStatTypeUpdatedBlockIdAndClaimIssuerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `StatType`. */
export type BlockIdentitiesByStatTypeUpdatedBlockIdAndClaimIssuerIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByStatTypeUpdatedBlockIdAndClaimIssuerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypesByClaimIssuerId: StatTypesConnection;
};

/** A `Identity` edge in the connection, with data from `StatType`. */
export type BlockIdentitiesByStatTypeUpdatedBlockIdAndClaimIssuerIdManyToManyEdgeStatTypesByClaimIssuerIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<StatTypesOrderBy>>;
    filter?: Maybe<StatTypeFilter>;
  };

/** A connection to a list of `Identity` values, with data from `TickerExternalAgentAction`. */
export type BlockIdentitiesByTickerExternalAgentActionCreatedBlockIdAndCallerIdManyToManyConnection =
  {
    __typename?: 'BlockIdentitiesByTickerExternalAgentActionCreatedBlockIdAndCallerIdManyToManyConnection';
    /** A list of `Identity` objects. */
    nodes: Array<Maybe<Identity>>;
    /** A list of edges which contains the `Identity`, info from the `TickerExternalAgentAction`, and the cursor to aid in pagination. */
    edges: Array<BlockIdentitiesByTickerExternalAgentActionCreatedBlockIdAndCallerIdManyToManyEdge>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Identity` you could get from the connection. */
    totalCount: Scalars['Int'];
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<IdentityAggregates>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  };

/** A connection to a list of `Identity` values, with data from `TickerExternalAgentAction`. */
export type BlockIdentitiesByTickerExternalAgentActionCreatedBlockIdAndCallerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `TickerExternalAgentAction`. */
export type BlockIdentitiesByTickerExternalAgentActionCreatedBlockIdAndCallerIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByTickerExternalAgentActionCreatedBlockIdAndCallerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `TickerExternalAgentAction`. */
  tickerExternalAgentActionsByCallerId: TickerExternalAgentActionsConnection;
};

/** A `Identity` edge in the connection, with data from `TickerExternalAgentAction`. */
export type BlockIdentitiesByTickerExternalAgentActionCreatedBlockIdAndCallerIdManyToManyEdgeTickerExternalAgentActionsByCallerIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TickerExternalAgentActionsOrderBy>>;
    filter?: Maybe<TickerExternalAgentActionFilter>;
  };

/** A connection to a list of `Identity` values, with data from `TickerExternalAgentAction`. */
export type BlockIdentitiesByTickerExternalAgentActionUpdatedBlockIdAndCallerIdManyToManyConnection =
  {
    __typename?: 'BlockIdentitiesByTickerExternalAgentActionUpdatedBlockIdAndCallerIdManyToManyConnection';
    /** A list of `Identity` objects. */
    nodes: Array<Maybe<Identity>>;
    /** A list of edges which contains the `Identity`, info from the `TickerExternalAgentAction`, and the cursor to aid in pagination. */
    edges: Array<BlockIdentitiesByTickerExternalAgentActionUpdatedBlockIdAndCallerIdManyToManyEdge>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Identity` you could get from the connection. */
    totalCount: Scalars['Int'];
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<IdentityAggregates>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  };

/** A connection to a list of `Identity` values, with data from `TickerExternalAgentAction`. */
export type BlockIdentitiesByTickerExternalAgentActionUpdatedBlockIdAndCallerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `TickerExternalAgentAction`. */
export type BlockIdentitiesByTickerExternalAgentActionUpdatedBlockIdAndCallerIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByTickerExternalAgentActionUpdatedBlockIdAndCallerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `TickerExternalAgentAction`. */
  tickerExternalAgentActionsByCallerId: TickerExternalAgentActionsConnection;
};

/** A `Identity` edge in the connection, with data from `TickerExternalAgentAction`. */
export type BlockIdentitiesByTickerExternalAgentActionUpdatedBlockIdAndCallerIdManyToManyEdgeTickerExternalAgentActionsByCallerIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TickerExternalAgentActionsOrderBy>>;
    filter?: Maybe<TickerExternalAgentActionFilter>;
  };

/** A connection to a list of `Identity` values, with data from `TickerExternalAgent`. */
export type BlockIdentitiesByTickerExternalAgentCreatedBlockIdAndCallerIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByTickerExternalAgentCreatedBlockIdAndCallerIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `TickerExternalAgent`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByTickerExternalAgentCreatedBlockIdAndCallerIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `TickerExternalAgent`. */
export type BlockIdentitiesByTickerExternalAgentCreatedBlockIdAndCallerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `TickerExternalAgent`. */
export type BlockIdentitiesByTickerExternalAgentCreatedBlockIdAndCallerIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByTickerExternalAgentCreatedBlockIdAndCallerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `TickerExternalAgent`. */
  tickerExternalAgentsByCallerId: TickerExternalAgentsConnection;
};

/** A `Identity` edge in the connection, with data from `TickerExternalAgent`. */
export type BlockIdentitiesByTickerExternalAgentCreatedBlockIdAndCallerIdManyToManyEdgeTickerExternalAgentsByCallerIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TickerExternalAgentsOrderBy>>;
    filter?: Maybe<TickerExternalAgentFilter>;
  };

/** A connection to a list of `Identity` values, with data from `TickerExternalAgentHistory`. */
export type BlockIdentitiesByTickerExternalAgentHistoryCreatedBlockIdAndIdentityIdManyToManyConnection =
  {
    __typename?: 'BlockIdentitiesByTickerExternalAgentHistoryCreatedBlockIdAndIdentityIdManyToManyConnection';
    /** A list of `Identity` objects. */
    nodes: Array<Maybe<Identity>>;
    /** A list of edges which contains the `Identity`, info from the `TickerExternalAgentHistory`, and the cursor to aid in pagination. */
    edges: Array<BlockIdentitiesByTickerExternalAgentHistoryCreatedBlockIdAndIdentityIdManyToManyEdge>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Identity` you could get from the connection. */
    totalCount: Scalars['Int'];
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<IdentityAggregates>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  };

/** A connection to a list of `Identity` values, with data from `TickerExternalAgentHistory`. */
export type BlockIdentitiesByTickerExternalAgentHistoryCreatedBlockIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type BlockIdentitiesByTickerExternalAgentHistoryCreatedBlockIdAndIdentityIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByTickerExternalAgentHistoryCreatedBlockIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `TickerExternalAgentHistory`. */
  tickerExternalAgentHistories: TickerExternalAgentHistoriesConnection;
};

/** A `Identity` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type BlockIdentitiesByTickerExternalAgentHistoryCreatedBlockIdAndIdentityIdManyToManyEdgeTickerExternalAgentHistoriesArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TickerExternalAgentHistoriesOrderBy>>;
    filter?: Maybe<TickerExternalAgentHistoryFilter>;
  };

/** A connection to a list of `Identity` values, with data from `TickerExternalAgentHistory`. */
export type BlockIdentitiesByTickerExternalAgentHistoryUpdatedBlockIdAndIdentityIdManyToManyConnection =
  {
    __typename?: 'BlockIdentitiesByTickerExternalAgentHistoryUpdatedBlockIdAndIdentityIdManyToManyConnection';
    /** A list of `Identity` objects. */
    nodes: Array<Maybe<Identity>>;
    /** A list of edges which contains the `Identity`, info from the `TickerExternalAgentHistory`, and the cursor to aid in pagination. */
    edges: Array<BlockIdentitiesByTickerExternalAgentHistoryUpdatedBlockIdAndIdentityIdManyToManyEdge>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Identity` you could get from the connection. */
    totalCount: Scalars['Int'];
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<IdentityAggregates>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  };

/** A connection to a list of `Identity` values, with data from `TickerExternalAgentHistory`. */
export type BlockIdentitiesByTickerExternalAgentHistoryUpdatedBlockIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type BlockIdentitiesByTickerExternalAgentHistoryUpdatedBlockIdAndIdentityIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByTickerExternalAgentHistoryUpdatedBlockIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `TickerExternalAgentHistory`. */
  tickerExternalAgentHistories: TickerExternalAgentHistoriesConnection;
};

/** A `Identity` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type BlockIdentitiesByTickerExternalAgentHistoryUpdatedBlockIdAndIdentityIdManyToManyEdgeTickerExternalAgentHistoriesArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TickerExternalAgentHistoriesOrderBy>>;
    filter?: Maybe<TickerExternalAgentHistoryFilter>;
  };

/** A connection to a list of `Identity` values, with data from `TickerExternalAgent`. */
export type BlockIdentitiesByTickerExternalAgentUpdatedBlockIdAndCallerIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByTickerExternalAgentUpdatedBlockIdAndCallerIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `TickerExternalAgent`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByTickerExternalAgentUpdatedBlockIdAndCallerIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `TickerExternalAgent`. */
export type BlockIdentitiesByTickerExternalAgentUpdatedBlockIdAndCallerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `TickerExternalAgent`. */
export type BlockIdentitiesByTickerExternalAgentUpdatedBlockIdAndCallerIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByTickerExternalAgentUpdatedBlockIdAndCallerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `TickerExternalAgent`. */
  tickerExternalAgentsByCallerId: TickerExternalAgentsConnection;
};

/** A `Identity` edge in the connection, with data from `TickerExternalAgent`. */
export type BlockIdentitiesByTickerExternalAgentUpdatedBlockIdAndCallerIdManyToManyEdgeTickerExternalAgentsByCallerIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TickerExternalAgentsOrderBy>>;
    filter?: Maybe<TickerExternalAgentFilter>;
  };

/** A connection to a list of `Identity` values, with data from `TransferCompliance`. */
export type BlockIdentitiesByTransferComplianceCreatedBlockIdAndClaimIssuerIdManyToManyConnection =
  {
    __typename?: 'BlockIdentitiesByTransferComplianceCreatedBlockIdAndClaimIssuerIdManyToManyConnection';
    /** A list of `Identity` objects. */
    nodes: Array<Maybe<Identity>>;
    /** A list of edges which contains the `Identity`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
    edges: Array<BlockIdentitiesByTransferComplianceCreatedBlockIdAndClaimIssuerIdManyToManyEdge>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Identity` you could get from the connection. */
    totalCount: Scalars['Int'];
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<IdentityAggregates>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  };

/** A connection to a list of `Identity` values, with data from `TransferCompliance`. */
export type BlockIdentitiesByTransferComplianceCreatedBlockIdAndClaimIssuerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `TransferCompliance`. */
export type BlockIdentitiesByTransferComplianceCreatedBlockIdAndClaimIssuerIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByTransferComplianceCreatedBlockIdAndClaimIssuerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliancesByClaimIssuerId: TransferCompliancesConnection;
};

/** A `Identity` edge in the connection, with data from `TransferCompliance`. */
export type BlockIdentitiesByTransferComplianceCreatedBlockIdAndClaimIssuerIdManyToManyEdgeTransferCompliancesByClaimIssuerIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TransferCompliancesOrderBy>>;
    filter?: Maybe<TransferComplianceFilter>;
  };

/** A connection to a list of `Identity` values, with data from `TransferCompliance`. */
export type BlockIdentitiesByTransferComplianceUpdatedBlockIdAndClaimIssuerIdManyToManyConnection =
  {
    __typename?: 'BlockIdentitiesByTransferComplianceUpdatedBlockIdAndClaimIssuerIdManyToManyConnection';
    /** A list of `Identity` objects. */
    nodes: Array<Maybe<Identity>>;
    /** A list of edges which contains the `Identity`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
    edges: Array<BlockIdentitiesByTransferComplianceUpdatedBlockIdAndClaimIssuerIdManyToManyEdge>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Identity` you could get from the connection. */
    totalCount: Scalars['Int'];
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<IdentityAggregates>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  };

/** A connection to a list of `Identity` values, with data from `TransferCompliance`. */
export type BlockIdentitiesByTransferComplianceUpdatedBlockIdAndClaimIssuerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `TransferCompliance`. */
export type BlockIdentitiesByTransferComplianceUpdatedBlockIdAndClaimIssuerIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByTransferComplianceUpdatedBlockIdAndClaimIssuerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliancesByClaimIssuerId: TransferCompliancesConnection;
};

/** A `Identity` edge in the connection, with data from `TransferCompliance`. */
export type BlockIdentitiesByTransferComplianceUpdatedBlockIdAndClaimIssuerIdManyToManyEdgeTransferCompliancesByClaimIssuerIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TransferCompliancesOrderBy>>;
    filter?: Maybe<TransferComplianceFilter>;
  };

/** A connection to a list of `Identity` values, with data from `Venue`. */
export type BlockIdentitiesByVenueCreatedBlockIdAndOwnerIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByVenueCreatedBlockIdAndOwnerIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `Venue`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByVenueCreatedBlockIdAndOwnerIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `Venue`. */
export type BlockIdentitiesByVenueCreatedBlockIdAndOwnerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Venue`. */
export type BlockIdentitiesByVenueCreatedBlockIdAndOwnerIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByVenueCreatedBlockIdAndOwnerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Venue`. */
  venuesByOwnerId: VenuesConnection;
};

/** A `Identity` edge in the connection, with data from `Venue`. */
export type BlockIdentitiesByVenueCreatedBlockIdAndOwnerIdManyToManyEdgeVenuesByOwnerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VenuesOrderBy>>;
  filter?: Maybe<VenueFilter>;
};

/** A connection to a list of `Identity` values, with data from `Venue`. */
export type BlockIdentitiesByVenueUpdatedBlockIdAndOwnerIdManyToManyConnection = {
  __typename?: 'BlockIdentitiesByVenueUpdatedBlockIdAndOwnerIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `Venue`, and the cursor to aid in pagination. */
  edges: Array<BlockIdentitiesByVenueUpdatedBlockIdAndOwnerIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `Venue`. */
export type BlockIdentitiesByVenueUpdatedBlockIdAndOwnerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Venue`. */
export type BlockIdentitiesByVenueUpdatedBlockIdAndOwnerIdManyToManyEdge = {
  __typename?: 'BlockIdentitiesByVenueUpdatedBlockIdAndOwnerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Venue`. */
  venuesByOwnerId: VenuesConnection;
};

/** A `Identity` edge in the connection, with data from `Venue`. */
export type BlockIdentitiesByVenueUpdatedBlockIdAndOwnerIdManyToManyEdgeVenuesByOwnerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VenuesOrderBy>>;
  filter?: Maybe<VenueFilter>;
};

/** A connection to a list of `Instruction` values, with data from `Leg`. */
export type BlockInstructionsByLegCreatedBlockIdAndInstructionIdManyToManyConnection = {
  __typename?: 'BlockInstructionsByLegCreatedBlockIdAndInstructionIdManyToManyConnection';
  /** A list of `Instruction` objects. */
  nodes: Array<Maybe<Instruction>>;
  /** A list of edges which contains the `Instruction`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<BlockInstructionsByLegCreatedBlockIdAndInstructionIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Instruction` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<InstructionAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<InstructionAggregates>>;
};

/** A connection to a list of `Instruction` values, with data from `Leg`. */
export type BlockInstructionsByLegCreatedBlockIdAndInstructionIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<InstructionsGroupBy>;
    having?: Maybe<InstructionsHavingInput>;
  };

/** A `Instruction` edge in the connection, with data from `Leg`. */
export type BlockInstructionsByLegCreatedBlockIdAndInstructionIdManyToManyEdge = {
  __typename?: 'BlockInstructionsByLegCreatedBlockIdAndInstructionIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Instruction` at the end of the edge. */
  node?: Maybe<Instruction>;
  /** Reads and enables pagination through a set of `Leg`. */
  legs: LegsConnection;
};

/** A `Instruction` edge in the connection, with data from `Leg`. */
export type BlockInstructionsByLegCreatedBlockIdAndInstructionIdManyToManyEdgeLegsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<LegsOrderBy>>;
  filter?: Maybe<LegFilter>;
};

/** A connection to a list of `Instruction` values, with data from `Leg`. */
export type BlockInstructionsByLegUpdatedBlockIdAndInstructionIdManyToManyConnection = {
  __typename?: 'BlockInstructionsByLegUpdatedBlockIdAndInstructionIdManyToManyConnection';
  /** A list of `Instruction` objects. */
  nodes: Array<Maybe<Instruction>>;
  /** A list of edges which contains the `Instruction`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<BlockInstructionsByLegUpdatedBlockIdAndInstructionIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Instruction` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<InstructionAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<InstructionAggregates>>;
};

/** A connection to a list of `Instruction` values, with data from `Leg`. */
export type BlockInstructionsByLegUpdatedBlockIdAndInstructionIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<InstructionsGroupBy>;
    having?: Maybe<InstructionsHavingInput>;
  };

/** A `Instruction` edge in the connection, with data from `Leg`. */
export type BlockInstructionsByLegUpdatedBlockIdAndInstructionIdManyToManyEdge = {
  __typename?: 'BlockInstructionsByLegUpdatedBlockIdAndInstructionIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Instruction` at the end of the edge. */
  node?: Maybe<Instruction>;
  /** Reads and enables pagination through a set of `Leg`. */
  legs: LegsConnection;
};

/** A `Instruction` edge in the connection, with data from `Leg`. */
export type BlockInstructionsByLegUpdatedBlockIdAndInstructionIdManyToManyEdgeLegsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<LegsOrderBy>>;
  filter?: Maybe<LegFilter>;
};

/** A connection to a list of `Permission` values, with data from `Account`. */
export type BlockPermissionsByAccountCreatedBlockIdAndPermissionsIdManyToManyConnection = {
  __typename?: 'BlockPermissionsByAccountCreatedBlockIdAndPermissionsIdManyToManyConnection';
  /** A list of `Permission` objects. */
  nodes: Array<Maybe<Permission>>;
  /** A list of edges which contains the `Permission`, info from the `Account`, and the cursor to aid in pagination. */
  edges: Array<BlockPermissionsByAccountCreatedBlockIdAndPermissionsIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Permission` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PermissionAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PermissionAggregates>>;
};

/** A connection to a list of `Permission` values, with data from `Account`. */
export type BlockPermissionsByAccountCreatedBlockIdAndPermissionsIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PermissionsGroupBy>;
    having?: Maybe<PermissionsHavingInput>;
  };

/** A `Permission` edge in the connection, with data from `Account`. */
export type BlockPermissionsByAccountCreatedBlockIdAndPermissionsIdManyToManyEdge = {
  __typename?: 'BlockPermissionsByAccountCreatedBlockIdAndPermissionsIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Permission` at the end of the edge. */
  node?: Maybe<Permission>;
  /** Reads and enables pagination through a set of `Account`. */
  accountsByPermissionsId: AccountsConnection;
};

/** A `Permission` edge in the connection, with data from `Account`. */
export type BlockPermissionsByAccountCreatedBlockIdAndPermissionsIdManyToManyEdgeAccountsByPermissionsIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AccountsOrderBy>>;
    filter?: Maybe<AccountFilter>;
  };

/** A connection to a list of `Permission` values, with data from `Account`. */
export type BlockPermissionsByAccountUpdatedBlockIdAndPermissionsIdManyToManyConnection = {
  __typename?: 'BlockPermissionsByAccountUpdatedBlockIdAndPermissionsIdManyToManyConnection';
  /** A list of `Permission` objects. */
  nodes: Array<Maybe<Permission>>;
  /** A list of edges which contains the `Permission`, info from the `Account`, and the cursor to aid in pagination. */
  edges: Array<BlockPermissionsByAccountUpdatedBlockIdAndPermissionsIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Permission` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PermissionAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PermissionAggregates>>;
};

/** A connection to a list of `Permission` values, with data from `Account`. */
export type BlockPermissionsByAccountUpdatedBlockIdAndPermissionsIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PermissionsGroupBy>;
    having?: Maybe<PermissionsHavingInput>;
  };

/** A `Permission` edge in the connection, with data from `Account`. */
export type BlockPermissionsByAccountUpdatedBlockIdAndPermissionsIdManyToManyEdge = {
  __typename?: 'BlockPermissionsByAccountUpdatedBlockIdAndPermissionsIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Permission` at the end of the edge. */
  node?: Maybe<Permission>;
  /** Reads and enables pagination through a set of `Account`. */
  accountsByPermissionsId: AccountsConnection;
};

/** A `Permission` edge in the connection, with data from `Account`. */
export type BlockPermissionsByAccountUpdatedBlockIdAndPermissionsIdManyToManyEdgeAccountsByPermissionsIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AccountsOrderBy>>;
    filter?: Maybe<AccountFilter>;
  };

/** A connection to a list of `Portfolio` values, with data from `Distribution`. */
export type BlockPortfoliosByDistributionCreatedBlockIdAndPortfolioIdManyToManyConnection = {
  __typename?: 'BlockPortfoliosByDistributionCreatedBlockIdAndPortfolioIdManyToManyConnection';
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** A list of edges which contains the `Portfolio`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<BlockPortfoliosByDistributionCreatedBlockIdAndPortfolioIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
};

/** A connection to a list of `Portfolio` values, with data from `Distribution`. */
export type BlockPortfoliosByDistributionCreatedBlockIdAndPortfolioIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: Maybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `Distribution`. */
export type BlockPortfoliosByDistributionCreatedBlockIdAndPortfolioIdManyToManyEdge = {
  __typename?: 'BlockPortfoliosByDistributionCreatedBlockIdAndPortfolioIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributions: DistributionsConnection;
};

/** A `Portfolio` edge in the connection, with data from `Distribution`. */
export type BlockPortfoliosByDistributionCreatedBlockIdAndPortfolioIdManyToManyEdgeDistributionsArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<DistributionsOrderBy>>;
    filter?: Maybe<DistributionFilter>;
  };

/** A connection to a list of `Portfolio` values, with data from `Distribution`. */
export type BlockPortfoliosByDistributionUpdatedBlockIdAndPortfolioIdManyToManyConnection = {
  __typename?: 'BlockPortfoliosByDistributionUpdatedBlockIdAndPortfolioIdManyToManyConnection';
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** A list of edges which contains the `Portfolio`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<BlockPortfoliosByDistributionUpdatedBlockIdAndPortfolioIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
};

/** A connection to a list of `Portfolio` values, with data from `Distribution`. */
export type BlockPortfoliosByDistributionUpdatedBlockIdAndPortfolioIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: Maybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `Distribution`. */
export type BlockPortfoliosByDistributionUpdatedBlockIdAndPortfolioIdManyToManyEdge = {
  __typename?: 'BlockPortfoliosByDistributionUpdatedBlockIdAndPortfolioIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributions: DistributionsConnection;
};

/** A `Portfolio` edge in the connection, with data from `Distribution`. */
export type BlockPortfoliosByDistributionUpdatedBlockIdAndPortfolioIdManyToManyEdgeDistributionsArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<DistributionsOrderBy>>;
    filter?: Maybe<DistributionFilter>;
  };

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type BlockPortfoliosByLegCreatedBlockIdAndFromIdManyToManyConnection = {
  __typename?: 'BlockPortfoliosByLegCreatedBlockIdAndFromIdManyToManyConnection';
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** A list of edges which contains the `Portfolio`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<BlockPortfoliosByLegCreatedBlockIdAndFromIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
};

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type BlockPortfoliosByLegCreatedBlockIdAndFromIdManyToManyConnectionGroupedAggregatesArgs = {
  groupBy: Array<PortfoliosGroupBy>;
  having?: Maybe<PortfoliosHavingInput>;
};

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type BlockPortfoliosByLegCreatedBlockIdAndFromIdManyToManyEdge = {
  __typename?: 'BlockPortfoliosByLegCreatedBlockIdAndFromIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByFromId: LegsConnection;
};

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type BlockPortfoliosByLegCreatedBlockIdAndFromIdManyToManyEdgeLegsByFromIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<LegsOrderBy>>;
  filter?: Maybe<LegFilter>;
};

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type BlockPortfoliosByLegCreatedBlockIdAndToIdManyToManyConnection = {
  __typename?: 'BlockPortfoliosByLegCreatedBlockIdAndToIdManyToManyConnection';
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** A list of edges which contains the `Portfolio`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<BlockPortfoliosByLegCreatedBlockIdAndToIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
};

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type BlockPortfoliosByLegCreatedBlockIdAndToIdManyToManyConnectionGroupedAggregatesArgs = {
  groupBy: Array<PortfoliosGroupBy>;
  having?: Maybe<PortfoliosHavingInput>;
};

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type BlockPortfoliosByLegCreatedBlockIdAndToIdManyToManyEdge = {
  __typename?: 'BlockPortfoliosByLegCreatedBlockIdAndToIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByToId: LegsConnection;
};

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type BlockPortfoliosByLegCreatedBlockIdAndToIdManyToManyEdgeLegsByToIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<LegsOrderBy>>;
  filter?: Maybe<LegFilter>;
};

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type BlockPortfoliosByLegUpdatedBlockIdAndFromIdManyToManyConnection = {
  __typename?: 'BlockPortfoliosByLegUpdatedBlockIdAndFromIdManyToManyConnection';
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** A list of edges which contains the `Portfolio`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<BlockPortfoliosByLegUpdatedBlockIdAndFromIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
};

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type BlockPortfoliosByLegUpdatedBlockIdAndFromIdManyToManyConnectionGroupedAggregatesArgs = {
  groupBy: Array<PortfoliosGroupBy>;
  having?: Maybe<PortfoliosHavingInput>;
};

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type BlockPortfoliosByLegUpdatedBlockIdAndFromIdManyToManyEdge = {
  __typename?: 'BlockPortfoliosByLegUpdatedBlockIdAndFromIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByFromId: LegsConnection;
};

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type BlockPortfoliosByLegUpdatedBlockIdAndFromIdManyToManyEdgeLegsByFromIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<LegsOrderBy>>;
  filter?: Maybe<LegFilter>;
};

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type BlockPortfoliosByLegUpdatedBlockIdAndToIdManyToManyConnection = {
  __typename?: 'BlockPortfoliosByLegUpdatedBlockIdAndToIdManyToManyConnection';
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** A list of edges which contains the `Portfolio`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<BlockPortfoliosByLegUpdatedBlockIdAndToIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
};

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type BlockPortfoliosByLegUpdatedBlockIdAndToIdManyToManyConnectionGroupedAggregatesArgs = {
  groupBy: Array<PortfoliosGroupBy>;
  having?: Maybe<PortfoliosHavingInput>;
};

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type BlockPortfoliosByLegUpdatedBlockIdAndToIdManyToManyEdge = {
  __typename?: 'BlockPortfoliosByLegUpdatedBlockIdAndToIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByToId: LegsConnection;
};

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type BlockPortfoliosByLegUpdatedBlockIdAndToIdManyToManyEdgeLegsByToIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<LegsOrderBy>>;
  filter?: Maybe<LegFilter>;
};

/** A connection to a list of `Portfolio` values, with data from `PortfolioMovement`. */
export type BlockPortfoliosByPortfolioMovementCreatedBlockIdAndFromIdManyToManyConnection = {
  __typename?: 'BlockPortfoliosByPortfolioMovementCreatedBlockIdAndFromIdManyToManyConnection';
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** A list of edges which contains the `Portfolio`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<BlockPortfoliosByPortfolioMovementCreatedBlockIdAndFromIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
};

/** A connection to a list of `Portfolio` values, with data from `PortfolioMovement`. */
export type BlockPortfoliosByPortfolioMovementCreatedBlockIdAndFromIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: Maybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `PortfolioMovement`. */
export type BlockPortfoliosByPortfolioMovementCreatedBlockIdAndFromIdManyToManyEdge = {
  __typename?: 'BlockPortfoliosByPortfolioMovementCreatedBlockIdAndFromIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByFromId: PortfolioMovementsConnection;
};

/** A `Portfolio` edge in the connection, with data from `PortfolioMovement`. */
export type BlockPortfoliosByPortfolioMovementCreatedBlockIdAndFromIdManyToManyEdgePortfolioMovementsByFromIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<PortfolioMovementsOrderBy>>;
    filter?: Maybe<PortfolioMovementFilter>;
  };

/** A connection to a list of `Portfolio` values, with data from `PortfolioMovement`. */
export type BlockPortfoliosByPortfolioMovementCreatedBlockIdAndToIdManyToManyConnection = {
  __typename?: 'BlockPortfoliosByPortfolioMovementCreatedBlockIdAndToIdManyToManyConnection';
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** A list of edges which contains the `Portfolio`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<BlockPortfoliosByPortfolioMovementCreatedBlockIdAndToIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
};

/** A connection to a list of `Portfolio` values, with data from `PortfolioMovement`. */
export type BlockPortfoliosByPortfolioMovementCreatedBlockIdAndToIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: Maybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `PortfolioMovement`. */
export type BlockPortfoliosByPortfolioMovementCreatedBlockIdAndToIdManyToManyEdge = {
  __typename?: 'BlockPortfoliosByPortfolioMovementCreatedBlockIdAndToIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByToId: PortfolioMovementsConnection;
};

/** A `Portfolio` edge in the connection, with data from `PortfolioMovement`. */
export type BlockPortfoliosByPortfolioMovementCreatedBlockIdAndToIdManyToManyEdgePortfolioMovementsByToIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<PortfolioMovementsOrderBy>>;
    filter?: Maybe<PortfolioMovementFilter>;
  };

/** A connection to a list of `Portfolio` values, with data from `PortfolioMovement`. */
export type BlockPortfoliosByPortfolioMovementUpdatedBlockIdAndFromIdManyToManyConnection = {
  __typename?: 'BlockPortfoliosByPortfolioMovementUpdatedBlockIdAndFromIdManyToManyConnection';
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** A list of edges which contains the `Portfolio`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<BlockPortfoliosByPortfolioMovementUpdatedBlockIdAndFromIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
};

/** A connection to a list of `Portfolio` values, with data from `PortfolioMovement`. */
export type BlockPortfoliosByPortfolioMovementUpdatedBlockIdAndFromIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: Maybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `PortfolioMovement`. */
export type BlockPortfoliosByPortfolioMovementUpdatedBlockIdAndFromIdManyToManyEdge = {
  __typename?: 'BlockPortfoliosByPortfolioMovementUpdatedBlockIdAndFromIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByFromId: PortfolioMovementsConnection;
};

/** A `Portfolio` edge in the connection, with data from `PortfolioMovement`. */
export type BlockPortfoliosByPortfolioMovementUpdatedBlockIdAndFromIdManyToManyEdgePortfolioMovementsByFromIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<PortfolioMovementsOrderBy>>;
    filter?: Maybe<PortfolioMovementFilter>;
  };

/** A connection to a list of `Portfolio` values, with data from `PortfolioMovement`. */
export type BlockPortfoliosByPortfolioMovementUpdatedBlockIdAndToIdManyToManyConnection = {
  __typename?: 'BlockPortfoliosByPortfolioMovementUpdatedBlockIdAndToIdManyToManyConnection';
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** A list of edges which contains the `Portfolio`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<BlockPortfoliosByPortfolioMovementUpdatedBlockIdAndToIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
};

/** A connection to a list of `Portfolio` values, with data from `PortfolioMovement`. */
export type BlockPortfoliosByPortfolioMovementUpdatedBlockIdAndToIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: Maybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `PortfolioMovement`. */
export type BlockPortfoliosByPortfolioMovementUpdatedBlockIdAndToIdManyToManyEdge = {
  __typename?: 'BlockPortfoliosByPortfolioMovementUpdatedBlockIdAndToIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByToId: PortfolioMovementsConnection;
};

/** A `Portfolio` edge in the connection, with data from `PortfolioMovement`. */
export type BlockPortfoliosByPortfolioMovementUpdatedBlockIdAndToIdManyToManyEdgePortfolioMovementsByToIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<PortfolioMovementsOrderBy>>;
    filter?: Maybe<PortfolioMovementFilter>;
  };

/** A connection to a list of `Proposal` values, with data from `ProposalVote`. */
export type BlockProposalsByProposalVoteCreatedBlockIdAndProposalIdManyToManyConnection = {
  __typename?: 'BlockProposalsByProposalVoteCreatedBlockIdAndProposalIdManyToManyConnection';
  /** A list of `Proposal` objects. */
  nodes: Array<Maybe<Proposal>>;
  /** A list of edges which contains the `Proposal`, info from the `ProposalVote`, and the cursor to aid in pagination. */
  edges: Array<BlockProposalsByProposalVoteCreatedBlockIdAndProposalIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Proposal` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<ProposalAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<ProposalAggregates>>;
};

/** A connection to a list of `Proposal` values, with data from `ProposalVote`. */
export type BlockProposalsByProposalVoteCreatedBlockIdAndProposalIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<ProposalsGroupBy>;
    having?: Maybe<ProposalsHavingInput>;
  };

/** A `Proposal` edge in the connection, with data from `ProposalVote`. */
export type BlockProposalsByProposalVoteCreatedBlockIdAndProposalIdManyToManyEdge = {
  __typename?: 'BlockProposalsByProposalVoteCreatedBlockIdAndProposalIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Proposal` at the end of the edge. */
  node?: Maybe<Proposal>;
  /** Reads and enables pagination through a set of `ProposalVote`. */
  votes: ProposalVotesConnection;
};

/** A `Proposal` edge in the connection, with data from `ProposalVote`. */
export type BlockProposalsByProposalVoteCreatedBlockIdAndProposalIdManyToManyEdgeVotesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ProposalVotesOrderBy>>;
  filter?: Maybe<ProposalVoteFilter>;
};

/** A connection to a list of `Proposal` values, with data from `ProposalVote`. */
export type BlockProposalsByProposalVoteUpdatedBlockIdAndProposalIdManyToManyConnection = {
  __typename?: 'BlockProposalsByProposalVoteUpdatedBlockIdAndProposalIdManyToManyConnection';
  /** A list of `Proposal` objects. */
  nodes: Array<Maybe<Proposal>>;
  /** A list of edges which contains the `Proposal`, info from the `ProposalVote`, and the cursor to aid in pagination. */
  edges: Array<BlockProposalsByProposalVoteUpdatedBlockIdAndProposalIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Proposal` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<ProposalAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<ProposalAggregates>>;
};

/** A connection to a list of `Proposal` values, with data from `ProposalVote`. */
export type BlockProposalsByProposalVoteUpdatedBlockIdAndProposalIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<ProposalsGroupBy>;
    having?: Maybe<ProposalsHavingInput>;
  };

/** A `Proposal` edge in the connection, with data from `ProposalVote`. */
export type BlockProposalsByProposalVoteUpdatedBlockIdAndProposalIdManyToManyEdge = {
  __typename?: 'BlockProposalsByProposalVoteUpdatedBlockIdAndProposalIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Proposal` at the end of the edge. */
  node?: Maybe<Proposal>;
  /** Reads and enables pagination through a set of `ProposalVote`. */
  votes: ProposalVotesConnection;
};

/** A `Proposal` edge in the connection, with data from `ProposalVote`. */
export type BlockProposalsByProposalVoteUpdatedBlockIdAndProposalIdManyToManyEdgeVotesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ProposalVotesOrderBy>>;
  filter?: Maybe<ProposalVoteFilter>;
};

/** A connection to a list of `Settlement` values, with data from `Leg`. */
export type BlockSettlementsByLegCreatedBlockIdAndSettlementIdManyToManyConnection = {
  __typename?: 'BlockSettlementsByLegCreatedBlockIdAndSettlementIdManyToManyConnection';
  /** A list of `Settlement` objects. */
  nodes: Array<Maybe<Settlement>>;
  /** A list of edges which contains the `Settlement`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<BlockSettlementsByLegCreatedBlockIdAndSettlementIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Settlement` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<SettlementAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<SettlementAggregates>>;
};

/** A connection to a list of `Settlement` values, with data from `Leg`. */
export type BlockSettlementsByLegCreatedBlockIdAndSettlementIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<SettlementsGroupBy>;
    having?: Maybe<SettlementsHavingInput>;
  };

/** A `Settlement` edge in the connection, with data from `Leg`. */
export type BlockSettlementsByLegCreatedBlockIdAndSettlementIdManyToManyEdge = {
  __typename?: 'BlockSettlementsByLegCreatedBlockIdAndSettlementIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Settlement` at the end of the edge. */
  node?: Maybe<Settlement>;
  /** Reads and enables pagination through a set of `Leg`. */
  legs: LegsConnection;
};

/** A `Settlement` edge in the connection, with data from `Leg`. */
export type BlockSettlementsByLegCreatedBlockIdAndSettlementIdManyToManyEdgeLegsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<LegsOrderBy>>;
  filter?: Maybe<LegFilter>;
};

/** A connection to a list of `Settlement` values, with data from `Leg`. */
export type BlockSettlementsByLegUpdatedBlockIdAndSettlementIdManyToManyConnection = {
  __typename?: 'BlockSettlementsByLegUpdatedBlockIdAndSettlementIdManyToManyConnection';
  /** A list of `Settlement` objects. */
  nodes: Array<Maybe<Settlement>>;
  /** A list of edges which contains the `Settlement`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<BlockSettlementsByLegUpdatedBlockIdAndSettlementIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Settlement` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<SettlementAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<SettlementAggregates>>;
};

/** A connection to a list of `Settlement` values, with data from `Leg`. */
export type BlockSettlementsByLegUpdatedBlockIdAndSettlementIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<SettlementsGroupBy>;
    having?: Maybe<SettlementsHavingInput>;
  };

/** A `Settlement` edge in the connection, with data from `Leg`. */
export type BlockSettlementsByLegUpdatedBlockIdAndSettlementIdManyToManyEdge = {
  __typename?: 'BlockSettlementsByLegUpdatedBlockIdAndSettlementIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Settlement` at the end of the edge. */
  node?: Maybe<Settlement>;
  /** Reads and enables pagination through a set of `Leg`. */
  legs: LegsConnection;
};

/** A `Settlement` edge in the connection, with data from `Leg`. */
export type BlockSettlementsByLegUpdatedBlockIdAndSettlementIdManyToManyEdgeLegsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<LegsOrderBy>>;
  filter?: Maybe<LegFilter>;
};

/** A connection to a list of `StatType` values, with data from `TransferCompliance`. */
export type BlockStatTypesByTransferComplianceCreatedBlockIdAndStatTypeIdManyToManyConnection = {
  __typename?: 'BlockStatTypesByTransferComplianceCreatedBlockIdAndStatTypeIdManyToManyConnection';
  /** A list of `StatType` objects. */
  nodes: Array<Maybe<StatType>>;
  /** A list of edges which contains the `StatType`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
  edges: Array<BlockStatTypesByTransferComplianceCreatedBlockIdAndStatTypeIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `StatType` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<StatTypeAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<StatTypeAggregates>>;
};

/** A connection to a list of `StatType` values, with data from `TransferCompliance`. */
export type BlockStatTypesByTransferComplianceCreatedBlockIdAndStatTypeIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<StatTypesGroupBy>;
    having?: Maybe<StatTypesHavingInput>;
  };

/** A `StatType` edge in the connection, with data from `TransferCompliance`. */
export type BlockStatTypesByTransferComplianceCreatedBlockIdAndStatTypeIdManyToManyEdge = {
  __typename?: 'BlockStatTypesByTransferComplianceCreatedBlockIdAndStatTypeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `StatType` at the end of the edge. */
  node?: Maybe<StatType>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliances: TransferCompliancesConnection;
};

/** A `StatType` edge in the connection, with data from `TransferCompliance`. */
export type BlockStatTypesByTransferComplianceCreatedBlockIdAndStatTypeIdManyToManyEdgeTransferCompliancesArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TransferCompliancesOrderBy>>;
    filter?: Maybe<TransferComplianceFilter>;
  };

/** A connection to a list of `StatType` values, with data from `TransferCompliance`. */
export type BlockStatTypesByTransferComplianceUpdatedBlockIdAndStatTypeIdManyToManyConnection = {
  __typename?: 'BlockStatTypesByTransferComplianceUpdatedBlockIdAndStatTypeIdManyToManyConnection';
  /** A list of `StatType` objects. */
  nodes: Array<Maybe<StatType>>;
  /** A list of edges which contains the `StatType`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
  edges: Array<BlockStatTypesByTransferComplianceUpdatedBlockIdAndStatTypeIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `StatType` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<StatTypeAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<StatTypeAggregates>>;
};

/** A connection to a list of `StatType` values, with data from `TransferCompliance`. */
export type BlockStatTypesByTransferComplianceUpdatedBlockIdAndStatTypeIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<StatTypesGroupBy>;
    having?: Maybe<StatTypesHavingInput>;
  };

/** A `StatType` edge in the connection, with data from `TransferCompliance`. */
export type BlockStatTypesByTransferComplianceUpdatedBlockIdAndStatTypeIdManyToManyEdge = {
  __typename?: 'BlockStatTypesByTransferComplianceUpdatedBlockIdAndStatTypeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `StatType` at the end of the edge. */
  node?: Maybe<StatType>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliances: TransferCompliancesConnection;
};

/** A `StatType` edge in the connection, with data from `TransferCompliance`. */
export type BlockStatTypesByTransferComplianceUpdatedBlockIdAndStatTypeIdManyToManyEdgeTransferCompliancesArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TransferCompliancesOrderBy>>;
    filter?: Maybe<TransferComplianceFilter>;
  };

/** A connection to a list of `Venue` values, with data from `Instruction`. */
export type BlockVenuesByInstructionCreatedBlockIdAndVenueIdManyToManyConnection = {
  __typename?: 'BlockVenuesByInstructionCreatedBlockIdAndVenueIdManyToManyConnection';
  /** A list of `Venue` objects. */
  nodes: Array<Maybe<Venue>>;
  /** A list of edges which contains the `Venue`, info from the `Instruction`, and the cursor to aid in pagination. */
  edges: Array<BlockVenuesByInstructionCreatedBlockIdAndVenueIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Venue` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<VenueAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<VenueAggregates>>;
};

/** A connection to a list of `Venue` values, with data from `Instruction`. */
export type BlockVenuesByInstructionCreatedBlockIdAndVenueIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<VenuesGroupBy>;
    having?: Maybe<VenuesHavingInput>;
  };

/** A `Venue` edge in the connection, with data from `Instruction`. */
export type BlockVenuesByInstructionCreatedBlockIdAndVenueIdManyToManyEdge = {
  __typename?: 'BlockVenuesByInstructionCreatedBlockIdAndVenueIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Venue` at the end of the edge. */
  node?: Maybe<Venue>;
  /** Reads and enables pagination through a set of `Instruction`. */
  instructions: InstructionsConnection;
};

/** A `Venue` edge in the connection, with data from `Instruction`. */
export type BlockVenuesByInstructionCreatedBlockIdAndVenueIdManyToManyEdgeInstructionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<InstructionsOrderBy>>;
  filter?: Maybe<InstructionFilter>;
};

/** A connection to a list of `Venue` values, with data from `Instruction`. */
export type BlockVenuesByInstructionUpdatedBlockIdAndVenueIdManyToManyConnection = {
  __typename?: 'BlockVenuesByInstructionUpdatedBlockIdAndVenueIdManyToManyConnection';
  /** A list of `Venue` objects. */
  nodes: Array<Maybe<Venue>>;
  /** A list of edges which contains the `Venue`, info from the `Instruction`, and the cursor to aid in pagination. */
  edges: Array<BlockVenuesByInstructionUpdatedBlockIdAndVenueIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Venue` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<VenueAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<VenueAggregates>>;
};

/** A connection to a list of `Venue` values, with data from `Instruction`. */
export type BlockVenuesByInstructionUpdatedBlockIdAndVenueIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<VenuesGroupBy>;
    having?: Maybe<VenuesHavingInput>;
  };

/** A `Venue` edge in the connection, with data from `Instruction`. */
export type BlockVenuesByInstructionUpdatedBlockIdAndVenueIdManyToManyEdge = {
  __typename?: 'BlockVenuesByInstructionUpdatedBlockIdAndVenueIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Venue` at the end of the edge. */
  node?: Maybe<Venue>;
  /** Reads and enables pagination through a set of `Instruction`. */
  instructions: InstructionsConnection;
};

/** A `Venue` edge in the connection, with data from `Instruction`. */
export type BlockVenuesByInstructionUpdatedBlockIdAndVenueIdManyToManyEdgeInstructionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<InstructionsOrderBy>>;
  filter?: Maybe<InstructionFilter>;
};

/** A connection to a list of `Block` values. */
export type BlocksConnection = {
  __typename?: 'BlocksConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block` and cursor to aid in pagination. */
  edges: Array<BlocksEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values. */
export type BlocksConnectionGroupedAggregatesArgs = {
  groupBy: Array<BlocksGroupBy>;
  having?: Maybe<BlocksHavingInput>;
};

/** A `Block` edge in the connection. */
export type BlocksEdge = {
  __typename?: 'BlocksEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
};

/** Grouping methods for `Block` for usage during aggregation. */
export enum BlocksGroupBy {
  BlockId = 'BLOCK_ID',
  ParentId = 'PARENT_ID',
  Hash = 'HASH',
  ParentHash = 'PARENT_HASH',
  StateRoot = 'STATE_ROOT',
  ExtrinsicsRoot = 'EXTRINSICS_ROOT',
  CountExtrinsics = 'COUNT_EXTRINSICS',
  CountExtrinsicsUnsigned = 'COUNT_EXTRINSICS_UNSIGNED',
  CountExtrinsicsSigned = 'COUNT_EXTRINSICS_SIGNED',
  CountExtrinsicsError = 'COUNT_EXTRINSICS_ERROR',
  CountExtrinsicsSuccess = 'COUNT_EXTRINSICS_SUCCESS',
  CountEvents = 'COUNT_EVENTS',
  Datetime = 'DATETIME',
  SpecVersionId = 'SPEC_VERSION_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `Block` aggregates. */
export type BlocksHavingInput = {
  AND?: Maybe<Array<BlocksHavingInput>>;
  OR?: Maybe<Array<BlocksHavingInput>>;
};

/** Methods to use when ordering `Block`. */
export enum BlocksOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  BlockIdAsc = 'BLOCK_ID_ASC',
  BlockIdDesc = 'BLOCK_ID_DESC',
  ParentIdAsc = 'PARENT_ID_ASC',
  ParentIdDesc = 'PARENT_ID_DESC',
  HashAsc = 'HASH_ASC',
  HashDesc = 'HASH_DESC',
  ParentHashAsc = 'PARENT_HASH_ASC',
  ParentHashDesc = 'PARENT_HASH_DESC',
  StateRootAsc = 'STATE_ROOT_ASC',
  StateRootDesc = 'STATE_ROOT_DESC',
  ExtrinsicsRootAsc = 'EXTRINSICS_ROOT_ASC',
  ExtrinsicsRootDesc = 'EXTRINSICS_ROOT_DESC',
  CountExtrinsicsAsc = 'COUNT_EXTRINSICS_ASC',
  CountExtrinsicsDesc = 'COUNT_EXTRINSICS_DESC',
  CountExtrinsicsUnsignedAsc = 'COUNT_EXTRINSICS_UNSIGNED_ASC',
  CountExtrinsicsUnsignedDesc = 'COUNT_EXTRINSICS_UNSIGNED_DESC',
  CountExtrinsicsSignedAsc = 'COUNT_EXTRINSICS_SIGNED_ASC',
  CountExtrinsicsSignedDesc = 'COUNT_EXTRINSICS_SIGNED_DESC',
  CountExtrinsicsErrorAsc = 'COUNT_EXTRINSICS_ERROR_ASC',
  CountExtrinsicsErrorDesc = 'COUNT_EXTRINSICS_ERROR_DESC',
  CountExtrinsicsSuccessAsc = 'COUNT_EXTRINSICS_SUCCESS_ASC',
  CountExtrinsicsSuccessDesc = 'COUNT_EXTRINSICS_SUCCESS_DESC',
  CountEventsAsc = 'COUNT_EVENTS_ASC',
  CountEventsDesc = 'COUNT_EVENTS_DESC',
  DatetimeAsc = 'DATETIME_ASC',
  DatetimeDesc = 'DATETIME_DESC',
  SpecVersionIdAsc = 'SPEC_VERSION_ID_ASC',
  SpecVersionIdDesc = 'SPEC_VERSION_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  EventsCountAsc = 'EVENTS_COUNT_ASC',
  EventsCountDesc = 'EVENTS_COUNT_DESC',
  ExtrinsicsCountAsc = 'EXTRINSICS_COUNT_ASC',
  ExtrinsicsCountDesc = 'EXTRINSICS_COUNT_DESC',
  PermissionsByCreatedBlockIdCountAsc = 'PERMISSIONS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  PermissionsByCreatedBlockIdCountDesc = 'PERMISSIONS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  PermissionsByUpdatedBlockIdCountAsc = 'PERMISSIONS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  PermissionsByUpdatedBlockIdCountDesc = 'PERMISSIONS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  IdentitiesByCreatedBlockIdCountAsc = 'IDENTITIES_BY_CREATED_BLOCK_ID_COUNT_ASC',
  IdentitiesByCreatedBlockIdCountDesc = 'IDENTITIES_BY_CREATED_BLOCK_ID_COUNT_DESC',
  IdentitiesByUpdatedBlockIdCountAsc = 'IDENTITIES_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  IdentitiesByUpdatedBlockIdCountDesc = 'IDENTITIES_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  AccountsByCreatedBlockIdCountAsc = 'ACCOUNTS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  AccountsByCreatedBlockIdCountDesc = 'ACCOUNTS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  AccountsByUpdatedBlockIdCountAsc = 'ACCOUNTS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  AccountsByUpdatedBlockIdCountDesc = 'ACCOUNTS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  BridgeEventsByCreatedBlockIdCountAsc = 'BRIDGE_EVENTS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  BridgeEventsByCreatedBlockIdCountDesc = 'BRIDGE_EVENTS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  BridgeEventsByUpdatedBlockIdCountAsc = 'BRIDGE_EVENTS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  BridgeEventsByUpdatedBlockIdCountDesc = 'BRIDGE_EVENTS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  StakingEventsByCreatedBlockIdCountAsc = 'STAKING_EVENTS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  StakingEventsByCreatedBlockIdCountDesc = 'STAKING_EVENTS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  StakingEventsByUpdatedBlockIdCountAsc = 'STAKING_EVENTS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  StakingEventsByUpdatedBlockIdCountDesc = 'STAKING_EVENTS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  AssetsByCreatedBlockIdCountAsc = 'ASSETS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  AssetsByCreatedBlockIdCountDesc = 'ASSETS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  AssetsByUpdatedBlockIdCountAsc = 'ASSETS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  AssetsByUpdatedBlockIdCountDesc = 'ASSETS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  TickerExternalAgentActionsByCreatedBlockIdCountAsc = 'TICKER_EXTERNAL_AGENT_ACTIONS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  TickerExternalAgentActionsByCreatedBlockIdCountDesc = 'TICKER_EXTERNAL_AGENT_ACTIONS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  TickerExternalAgentActionsByUpdatedBlockIdCountAsc = 'TICKER_EXTERNAL_AGENT_ACTIONS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  TickerExternalAgentActionsByUpdatedBlockIdCountDesc = 'TICKER_EXTERNAL_AGENT_ACTIONS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  StosByCreatedBlockIdCountAsc = 'STOS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  StosByCreatedBlockIdCountDesc = 'STOS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  StosByUpdatedBlockIdCountAsc = 'STOS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  StosByUpdatedBlockIdCountDesc = 'STOS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  AuthorizationsByCreatedBlockIdCountAsc = 'AUTHORIZATIONS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  AuthorizationsByCreatedBlockIdCountDesc = 'AUTHORIZATIONS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  AuthorizationsByUpdatedBlockIdCountAsc = 'AUTHORIZATIONS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  AuthorizationsByUpdatedBlockIdCountDesc = 'AUTHORIZATIONS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  InvestmentsByCreatedBlockIdCountAsc = 'INVESTMENTS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  InvestmentsByCreatedBlockIdCountDesc = 'INVESTMENTS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  InvestmentsByUpdatedBlockIdCountAsc = 'INVESTMENTS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  InvestmentsByUpdatedBlockIdCountDesc = 'INVESTMENTS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  TickerExternalAgentsByCreatedBlockIdCountAsc = 'TICKER_EXTERNAL_AGENTS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  TickerExternalAgentsByCreatedBlockIdCountDesc = 'TICKER_EXTERNAL_AGENTS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  TickerExternalAgentsByUpdatedBlockIdCountAsc = 'TICKER_EXTERNAL_AGENTS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  TickerExternalAgentsByUpdatedBlockIdCountDesc = 'TICKER_EXTERNAL_AGENTS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  TickerExternalAgentHistoriesByCreatedBlockIdCountAsc = 'TICKER_EXTERNAL_AGENT_HISTORIES_BY_CREATED_BLOCK_ID_COUNT_ASC',
  TickerExternalAgentHistoriesByCreatedBlockIdCountDesc = 'TICKER_EXTERNAL_AGENT_HISTORIES_BY_CREATED_BLOCK_ID_COUNT_DESC',
  TickerExternalAgentHistoriesByUpdatedBlockIdCountAsc = 'TICKER_EXTERNAL_AGENT_HISTORIES_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  TickerExternalAgentHistoriesByUpdatedBlockIdCountDesc = 'TICKER_EXTERNAL_AGENT_HISTORIES_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  AgentGroupsByCreatedBlockIdCountAsc = 'AGENT_GROUPS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  AgentGroupsByCreatedBlockIdCountDesc = 'AGENT_GROUPS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  AgentGroupsByUpdatedBlockIdCountAsc = 'AGENT_GROUPS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  AgentGroupsByUpdatedBlockIdCountDesc = 'AGENT_GROUPS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  AgentGroupMembershipsByCreatedBlockIdCountAsc = 'AGENT_GROUP_MEMBERSHIPS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  AgentGroupMembershipsByCreatedBlockIdCountDesc = 'AGENT_GROUP_MEMBERSHIPS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  AgentGroupMembershipsByUpdatedBlockIdCountAsc = 'AGENT_GROUP_MEMBERSHIPS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  AgentGroupMembershipsByUpdatedBlockIdCountDesc = 'AGENT_GROUP_MEMBERSHIPS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  PortfoliosByCreatedBlockIdCountAsc = 'PORTFOLIOS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  PortfoliosByCreatedBlockIdCountDesc = 'PORTFOLIOS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  PortfoliosByUpdatedBlockIdCountAsc = 'PORTFOLIOS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  PortfoliosByUpdatedBlockIdCountDesc = 'PORTFOLIOS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  PortfolioMovementsByCreatedBlockIdCountAsc = 'PORTFOLIO_MOVEMENTS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  PortfolioMovementsByCreatedBlockIdCountDesc = 'PORTFOLIO_MOVEMENTS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  PortfolioMovementsByUpdatedBlockIdCountAsc = 'PORTFOLIO_MOVEMENTS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  PortfolioMovementsByUpdatedBlockIdCountDesc = 'PORTFOLIO_MOVEMENTS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  VenuesByCreatedBlockIdCountAsc = 'VENUES_BY_CREATED_BLOCK_ID_COUNT_ASC',
  VenuesByCreatedBlockIdCountDesc = 'VENUES_BY_CREATED_BLOCK_ID_COUNT_DESC',
  VenuesByUpdatedBlockIdCountAsc = 'VENUES_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  VenuesByUpdatedBlockIdCountDesc = 'VENUES_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  InstructionsByCreatedBlockIdCountAsc = 'INSTRUCTIONS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  InstructionsByCreatedBlockIdCountDesc = 'INSTRUCTIONS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  InstructionsByUpdatedBlockIdCountAsc = 'INSTRUCTIONS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  InstructionsByUpdatedBlockIdCountDesc = 'INSTRUCTIONS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  SettlementsByCreatedBlockIdCountAsc = 'SETTLEMENTS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  SettlementsByCreatedBlockIdCountDesc = 'SETTLEMENTS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  SettlementsByUpdatedBlockIdCountAsc = 'SETTLEMENTS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  SettlementsByUpdatedBlockIdCountDesc = 'SETTLEMENTS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  LegsByCreatedBlockIdCountAsc = 'LEGS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  LegsByCreatedBlockIdCountDesc = 'LEGS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  LegsByUpdatedBlockIdCountAsc = 'LEGS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  LegsByUpdatedBlockIdCountDesc = 'LEGS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  DistributionsByCreatedBlockIdCountAsc = 'DISTRIBUTIONS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  DistributionsByCreatedBlockIdCountDesc = 'DISTRIBUTIONS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  DistributionsByUpdatedBlockIdCountAsc = 'DISTRIBUTIONS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  DistributionsByUpdatedBlockIdCountDesc = 'DISTRIBUTIONS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  DistributionPaymentsByCreatedBlockIdCountAsc = 'DISTRIBUTION_PAYMENTS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  DistributionPaymentsByCreatedBlockIdCountDesc = 'DISTRIBUTION_PAYMENTS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  DistributionPaymentsByUpdatedBlockIdCountAsc = 'DISTRIBUTION_PAYMENTS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  DistributionPaymentsByUpdatedBlockIdCountDesc = 'DISTRIBUTION_PAYMENTS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  ProposalsByCreatedBlockIdCountAsc = 'PROPOSALS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  ProposalsByCreatedBlockIdCountDesc = 'PROPOSALS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  ProposalsByUpdatedBlockIdCountAsc = 'PROPOSALS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  ProposalsByUpdatedBlockIdCountDesc = 'PROPOSALS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  ProposalVotesByCreatedBlockIdCountAsc = 'PROPOSAL_VOTES_BY_CREATED_BLOCK_ID_COUNT_ASC',
  ProposalVotesByCreatedBlockIdCountDesc = 'PROPOSAL_VOTES_BY_CREATED_BLOCK_ID_COUNT_DESC',
  ProposalVotesByUpdatedBlockIdCountAsc = 'PROPOSAL_VOTES_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  ProposalVotesByUpdatedBlockIdCountDesc = 'PROPOSAL_VOTES_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  ClaimScopesByCreatedBlockIdCountAsc = 'CLAIM_SCOPES_BY_CREATED_BLOCK_ID_COUNT_ASC',
  ClaimScopesByCreatedBlockIdCountDesc = 'CLAIM_SCOPES_BY_CREATED_BLOCK_ID_COUNT_DESC',
  ClaimScopesByUpdatedBlockIdCountAsc = 'CLAIM_SCOPES_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  ClaimScopesByUpdatedBlockIdCountDesc = 'CLAIM_SCOPES_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  ClaimsByCreatedBlockIdCountAsc = 'CLAIMS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  ClaimsByCreatedBlockIdCountDesc = 'CLAIMS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  ClaimsByUpdatedBlockIdCountAsc = 'CLAIMS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  ClaimsByUpdatedBlockIdCountDesc = 'CLAIMS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  TrustedClaimIssuersByCreatedBlockIdCountAsc = 'TRUSTED_CLAIM_ISSUERS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  TrustedClaimIssuersByCreatedBlockIdCountDesc = 'TRUSTED_CLAIM_ISSUERS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  TrustedClaimIssuersByUpdatedBlockIdCountAsc = 'TRUSTED_CLAIM_ISSUERS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  TrustedClaimIssuersByUpdatedBlockIdCountDesc = 'TRUSTED_CLAIM_ISSUERS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  AssetPendingOwnershipTransfersByCreatedBlockIdCountAsc = 'ASSET_PENDING_OWNERSHIP_TRANSFERS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  AssetPendingOwnershipTransfersByCreatedBlockIdCountDesc = 'ASSET_PENDING_OWNERSHIP_TRANSFERS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  AssetPendingOwnershipTransfersByUpdatedBlockIdCountAsc = 'ASSET_PENDING_OWNERSHIP_TRANSFERS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  AssetPendingOwnershipTransfersByUpdatedBlockIdCountDesc = 'ASSET_PENDING_OWNERSHIP_TRANSFERS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  TransferManagersByCreatedBlockIdCountAsc = 'TRANSFER_MANAGERS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  TransferManagersByCreatedBlockIdCountDesc = 'TRANSFER_MANAGERS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  TransferManagersByUpdatedBlockIdCountAsc = 'TRANSFER_MANAGERS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  TransferManagersByUpdatedBlockIdCountDesc = 'TRANSFER_MANAGERS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  StatTypesByCreatedBlockIdCountAsc = 'STAT_TYPES_BY_CREATED_BLOCK_ID_COUNT_ASC',
  StatTypesByCreatedBlockIdCountDesc = 'STAT_TYPES_BY_CREATED_BLOCK_ID_COUNT_DESC',
  StatTypesByUpdatedBlockIdCountAsc = 'STAT_TYPES_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  StatTypesByUpdatedBlockIdCountDesc = 'STAT_TYPES_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  TransferCompliancesByCreatedBlockIdCountAsc = 'TRANSFER_COMPLIANCES_BY_CREATED_BLOCK_ID_COUNT_ASC',
  TransferCompliancesByCreatedBlockIdCountDesc = 'TRANSFER_COMPLIANCES_BY_CREATED_BLOCK_ID_COUNT_DESC',
  TransferCompliancesByUpdatedBlockIdCountAsc = 'TRANSFER_COMPLIANCES_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  TransferCompliancesByUpdatedBlockIdCountDesc = 'TRANSFER_COMPLIANCES_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  TransferComplianceExemptionsByCreatedBlockIdCountAsc = 'TRANSFER_COMPLIANCE_EXEMPTIONS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  TransferComplianceExemptionsByCreatedBlockIdCountDesc = 'TRANSFER_COMPLIANCE_EXEMPTIONS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  TransferComplianceExemptionsByUpdatedBlockIdCountAsc = 'TRANSFER_COMPLIANCE_EXEMPTIONS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  TransferComplianceExemptionsByUpdatedBlockIdCountDesc = 'TRANSFER_COMPLIANCE_EXEMPTIONS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  CompliancesByCreatedBlockIdCountAsc = 'COMPLIANCES_BY_CREATED_BLOCK_ID_COUNT_ASC',
  CompliancesByCreatedBlockIdCountDesc = 'COMPLIANCES_BY_CREATED_BLOCK_ID_COUNT_DESC',
  CompliancesByUpdatedBlockIdCountAsc = 'COMPLIANCES_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  CompliancesByUpdatedBlockIdCountDesc = 'COMPLIANCES_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  AssetHoldersByCreatedBlockIdCountAsc = 'ASSET_HOLDERS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  AssetHoldersByCreatedBlockIdCountDesc = 'ASSET_HOLDERS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  AssetHoldersByUpdatedBlockIdCountAsc = 'ASSET_HOLDERS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  AssetHoldersByUpdatedBlockIdCountDesc = 'ASSET_HOLDERS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  AssetDocumentsByCreatedBlockIdCountAsc = 'ASSET_DOCUMENTS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  AssetDocumentsByCreatedBlockIdCountDesc = 'ASSET_DOCUMENTS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  AssetDocumentsByUpdatedBlockIdCountAsc = 'ASSET_DOCUMENTS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  AssetDocumentsByUpdatedBlockIdCountDesc = 'ASSET_DOCUMENTS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
  FundingsByCreatedBlockIdCountAsc = 'FUNDINGS_BY_CREATED_BLOCK_ID_COUNT_ASC',
  FundingsByCreatedBlockIdCountDesc = 'FUNDINGS_BY_CREATED_BLOCK_ID_COUNT_DESC',
  FundingsByUpdatedBlockIdCountAsc = 'FUNDINGS_BY_UPDATED_BLOCK_ID_COUNT_ASC',
  FundingsByUpdatedBlockIdCountDesc = 'FUNDINGS_BY_UPDATED_BLOCK_ID_COUNT_DESC',
}

/** A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’ */
export type BooleanFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Boolean']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Boolean']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Boolean']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Boolean']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Boolean']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Boolean']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Boolean']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Boolean']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Boolean']>;
};

export type BridgeEvent = Node & {
  __typename?: 'BridgeEvent';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  identityId: Scalars['String'];
  recipient: Scalars['String'];
  amount: Scalars['BigFloat'];
  txHash: Scalars['String'];
  datetime: Scalars['Datetime'];
  createdBlockId: Scalars['String'];
  updatedBlockId: Scalars['String'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Identity` that is related to this `BridgeEvent`. */
  identity?: Maybe<Identity>;
  /** Reads a single `Block` that is related to this `BridgeEvent`. */
  createdBlock?: Maybe<Block>;
  /** Reads a single `Block` that is related to this `BridgeEvent`. */
  updatedBlock?: Maybe<Block>;
};

export type BridgeEventAggregates = {
  __typename?: 'BridgeEventAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `BridgeEvent` object types. All fields are combined with a logical ‘and.’ */
export type BridgeEventFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `identityId` field. */
  identityId?: Maybe<StringFilter>;
  /** Filter by the object’s `recipient` field. */
  recipient?: Maybe<StringFilter>;
  /** Filter by the object’s `amount` field. */
  amount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `txHash` field. */
  txHash?: Maybe<StringFilter>;
  /** Filter by the object’s `datetime` field. */
  datetime?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<BridgeEventFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<BridgeEventFilter>>;
  /** Negates the expression. */
  not?: Maybe<BridgeEventFilter>;
};

/** A connection to a list of `BridgeEvent` values. */
export type BridgeEventsConnection = {
  __typename?: 'BridgeEventsConnection';
  /** A list of `BridgeEvent` objects. */
  nodes: Array<Maybe<BridgeEvent>>;
  /** A list of edges which contains the `BridgeEvent` and cursor to aid in pagination. */
  edges: Array<BridgeEventsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `BridgeEvent` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BridgeEventAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BridgeEventAggregates>>;
};

/** A connection to a list of `BridgeEvent` values. */
export type BridgeEventsConnectionGroupedAggregatesArgs = {
  groupBy: Array<BridgeEventsGroupBy>;
  having?: Maybe<BridgeEventsHavingInput>;
};

/** A `BridgeEvent` edge in the connection. */
export type BridgeEventsEdge = {
  __typename?: 'BridgeEventsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `BridgeEvent` at the end of the edge. */
  node?: Maybe<BridgeEvent>;
};

/** Grouping methods for `BridgeEvent` for usage during aggregation. */
export enum BridgeEventsGroupBy {
  IdentityId = 'IDENTITY_ID',
  Recipient = 'RECIPIENT',
  Amount = 'AMOUNT',
  TxHash = 'TX_HASH',
  Datetime = 'DATETIME',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `BridgeEvent` aggregates. */
export type BridgeEventsHavingInput = {
  AND?: Maybe<Array<BridgeEventsHavingInput>>;
  OR?: Maybe<Array<BridgeEventsHavingInput>>;
};

/** Methods to use when ordering `BridgeEvent`. */
export enum BridgeEventsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IdentityIdAsc = 'IDENTITY_ID_ASC',
  IdentityIdDesc = 'IDENTITY_ID_DESC',
  RecipientAsc = 'RECIPIENT_ASC',
  RecipientDesc = 'RECIPIENT_DESC',
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  TxHashAsc = 'TX_HASH_ASC',
  TxHashDesc = 'TX_HASH_DESC',
  DatetimeAsc = 'DATETIME_ASC',
  DatetimeDesc = 'DATETIME_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
}

export type Claim = Node & {
  __typename?: 'Claim';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  eventIdx: Scalars['Int'];
  targetId: Scalars['String'];
  issuerId: Scalars['String'];
  issuanceDate: Scalars['BigFloat'];
  lastUpdateDate: Scalars['BigFloat'];
  expiry?: Maybe<Scalars['BigFloat']>;
  filterExpiry: Scalars['BigFloat'];
  type: Scalars['String'];
  jurisdiction?: Maybe<Scalars['String']>;
  scope?: Maybe<Scalars['JSON']>;
  cddId?: Maybe<Scalars['String']>;
  revokeDate?: Maybe<Scalars['BigFloat']>;
  createdBlockId: Scalars['String'];
  updatedBlockId: Scalars['String'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Identity` that is related to this `Claim`. */
  target?: Maybe<Identity>;
  /** Reads a single `Identity` that is related to this `Claim`. */
  issuer?: Maybe<Identity>;
  /** Reads a single `Block` that is related to this `Claim`. */
  createdBlock?: Maybe<Block>;
  /** Reads a single `Block` that is related to this `Claim`. */
  updatedBlock?: Maybe<Block>;
};

export type ClaimAggregates = {
  __typename?: 'ClaimAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `Claim` object types. All fields are combined with a logical ‘and.’ */
export type ClaimFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `eventIdx` field. */
  eventIdx?: Maybe<IntFilter>;
  /** Filter by the object’s `targetId` field. */
  targetId?: Maybe<StringFilter>;
  /** Filter by the object’s `issuerId` field. */
  issuerId?: Maybe<StringFilter>;
  /** Filter by the object’s `issuanceDate` field. */
  issuanceDate?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `lastUpdateDate` field. */
  lastUpdateDate?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `expiry` field. */
  expiry?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `filterExpiry` field. */
  filterExpiry?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `type` field. */
  type?: Maybe<StringFilter>;
  /** Filter by the object’s `jurisdiction` field. */
  jurisdiction?: Maybe<StringFilter>;
  /** Filter by the object’s `scope` field. */
  scope?: Maybe<JsonFilter>;
  /** Filter by the object’s `cddId` field. */
  cddId?: Maybe<StringFilter>;
  /** Filter by the object’s `revokeDate` field. */
  revokeDate?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ClaimFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ClaimFilter>>;
  /** Negates the expression. */
  not?: Maybe<ClaimFilter>;
};

export type ClaimScope = Node & {
  __typename?: 'ClaimScope';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  target: Scalars['String'];
  ticker?: Maybe<Scalars['String']>;
  scope?: Maybe<Scalars['JSON']>;
  createdBlockId: Scalars['String'];
  updatedBlockId: Scalars['String'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Block` that is related to this `ClaimScope`. */
  createdBlock?: Maybe<Block>;
  /** Reads a single `Block` that is related to this `ClaimScope`. */
  updatedBlock?: Maybe<Block>;
};

export type ClaimScopeAggregates = {
  __typename?: 'ClaimScopeAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `ClaimScope` object types. All fields are combined with a logical ‘and.’ */
export type ClaimScopeFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `target` field. */
  target?: Maybe<StringFilter>;
  /** Filter by the object’s `ticker` field. */
  ticker?: Maybe<StringFilter>;
  /** Filter by the object’s `scope` field. */
  scope?: Maybe<JsonFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ClaimScopeFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ClaimScopeFilter>>;
  /** Negates the expression. */
  not?: Maybe<ClaimScopeFilter>;
};

/** A connection to a list of `ClaimScope` values. */
export type ClaimScopesConnection = {
  __typename?: 'ClaimScopesConnection';
  /** A list of `ClaimScope` objects. */
  nodes: Array<Maybe<ClaimScope>>;
  /** A list of edges which contains the `ClaimScope` and cursor to aid in pagination. */
  edges: Array<ClaimScopesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ClaimScope` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<ClaimScopeAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<ClaimScopeAggregates>>;
};

/** A connection to a list of `ClaimScope` values. */
export type ClaimScopesConnectionGroupedAggregatesArgs = {
  groupBy: Array<ClaimScopesGroupBy>;
  having?: Maybe<ClaimScopesHavingInput>;
};

/** A `ClaimScope` edge in the connection. */
export type ClaimScopesEdge = {
  __typename?: 'ClaimScopesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ClaimScope` at the end of the edge. */
  node?: Maybe<ClaimScope>;
};

/** Grouping methods for `ClaimScope` for usage during aggregation. */
export enum ClaimScopesGroupBy {
  Target = 'TARGET',
  Ticker = 'TICKER',
  Scope = 'SCOPE',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `ClaimScope` aggregates. */
export type ClaimScopesHavingInput = {
  AND?: Maybe<Array<ClaimScopesHavingInput>>;
  OR?: Maybe<Array<ClaimScopesHavingInput>>;
};

/** Methods to use when ordering `ClaimScope`. */
export enum ClaimScopesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  TargetAsc = 'TARGET_ASC',
  TargetDesc = 'TARGET_DESC',
  TickerAsc = 'TICKER_ASC',
  TickerDesc = 'TICKER_DESC',
  ScopeAsc = 'SCOPE_ASC',
  ScopeDesc = 'SCOPE_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
}

/** A connection to a list of `Claim` values. */
export type ClaimsConnection = {
  __typename?: 'ClaimsConnection';
  /** A list of `Claim` objects. */
  nodes: Array<Maybe<Claim>>;
  /** A list of edges which contains the `Claim` and cursor to aid in pagination. */
  edges: Array<ClaimsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Claim` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<ClaimAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<ClaimAggregates>>;
};

/** A connection to a list of `Claim` values. */
export type ClaimsConnectionGroupedAggregatesArgs = {
  groupBy: Array<ClaimsGroupBy>;
  having?: Maybe<ClaimsHavingInput>;
};

/** A `Claim` edge in the connection. */
export type ClaimsEdge = {
  __typename?: 'ClaimsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Claim` at the end of the edge. */
  node?: Maybe<Claim>;
};

/** Grouping methods for `Claim` for usage during aggregation. */
export enum ClaimsGroupBy {
  EventIdx = 'EVENT_IDX',
  TargetId = 'TARGET_ID',
  IssuerId = 'ISSUER_ID',
  IssuanceDate = 'ISSUANCE_DATE',
  LastUpdateDate = 'LAST_UPDATE_DATE',
  Expiry = 'EXPIRY',
  FilterExpiry = 'FILTER_EXPIRY',
  Type = 'TYPE',
  Jurisdiction = 'JURISDICTION',
  Scope = 'SCOPE',
  CddId = 'CDD_ID',
  RevokeDate = 'REVOKE_DATE',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `Claim` aggregates. */
export type ClaimsHavingInput = {
  AND?: Maybe<Array<ClaimsHavingInput>>;
  OR?: Maybe<Array<ClaimsHavingInput>>;
};

/** Methods to use when ordering `Claim`. */
export enum ClaimsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  EventIdxAsc = 'EVENT_IDX_ASC',
  EventIdxDesc = 'EVENT_IDX_DESC',
  TargetIdAsc = 'TARGET_ID_ASC',
  TargetIdDesc = 'TARGET_ID_DESC',
  IssuerIdAsc = 'ISSUER_ID_ASC',
  IssuerIdDesc = 'ISSUER_ID_DESC',
  IssuanceDateAsc = 'ISSUANCE_DATE_ASC',
  IssuanceDateDesc = 'ISSUANCE_DATE_DESC',
  LastUpdateDateAsc = 'LAST_UPDATE_DATE_ASC',
  LastUpdateDateDesc = 'LAST_UPDATE_DATE_DESC',
  ExpiryAsc = 'EXPIRY_ASC',
  ExpiryDesc = 'EXPIRY_DESC',
  FilterExpiryAsc = 'FILTER_EXPIRY_ASC',
  FilterExpiryDesc = 'FILTER_EXPIRY_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  JurisdictionAsc = 'JURISDICTION_ASC',
  JurisdictionDesc = 'JURISDICTION_DESC',
  ScopeAsc = 'SCOPE_ASC',
  ScopeDesc = 'SCOPE_DESC',
  CddIdAsc = 'CDD_ID_ASC',
  CddIdDesc = 'CDD_ID_DESC',
  RevokeDateAsc = 'REVOKE_DATE_ASC',
  RevokeDateDesc = 'REVOKE_DATE_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
}

export type Compliance = Node & {
  __typename?: 'Compliance';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  complianceId: Scalars['Int'];
  data: Scalars['String'];
  assetId: Scalars['String'];
  createdBlockId: Scalars['String'];
  updatedBlockId: Scalars['String'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Asset` that is related to this `Compliance`. */
  asset?: Maybe<Asset>;
  /** Reads a single `Block` that is related to this `Compliance`. */
  createdBlock?: Maybe<Block>;
  /** Reads a single `Block` that is related to this `Compliance`. */
  updatedBlock?: Maybe<Block>;
};

export type ComplianceAggregates = {
  __typename?: 'ComplianceAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `Compliance` object types. All fields are combined with a logical ‘and.’ */
export type ComplianceFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `complianceId` field. */
  complianceId?: Maybe<IntFilter>;
  /** Filter by the object’s `data` field. */
  data?: Maybe<StringFilter>;
  /** Filter by the object’s `assetId` field. */
  assetId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ComplianceFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ComplianceFilter>>;
  /** Negates the expression. */
  not?: Maybe<ComplianceFilter>;
};

/** A connection to a list of `Compliance` values. */
export type CompliancesConnection = {
  __typename?: 'CompliancesConnection';
  /** A list of `Compliance` objects. */
  nodes: Array<Maybe<Compliance>>;
  /** A list of edges which contains the `Compliance` and cursor to aid in pagination. */
  edges: Array<CompliancesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Compliance` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<ComplianceAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<ComplianceAggregates>>;
};

/** A connection to a list of `Compliance` values. */
export type CompliancesConnectionGroupedAggregatesArgs = {
  groupBy: Array<CompliancesGroupBy>;
  having?: Maybe<CompliancesHavingInput>;
};

/** A `Compliance` edge in the connection. */
export type CompliancesEdge = {
  __typename?: 'CompliancesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Compliance` at the end of the edge. */
  node?: Maybe<Compliance>;
};

/** Grouping methods for `Compliance` for usage during aggregation. */
export enum CompliancesGroupBy {
  ComplianceId = 'COMPLIANCE_ID',
  Data = 'DATA',
  AssetId = 'ASSET_ID',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `Compliance` aggregates. */
export type CompliancesHavingInput = {
  AND?: Maybe<Array<CompliancesHavingInput>>;
  OR?: Maybe<Array<CompliancesHavingInput>>;
};

/** Methods to use when ordering `Compliance`. */
export enum CompliancesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ComplianceIdAsc = 'COMPLIANCE_ID_ASC',
  ComplianceIdDesc = 'COMPLIANCE_ID_DESC',
  DataAsc = 'DATA_ASC',
  DataDesc = 'DATA_DESC',
  AssetIdAsc = 'ASSET_ID_ASC',
  AssetIdDesc = 'ASSET_ID_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
}

/** A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’ */
export type DatetimeFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Datetime']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Datetime']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Datetime']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Datetime']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Datetime']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Datetime']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Datetime']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Datetime']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Datetime']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Datetime']>;
};

export type Debug = Node & {
  __typename?: 'Debug';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  line?: Maybe<Scalars['String']>;
  context?: Maybe<Scalars['String']>;
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
};

export type DebugAggregates = {
  __typename?: 'DebugAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `Debug` object types. All fields are combined with a logical ‘and.’ */
export type DebugFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `line` field. */
  line?: Maybe<StringFilter>;
  /** Filter by the object’s `context` field. */
  context?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<DebugFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<DebugFilter>>;
  /** Negates the expression. */
  not?: Maybe<DebugFilter>;
};

/** A connection to a list of `Debug` values. */
export type DebugsConnection = {
  __typename?: 'DebugsConnection';
  /** A list of `Debug` objects. */
  nodes: Array<Maybe<Debug>>;
  /** A list of edges which contains the `Debug` and cursor to aid in pagination. */
  edges: Array<DebugsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Debug` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<DebugAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<DebugAggregates>>;
};

/** A connection to a list of `Debug` values. */
export type DebugsConnectionGroupedAggregatesArgs = {
  groupBy: Array<DebugsGroupBy>;
  having?: Maybe<DebugsHavingInput>;
};

/** A `Debug` edge in the connection. */
export type DebugsEdge = {
  __typename?: 'DebugsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Debug` at the end of the edge. */
  node?: Maybe<Debug>;
};

/** Grouping methods for `Debug` for usage during aggregation. */
export enum DebugsGroupBy {
  Line = 'LINE',
  Context = 'CONTEXT',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `Debug` aggregates. */
export type DebugsHavingInput = {
  AND?: Maybe<Array<DebugsHavingInput>>;
  OR?: Maybe<Array<DebugsHavingInput>>;
};

/** Methods to use when ordering `Debug`. */
export enum DebugsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LineAsc = 'LINE_ASC',
  LineDesc = 'LINE_DESC',
  ContextAsc = 'CONTEXT_ASC',
  ContextDesc = 'CONTEXT_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
}

export type Distribution = Node & {
  __typename?: 'Distribution';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  identityId: Scalars['String'];
  localId: Scalars['Int'];
  assetId: Scalars['String'];
  portfolioId: Scalars['String'];
  currency: Scalars['String'];
  perShare: Scalars['BigFloat'];
  amount: Scalars['BigFloat'];
  remaining: Scalars['BigFloat'];
  paymentAt: Scalars['BigFloat'];
  expiresAt?: Maybe<Scalars['BigFloat']>;
  taxes: Scalars['BigFloat'];
  createdBlockId: Scalars['String'];
  updatedBlockId: Scalars['String'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Identity` that is related to this `Distribution`. */
  identity?: Maybe<Identity>;
  /** Reads a single `Asset` that is related to this `Distribution`. */
  asset?: Maybe<Asset>;
  /** Reads a single `Portfolio` that is related to this `Distribution`. */
  portfolio?: Maybe<Portfolio>;
  /** Reads a single `Block` that is related to this `Distribution`. */
  createdBlock?: Maybe<Block>;
  /** Reads a single `Block` that is related to this `Distribution`. */
  updatedBlock?: Maybe<Block>;
  /** Reads and enables pagination through a set of `DistributionPayment`. */
  distributionPayments: DistributionPaymentsConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByDistributionPaymentDistributionIdAndTargetId: DistributionIdentitiesByDistributionPaymentDistributionIdAndTargetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByDistributionPaymentDistributionIdAndCreatedBlockId: DistributionBlocksByDistributionPaymentDistributionIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByDistributionPaymentDistributionIdAndUpdatedBlockId: DistributionBlocksByDistributionPaymentDistributionIdAndUpdatedBlockIdManyToManyConnection;
};

export type DistributionDistributionPaymentsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<DistributionPaymentsOrderBy>>;
  filter?: Maybe<DistributionPaymentFilter>;
};

export type DistributionIdentitiesByDistributionPaymentDistributionIdAndTargetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type DistributionBlocksByDistributionPaymentDistributionIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type DistributionBlocksByDistributionPaymentDistributionIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type DistributionAggregates = {
  __typename?: 'DistributionAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A connection to a list of `Block` values, with data from `DistributionPayment`. */
export type DistributionBlocksByDistributionPaymentDistributionIdAndCreatedBlockIdManyToManyConnection =
  {
    __typename?: 'DistributionBlocksByDistributionPaymentDistributionIdAndCreatedBlockIdManyToManyConnection';
    /** A list of `Block` objects. */
    nodes: Array<Maybe<Block>>;
    /** A list of edges which contains the `Block`, info from the `DistributionPayment`, and the cursor to aid in pagination. */
    edges: Array<DistributionBlocksByDistributionPaymentDistributionIdAndCreatedBlockIdManyToManyEdge>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Block` you could get from the connection. */
    totalCount: Scalars['Int'];
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<BlockAggregates>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<BlockAggregates>>;
  };

/** A connection to a list of `Block` values, with data from `DistributionPayment`. */
export type DistributionBlocksByDistributionPaymentDistributionIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `DistributionPayment`. */
export type DistributionBlocksByDistributionPaymentDistributionIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'DistributionBlocksByDistributionPaymentDistributionIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `DistributionPayment`. */
  distributionPaymentsByCreatedBlockId: DistributionPaymentsConnection;
};

/** A `Block` edge in the connection, with data from `DistributionPayment`. */
export type DistributionBlocksByDistributionPaymentDistributionIdAndCreatedBlockIdManyToManyEdgeDistributionPaymentsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<DistributionPaymentsOrderBy>>;
    filter?: Maybe<DistributionPaymentFilter>;
  };

/** A connection to a list of `Block` values, with data from `DistributionPayment`. */
export type DistributionBlocksByDistributionPaymentDistributionIdAndUpdatedBlockIdManyToManyConnection =
  {
    __typename?: 'DistributionBlocksByDistributionPaymentDistributionIdAndUpdatedBlockIdManyToManyConnection';
    /** A list of `Block` objects. */
    nodes: Array<Maybe<Block>>;
    /** A list of edges which contains the `Block`, info from the `DistributionPayment`, and the cursor to aid in pagination. */
    edges: Array<DistributionBlocksByDistributionPaymentDistributionIdAndUpdatedBlockIdManyToManyEdge>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Block` you could get from the connection. */
    totalCount: Scalars['Int'];
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<BlockAggregates>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<BlockAggregates>>;
  };

/** A connection to a list of `Block` values, with data from `DistributionPayment`. */
export type DistributionBlocksByDistributionPaymentDistributionIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `DistributionPayment`. */
export type DistributionBlocksByDistributionPaymentDistributionIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'DistributionBlocksByDistributionPaymentDistributionIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `DistributionPayment`. */
  distributionPaymentsByUpdatedBlockId: DistributionPaymentsConnection;
};

/** A `Block` edge in the connection, with data from `DistributionPayment`. */
export type DistributionBlocksByDistributionPaymentDistributionIdAndUpdatedBlockIdManyToManyEdgeDistributionPaymentsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<DistributionPaymentsOrderBy>>;
    filter?: Maybe<DistributionPaymentFilter>;
  };

/** A filter to be used against `Distribution` object types. All fields are combined with a logical ‘and.’ */
export type DistributionFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `identityId` field. */
  identityId?: Maybe<StringFilter>;
  /** Filter by the object’s `localId` field. */
  localId?: Maybe<IntFilter>;
  /** Filter by the object’s `assetId` field. */
  assetId?: Maybe<StringFilter>;
  /** Filter by the object’s `portfolioId` field. */
  portfolioId?: Maybe<StringFilter>;
  /** Filter by the object’s `currency` field. */
  currency?: Maybe<StringFilter>;
  /** Filter by the object’s `perShare` field. */
  perShare?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `amount` field. */
  amount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `remaining` field. */
  remaining?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `paymentAt` field. */
  paymentAt?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `expiresAt` field. */
  expiresAt?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `taxes` field. */
  taxes?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<DistributionFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<DistributionFilter>>;
  /** Negates the expression. */
  not?: Maybe<DistributionFilter>;
};

/** A connection to a list of `Identity` values, with data from `DistributionPayment`. */
export type DistributionIdentitiesByDistributionPaymentDistributionIdAndTargetIdManyToManyConnection =
  {
    __typename?: 'DistributionIdentitiesByDistributionPaymentDistributionIdAndTargetIdManyToManyConnection';
    /** A list of `Identity` objects. */
    nodes: Array<Maybe<Identity>>;
    /** A list of edges which contains the `Identity`, info from the `DistributionPayment`, and the cursor to aid in pagination. */
    edges: Array<DistributionIdentitiesByDistributionPaymentDistributionIdAndTargetIdManyToManyEdge>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Identity` you could get from the connection. */
    totalCount: Scalars['Int'];
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<IdentityAggregates>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<IdentityAggregates>>;
  };

/** A connection to a list of `Identity` values, with data from `DistributionPayment`. */
export type DistributionIdentitiesByDistributionPaymentDistributionIdAndTargetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `DistributionPayment`. */
export type DistributionIdentitiesByDistributionPaymentDistributionIdAndTargetIdManyToManyEdge = {
  __typename?: 'DistributionIdentitiesByDistributionPaymentDistributionIdAndTargetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `DistributionPayment`. */
  distributionPaymentsByTargetId: DistributionPaymentsConnection;
};

/** A `Identity` edge in the connection, with data from `DistributionPayment`. */
export type DistributionIdentitiesByDistributionPaymentDistributionIdAndTargetIdManyToManyEdgeDistributionPaymentsByTargetIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<DistributionPaymentsOrderBy>>;
    filter?: Maybe<DistributionPaymentFilter>;
  };

export type DistributionPayment = Node & {
  __typename?: 'DistributionPayment';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  distributionId: Scalars['String'];
  targetId: Scalars['String'];
  eventId: Scalars['String'];
  amount: Scalars['BigFloat'];
  tax: Scalars['BigFloat'];
  reclaimed: Scalars['Boolean'];
  datetime: Scalars['Datetime'];
  createdBlockId: Scalars['String'];
  updatedBlockId: Scalars['String'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Distribution` that is related to this `DistributionPayment`. */
  distribution?: Maybe<Distribution>;
  /** Reads a single `Identity` that is related to this `DistributionPayment`. */
  target?: Maybe<Identity>;
  /** Reads a single `Block` that is related to this `DistributionPayment`. */
  createdBlock?: Maybe<Block>;
  /** Reads a single `Block` that is related to this `DistributionPayment`. */
  updatedBlock?: Maybe<Block>;
};

export type DistributionPaymentAggregates = {
  __typename?: 'DistributionPaymentAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `DistributionPayment` object types. All fields are combined with a logical ‘and.’ */
export type DistributionPaymentFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `distributionId` field. */
  distributionId?: Maybe<StringFilter>;
  /** Filter by the object’s `targetId` field. */
  targetId?: Maybe<StringFilter>;
  /** Filter by the object’s `eventId` field. */
  eventId?: Maybe<StringFilter>;
  /** Filter by the object’s `amount` field. */
  amount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `tax` field. */
  tax?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `reclaimed` field. */
  reclaimed?: Maybe<BooleanFilter>;
  /** Filter by the object’s `datetime` field. */
  datetime?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<DistributionPaymentFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<DistributionPaymentFilter>>;
  /** Negates the expression. */
  not?: Maybe<DistributionPaymentFilter>;
};

/** A connection to a list of `DistributionPayment` values. */
export type DistributionPaymentsConnection = {
  __typename?: 'DistributionPaymentsConnection';
  /** A list of `DistributionPayment` objects. */
  nodes: Array<Maybe<DistributionPayment>>;
  /** A list of edges which contains the `DistributionPayment` and cursor to aid in pagination. */
  edges: Array<DistributionPaymentsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DistributionPayment` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<DistributionPaymentAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<DistributionPaymentAggregates>>;
};

/** A connection to a list of `DistributionPayment` values. */
export type DistributionPaymentsConnectionGroupedAggregatesArgs = {
  groupBy: Array<DistributionPaymentsGroupBy>;
  having?: Maybe<DistributionPaymentsHavingInput>;
};

/** A `DistributionPayment` edge in the connection. */
export type DistributionPaymentsEdge = {
  __typename?: 'DistributionPaymentsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `DistributionPayment` at the end of the edge. */
  node?: Maybe<DistributionPayment>;
};

/** Grouping methods for `DistributionPayment` for usage during aggregation. */
export enum DistributionPaymentsGroupBy {
  DistributionId = 'DISTRIBUTION_ID',
  TargetId = 'TARGET_ID',
  EventId = 'EVENT_ID',
  Amount = 'AMOUNT',
  Tax = 'TAX',
  Reclaimed = 'RECLAIMED',
  Datetime = 'DATETIME',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `DistributionPayment` aggregates. */
export type DistributionPaymentsHavingInput = {
  AND?: Maybe<Array<DistributionPaymentsHavingInput>>;
  OR?: Maybe<Array<DistributionPaymentsHavingInput>>;
};

/** Methods to use when ordering `DistributionPayment`. */
export enum DistributionPaymentsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  DistributionIdAsc = 'DISTRIBUTION_ID_ASC',
  DistributionIdDesc = 'DISTRIBUTION_ID_DESC',
  TargetIdAsc = 'TARGET_ID_ASC',
  TargetIdDesc = 'TARGET_ID_DESC',
  EventIdAsc = 'EVENT_ID_ASC',
  EventIdDesc = 'EVENT_ID_DESC',
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  TaxAsc = 'TAX_ASC',
  TaxDesc = 'TAX_DESC',
  ReclaimedAsc = 'RECLAIMED_ASC',
  ReclaimedDesc = 'RECLAIMED_DESC',
  DatetimeAsc = 'DATETIME_ASC',
  DatetimeDesc = 'DATETIME_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
}

/** A connection to a list of `Distribution` values. */
export type DistributionsConnection = {
  __typename?: 'DistributionsConnection';
  /** A list of `Distribution` objects. */
  nodes: Array<Maybe<Distribution>>;
  /** A list of edges which contains the `Distribution` and cursor to aid in pagination. */
  edges: Array<DistributionsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Distribution` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<DistributionAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<DistributionAggregates>>;
};

/** A connection to a list of `Distribution` values. */
export type DistributionsConnectionGroupedAggregatesArgs = {
  groupBy: Array<DistributionsGroupBy>;
  having?: Maybe<DistributionsHavingInput>;
};

/** A `Distribution` edge in the connection. */
export type DistributionsEdge = {
  __typename?: 'DistributionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Distribution` at the end of the edge. */
  node?: Maybe<Distribution>;
};

/** Grouping methods for `Distribution` for usage during aggregation. */
export enum DistributionsGroupBy {
  IdentityId = 'IDENTITY_ID',
  LocalId = 'LOCAL_ID',
  AssetId = 'ASSET_ID',
  PortfolioId = 'PORTFOLIO_ID',
  Currency = 'CURRENCY',
  PerShare = 'PER_SHARE',
  Amount = 'AMOUNT',
  Remaining = 'REMAINING',
  PaymentAt = 'PAYMENT_AT',
  ExpiresAt = 'EXPIRES_AT',
  Taxes = 'TAXES',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `Distribution` aggregates. */
export type DistributionsHavingInput = {
  AND?: Maybe<Array<DistributionsHavingInput>>;
  OR?: Maybe<Array<DistributionsHavingInput>>;
};

/** Methods to use when ordering `Distribution`. */
export enum DistributionsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IdentityIdAsc = 'IDENTITY_ID_ASC',
  IdentityIdDesc = 'IDENTITY_ID_DESC',
  LocalIdAsc = 'LOCAL_ID_ASC',
  LocalIdDesc = 'LOCAL_ID_DESC',
  AssetIdAsc = 'ASSET_ID_ASC',
  AssetIdDesc = 'ASSET_ID_DESC',
  PortfolioIdAsc = 'PORTFOLIO_ID_ASC',
  PortfolioIdDesc = 'PORTFOLIO_ID_DESC',
  CurrencyAsc = 'CURRENCY_ASC',
  CurrencyDesc = 'CURRENCY_DESC',
  PerShareAsc = 'PER_SHARE_ASC',
  PerShareDesc = 'PER_SHARE_DESC',
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  RemainingAsc = 'REMAINING_ASC',
  RemainingDesc = 'REMAINING_DESC',
  PaymentAtAsc = 'PAYMENT_AT_ASC',
  PaymentAtDesc = 'PAYMENT_AT_DESC',
  ExpiresAtAsc = 'EXPIRES_AT_ASC',
  ExpiresAtDesc = 'EXPIRES_AT_DESC',
  TaxesAsc = 'TAXES_ASC',
  TaxesDesc = 'TAXES_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  DistributionPaymentsCountAsc = 'DISTRIBUTION_PAYMENTS_COUNT_ASC',
  DistributionPaymentsCountDesc = 'DISTRIBUTION_PAYMENTS_COUNT_DESC',
}

export type Event = Node & {
  __typename?: 'Event';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  blockId: Scalars['String'];
  eventIdx: Scalars['Int'];
  extrinsicIdx?: Maybe<Scalars['Int']>;
  specVersionId: Scalars['Int'];
  moduleId: Scalars['String'];
  eventId: Scalars['String'];
  attributesTxt: Scalars['String'];
  eventArg0?: Maybe<Scalars['String']>;
  eventArg1?: Maybe<Scalars['String']>;
  eventArg2?: Maybe<Scalars['String']>;
  eventArg3?: Maybe<Scalars['String']>;
  claimType?: Maybe<Scalars['String']>;
  claimScope?: Maybe<Scalars['String']>;
  claimIssuer?: Maybe<Scalars['String']>;
  claimExpiry?: Maybe<Scalars['String']>;
  corporateActionTicker?: Maybe<Scalars['String']>;
  fundraiserOfferingAsset?: Maybe<Scalars['String']>;
  transferTo?: Maybe<Scalars['String']>;
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Block` that is related to this `Event`. */
  block?: Maybe<Block>;
};

export type EventAggregates = {
  __typename?: 'EventAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `Event` object types. All fields are combined with a logical ‘and.’ */
export type EventFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `blockId` field. */
  blockId?: Maybe<StringFilter>;
  /** Filter by the object’s `eventIdx` field. */
  eventIdx?: Maybe<IntFilter>;
  /** Filter by the object’s `extrinsicIdx` field. */
  extrinsicIdx?: Maybe<IntFilter>;
  /** Filter by the object’s `specVersionId` field. */
  specVersionId?: Maybe<IntFilter>;
  /** Filter by the object’s `moduleId` field. */
  moduleId?: Maybe<StringFilter>;
  /** Filter by the object’s `eventId` field. */
  eventId?: Maybe<StringFilter>;
  /** Filter by the object’s `attributesTxt` field. */
  attributesTxt?: Maybe<StringFilter>;
  /** Filter by the object’s `eventArg0` field. */
  eventArg0?: Maybe<StringFilter>;
  /** Filter by the object’s `eventArg1` field. */
  eventArg1?: Maybe<StringFilter>;
  /** Filter by the object’s `eventArg2` field. */
  eventArg2?: Maybe<StringFilter>;
  /** Filter by the object’s `eventArg3` field. */
  eventArg3?: Maybe<StringFilter>;
  /** Filter by the object’s `claimType` field. */
  claimType?: Maybe<StringFilter>;
  /** Filter by the object’s `claimScope` field. */
  claimScope?: Maybe<StringFilter>;
  /** Filter by the object’s `claimIssuer` field. */
  claimIssuer?: Maybe<StringFilter>;
  /** Filter by the object’s `claimExpiry` field. */
  claimExpiry?: Maybe<StringFilter>;
  /** Filter by the object’s `corporateActionTicker` field. */
  corporateActionTicker?: Maybe<StringFilter>;
  /** Filter by the object’s `fundraiserOfferingAsset` field. */
  fundraiserOfferingAsset?: Maybe<StringFilter>;
  /** Filter by the object’s `transferTo` field. */
  transferTo?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<EventFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<EventFilter>>;
  /** Negates the expression. */
  not?: Maybe<EventFilter>;
};

/** A connection to a list of `Event` values. */
export type EventsConnection = {
  __typename?: 'EventsConnection';
  /** A list of `Event` objects. */
  nodes: Array<Maybe<Event>>;
  /** A list of edges which contains the `Event` and cursor to aid in pagination. */
  edges: Array<EventsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Event` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<EventAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<EventAggregates>>;
};

/** A connection to a list of `Event` values. */
export type EventsConnectionGroupedAggregatesArgs = {
  groupBy: Array<EventsGroupBy>;
  having?: Maybe<EventsHavingInput>;
};

/** A `Event` edge in the connection. */
export type EventsEdge = {
  __typename?: 'EventsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Event` at the end of the edge. */
  node?: Maybe<Event>;
};

/** Grouping methods for `Event` for usage during aggregation. */
export enum EventsGroupBy {
  BlockId = 'BLOCK_ID',
  EventIdx = 'EVENT_IDX',
  ExtrinsicIdx = 'EXTRINSIC_IDX',
  SpecVersionId = 'SPEC_VERSION_ID',
  ModuleId = 'MODULE_ID',
  EventId = 'EVENT_ID',
  AttributesTxt = 'ATTRIBUTES_TXT',
  EventArg_0 = 'EVENT_ARG_0',
  EventArg_1 = 'EVENT_ARG_1',
  EventArg_2 = 'EVENT_ARG_2',
  EventArg_3 = 'EVENT_ARG_3',
  ClaimType = 'CLAIM_TYPE',
  ClaimScope = 'CLAIM_SCOPE',
  ClaimIssuer = 'CLAIM_ISSUER',
  ClaimExpiry = 'CLAIM_EXPIRY',
  CorporateActionTicker = 'CORPORATE_ACTION_TICKER',
  FundraiserOfferingAsset = 'FUNDRAISER_OFFERING_ASSET',
  TransferTo = 'TRANSFER_TO',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `Event` aggregates. */
export type EventsHavingInput = {
  AND?: Maybe<Array<EventsHavingInput>>;
  OR?: Maybe<Array<EventsHavingInput>>;
};

/** Methods to use when ordering `Event`. */
export enum EventsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  BlockIdAsc = 'BLOCK_ID_ASC',
  BlockIdDesc = 'BLOCK_ID_DESC',
  EventIdxAsc = 'EVENT_IDX_ASC',
  EventIdxDesc = 'EVENT_IDX_DESC',
  ExtrinsicIdxAsc = 'EXTRINSIC_IDX_ASC',
  ExtrinsicIdxDesc = 'EXTRINSIC_IDX_DESC',
  SpecVersionIdAsc = 'SPEC_VERSION_ID_ASC',
  SpecVersionIdDesc = 'SPEC_VERSION_ID_DESC',
  ModuleIdAsc = 'MODULE_ID_ASC',
  ModuleIdDesc = 'MODULE_ID_DESC',
  EventIdAsc = 'EVENT_ID_ASC',
  EventIdDesc = 'EVENT_ID_DESC',
  AttributesTxtAsc = 'ATTRIBUTES_TXT_ASC',
  AttributesTxtDesc = 'ATTRIBUTES_TXT_DESC',
  EventArg_0Asc = 'EVENT_ARG_0_ASC',
  EventArg_0Desc = 'EVENT_ARG_0_DESC',
  EventArg_1Asc = 'EVENT_ARG_1_ASC',
  EventArg_1Desc = 'EVENT_ARG_1_DESC',
  EventArg_2Asc = 'EVENT_ARG_2_ASC',
  EventArg_2Desc = 'EVENT_ARG_2_DESC',
  EventArg_3Asc = 'EVENT_ARG_3_ASC',
  EventArg_3Desc = 'EVENT_ARG_3_DESC',
  ClaimTypeAsc = 'CLAIM_TYPE_ASC',
  ClaimTypeDesc = 'CLAIM_TYPE_DESC',
  ClaimScopeAsc = 'CLAIM_SCOPE_ASC',
  ClaimScopeDesc = 'CLAIM_SCOPE_DESC',
  ClaimIssuerAsc = 'CLAIM_ISSUER_ASC',
  ClaimIssuerDesc = 'CLAIM_ISSUER_DESC',
  ClaimExpiryAsc = 'CLAIM_EXPIRY_ASC',
  ClaimExpiryDesc = 'CLAIM_EXPIRY_DESC',
  CorporateActionTickerAsc = 'CORPORATE_ACTION_TICKER_ASC',
  CorporateActionTickerDesc = 'CORPORATE_ACTION_TICKER_DESC',
  FundraiserOfferingAssetAsc = 'FUNDRAISER_OFFERING_ASSET_ASC',
  FundraiserOfferingAssetDesc = 'FUNDRAISER_OFFERING_ASSET_DESC',
  TransferToAsc = 'TRANSFER_TO_ASC',
  TransferToDesc = 'TRANSFER_TO_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
}

export type Extrinsic = Node & {
  __typename?: 'Extrinsic';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  blockId: Scalars['String'];
  extrinsicIdx: Scalars['Int'];
  extrinsicLength: Scalars['Int'];
  signed: Scalars['Int'];
  signedbyAddress: Scalars['Int'];
  address?: Maybe<Scalars['String']>;
  moduleId: Scalars['String'];
  callId: Scalars['String'];
  paramsTxt: Scalars['String'];
  success: Scalars['Int'];
  nonce?: Maybe<Scalars['Int']>;
  extrinsicHash?: Maybe<Scalars['String']>;
  specVersionId: Scalars['Int'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Block` that is related to this `Extrinsic`. */
  block?: Maybe<Block>;
};

export type ExtrinsicAggregates = {
  __typename?: 'ExtrinsicAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `Extrinsic` object types. All fields are combined with a logical ‘and.’ */
export type ExtrinsicFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `blockId` field. */
  blockId?: Maybe<StringFilter>;
  /** Filter by the object’s `extrinsicIdx` field. */
  extrinsicIdx?: Maybe<IntFilter>;
  /** Filter by the object’s `extrinsicLength` field. */
  extrinsicLength?: Maybe<IntFilter>;
  /** Filter by the object’s `signed` field. */
  signed?: Maybe<IntFilter>;
  /** Filter by the object’s `signedbyAddress` field. */
  signedbyAddress?: Maybe<IntFilter>;
  /** Filter by the object’s `address` field. */
  address?: Maybe<StringFilter>;
  /** Filter by the object’s `moduleId` field. */
  moduleId?: Maybe<StringFilter>;
  /** Filter by the object’s `callId` field. */
  callId?: Maybe<StringFilter>;
  /** Filter by the object’s `paramsTxt` field. */
  paramsTxt?: Maybe<StringFilter>;
  /** Filter by the object’s `success` field. */
  success?: Maybe<IntFilter>;
  /** Filter by the object’s `nonce` field. */
  nonce?: Maybe<IntFilter>;
  /** Filter by the object’s `extrinsicHash` field. */
  extrinsicHash?: Maybe<StringFilter>;
  /** Filter by the object’s `specVersionId` field. */
  specVersionId?: Maybe<IntFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ExtrinsicFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ExtrinsicFilter>>;
  /** Negates the expression. */
  not?: Maybe<ExtrinsicFilter>;
};

/** A connection to a list of `Extrinsic` values. */
export type ExtrinsicsConnection = {
  __typename?: 'ExtrinsicsConnection';
  /** A list of `Extrinsic` objects. */
  nodes: Array<Maybe<Extrinsic>>;
  /** A list of edges which contains the `Extrinsic` and cursor to aid in pagination. */
  edges: Array<ExtrinsicsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Extrinsic` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<ExtrinsicAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<ExtrinsicAggregates>>;
};

/** A connection to a list of `Extrinsic` values. */
export type ExtrinsicsConnectionGroupedAggregatesArgs = {
  groupBy: Array<ExtrinsicsGroupBy>;
  having?: Maybe<ExtrinsicsHavingInput>;
};

/** A `Extrinsic` edge in the connection. */
export type ExtrinsicsEdge = {
  __typename?: 'ExtrinsicsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Extrinsic` at the end of the edge. */
  node?: Maybe<Extrinsic>;
};

/** Grouping methods for `Extrinsic` for usage during aggregation. */
export enum ExtrinsicsGroupBy {
  BlockId = 'BLOCK_ID',
  ExtrinsicIdx = 'EXTRINSIC_IDX',
  ExtrinsicLength = 'EXTRINSIC_LENGTH',
  Signed = 'SIGNED',
  SignedbyAddress = 'SIGNEDBY_ADDRESS',
  Address = 'ADDRESS',
  ModuleId = 'MODULE_ID',
  CallId = 'CALL_ID',
  ParamsTxt = 'PARAMS_TXT',
  Success = 'SUCCESS',
  Nonce = 'NONCE',
  ExtrinsicHash = 'EXTRINSIC_HASH',
  SpecVersionId = 'SPEC_VERSION_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `Extrinsic` aggregates. */
export type ExtrinsicsHavingInput = {
  AND?: Maybe<Array<ExtrinsicsHavingInput>>;
  OR?: Maybe<Array<ExtrinsicsHavingInput>>;
};

/** Methods to use when ordering `Extrinsic`. */
export enum ExtrinsicsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  BlockIdAsc = 'BLOCK_ID_ASC',
  BlockIdDesc = 'BLOCK_ID_DESC',
  ExtrinsicIdxAsc = 'EXTRINSIC_IDX_ASC',
  ExtrinsicIdxDesc = 'EXTRINSIC_IDX_DESC',
  ExtrinsicLengthAsc = 'EXTRINSIC_LENGTH_ASC',
  ExtrinsicLengthDesc = 'EXTRINSIC_LENGTH_DESC',
  SignedAsc = 'SIGNED_ASC',
  SignedDesc = 'SIGNED_DESC',
  SignedbyAddressAsc = 'SIGNEDBY_ADDRESS_ASC',
  SignedbyAddressDesc = 'SIGNEDBY_ADDRESS_DESC',
  AddressAsc = 'ADDRESS_ASC',
  AddressDesc = 'ADDRESS_DESC',
  ModuleIdAsc = 'MODULE_ID_ASC',
  ModuleIdDesc = 'MODULE_ID_DESC',
  CallIdAsc = 'CALL_ID_ASC',
  CallIdDesc = 'CALL_ID_DESC',
  ParamsTxtAsc = 'PARAMS_TXT_ASC',
  ParamsTxtDesc = 'PARAMS_TXT_DESC',
  SuccessAsc = 'SUCCESS_ASC',
  SuccessDesc = 'SUCCESS_DESC',
  NonceAsc = 'NONCE_ASC',
  NonceDesc = 'NONCE_DESC',
  ExtrinsicHashAsc = 'EXTRINSIC_HASH_ASC',
  ExtrinsicHashDesc = 'EXTRINSIC_HASH_DESC',
  SpecVersionIdAsc = 'SPEC_VERSION_ID_ASC',
  SpecVersionIdDesc = 'SPEC_VERSION_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
}

export type FoundType = Node & {
  __typename?: 'FoundType';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  rawType: Scalars['String'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
};

export type FoundTypeAggregates = {
  __typename?: 'FoundTypeAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `FoundType` object types. All fields are combined with a logical ‘and.’ */
export type FoundTypeFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `rawType` field. */
  rawType?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<FoundTypeFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<FoundTypeFilter>>;
  /** Negates the expression. */
  not?: Maybe<FoundTypeFilter>;
};

/** A connection to a list of `FoundType` values. */
export type FoundTypesConnection = {
  __typename?: 'FoundTypesConnection';
  /** A list of `FoundType` objects. */
  nodes: Array<Maybe<FoundType>>;
  /** A list of edges which contains the `FoundType` and cursor to aid in pagination. */
  edges: Array<FoundTypesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FoundType` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<FoundTypeAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<FoundTypeAggregates>>;
};

/** A connection to a list of `FoundType` values. */
export type FoundTypesConnectionGroupedAggregatesArgs = {
  groupBy: Array<FoundTypesGroupBy>;
  having?: Maybe<FoundTypesHavingInput>;
};

/** A `FoundType` edge in the connection. */
export type FoundTypesEdge = {
  __typename?: 'FoundTypesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `FoundType` at the end of the edge. */
  node?: Maybe<FoundType>;
};

/** Grouping methods for `FoundType` for usage during aggregation. */
export enum FoundTypesGroupBy {
  RawType = 'RAW_TYPE',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `FoundType` aggregates. */
export type FoundTypesHavingInput = {
  AND?: Maybe<Array<FoundTypesHavingInput>>;
  OR?: Maybe<Array<FoundTypesHavingInput>>;
};

/** Methods to use when ordering `FoundType`. */
export enum FoundTypesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  RawTypeAsc = 'RAW_TYPE_ASC',
  RawTypeDesc = 'RAW_TYPE_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
}

export type Funding = Node & {
  __typename?: 'Funding';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  assetId: Scalars['String'];
  fundingRound: Scalars['String'];
  amount: Scalars['BigFloat'];
  totalFundingAmount: Scalars['BigFloat'];
  datetime: Scalars['Datetime'];
  createdBlockId: Scalars['String'];
  updatedBlockId: Scalars['String'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Asset` that is related to this `Funding`. */
  asset?: Maybe<Asset>;
  /** Reads a single `Block` that is related to this `Funding`. */
  createdBlock?: Maybe<Block>;
  /** Reads a single `Block` that is related to this `Funding`. */
  updatedBlock?: Maybe<Block>;
};

export type FundingAggregates = {
  __typename?: 'FundingAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `Funding` object types. All fields are combined with a logical ‘and.’ */
export type FundingFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `assetId` field. */
  assetId?: Maybe<StringFilter>;
  /** Filter by the object’s `fundingRound` field. */
  fundingRound?: Maybe<StringFilter>;
  /** Filter by the object’s `amount` field. */
  amount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `totalFundingAmount` field. */
  totalFundingAmount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `datetime` field. */
  datetime?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<FundingFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<FundingFilter>>;
  /** Negates the expression. */
  not?: Maybe<FundingFilter>;
};

/** A connection to a list of `Funding` values. */
export type FundingsConnection = {
  __typename?: 'FundingsConnection';
  /** A list of `Funding` objects. */
  nodes: Array<Maybe<Funding>>;
  /** A list of edges which contains the `Funding` and cursor to aid in pagination. */
  edges: Array<FundingsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Funding` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<FundingAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<FundingAggregates>>;
};

/** A connection to a list of `Funding` values. */
export type FundingsConnectionGroupedAggregatesArgs = {
  groupBy: Array<FundingsGroupBy>;
  having?: Maybe<FundingsHavingInput>;
};

/** A `Funding` edge in the connection. */
export type FundingsEdge = {
  __typename?: 'FundingsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Funding` at the end of the edge. */
  node?: Maybe<Funding>;
};

/** Grouping methods for `Funding` for usage during aggregation. */
export enum FundingsGroupBy {
  AssetId = 'ASSET_ID',
  FundingRound = 'FUNDING_ROUND',
  Amount = 'AMOUNT',
  TotalFundingAmount = 'TOTAL_FUNDING_AMOUNT',
  Datetime = 'DATETIME',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `Funding` aggregates. */
export type FundingsHavingInput = {
  AND?: Maybe<Array<FundingsHavingInput>>;
  OR?: Maybe<Array<FundingsHavingInput>>;
};

/** Methods to use when ordering `Funding`. */
export enum FundingsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  AssetIdAsc = 'ASSET_ID_ASC',
  AssetIdDesc = 'ASSET_ID_DESC',
  FundingRoundAsc = 'FUNDING_ROUND_ASC',
  FundingRoundDesc = 'FUNDING_ROUND_DESC',
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  TotalFundingAmountAsc = 'TOTAL_FUNDING_AMOUNT_ASC',
  TotalFundingAmountDesc = 'TOTAL_FUNDING_AMOUNT_DESC',
  DatetimeAsc = 'DATETIME_ASC',
  DatetimeDesc = 'DATETIME_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
}

/** A connection to a list of `Identity` values. */
export type IdentitiesConnection = {
  __typename?: 'IdentitiesConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity` and cursor to aid in pagination. */
  edges: Array<IdentitiesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values. */
export type IdentitiesConnectionGroupedAggregatesArgs = {
  groupBy: Array<IdentitiesGroupBy>;
  having?: Maybe<IdentitiesHavingInput>;
};

/** A `Identity` edge in the connection. */
export type IdentitiesEdge = {
  __typename?: 'IdentitiesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
};

/** Grouping methods for `Identity` for usage during aggregation. */
export enum IdentitiesGroupBy {
  PrimaryAccount = 'PRIMARY_ACCOUNT',
  SecondaryKeysFrozen = 'SECONDARY_KEYS_FROZEN',
  EventId = 'EVENT_ID',
  Datetime = 'DATETIME',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `Identity` aggregates. */
export type IdentitiesHavingInput = {
  AND?: Maybe<Array<IdentitiesHavingInput>>;
  OR?: Maybe<Array<IdentitiesHavingInput>>;
};

/** Methods to use when ordering `Identity`. */
export enum IdentitiesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  DidAsc = 'DID_ASC',
  DidDesc = 'DID_DESC',
  PrimaryAccountAsc = 'PRIMARY_ACCOUNT_ASC',
  PrimaryAccountDesc = 'PRIMARY_ACCOUNT_DESC',
  SecondaryKeysFrozenAsc = 'SECONDARY_KEYS_FROZEN_ASC',
  SecondaryKeysFrozenDesc = 'SECONDARY_KEYS_FROZEN_DESC',
  EventIdAsc = 'EVENT_ID_ASC',
  EventIdDesc = 'EVENT_ID_DESC',
  DatetimeAsc = 'DATETIME_ASC',
  DatetimeDesc = 'DATETIME_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SecondaryAccountsCountAsc = 'SECONDARY_ACCOUNTS_COUNT_ASC',
  SecondaryAccountsCountDesc = 'SECONDARY_ACCOUNTS_COUNT_DESC',
  BridgeEventsCountAsc = 'BRIDGE_EVENTS_COUNT_ASC',
  BridgeEventsCountDesc = 'BRIDGE_EVENTS_COUNT_DESC',
  StakingEventsCountAsc = 'STAKING_EVENTS_COUNT_ASC',
  StakingEventsCountDesc = 'STAKING_EVENTS_COUNT_DESC',
  AssetsByOwnerIdCountAsc = 'ASSETS_BY_OWNER_ID_COUNT_ASC',
  AssetsByOwnerIdCountDesc = 'ASSETS_BY_OWNER_ID_COUNT_DESC',
  TickerExternalAgentActionsByCallerIdCountAsc = 'TICKER_EXTERNAL_AGENT_ACTIONS_BY_CALLER_ID_COUNT_ASC',
  TickerExternalAgentActionsByCallerIdCountDesc = 'TICKER_EXTERNAL_AGENT_ACTIONS_BY_CALLER_ID_COUNT_DESC',
  AuthorizationsByFromIdCountAsc = 'AUTHORIZATIONS_BY_FROM_ID_COUNT_ASC',
  AuthorizationsByFromIdCountDesc = 'AUTHORIZATIONS_BY_FROM_ID_COUNT_DESC',
  AuthorizationsByToIdCountAsc = 'AUTHORIZATIONS_BY_TO_ID_COUNT_ASC',
  AuthorizationsByToIdCountDesc = 'AUTHORIZATIONS_BY_TO_ID_COUNT_DESC',
  InvestmentsByInvestorIdCountAsc = 'INVESTMENTS_BY_INVESTOR_ID_COUNT_ASC',
  InvestmentsByInvestorIdCountDesc = 'INVESTMENTS_BY_INVESTOR_ID_COUNT_DESC',
  TickerExternalAgentsByCallerIdCountAsc = 'TICKER_EXTERNAL_AGENTS_BY_CALLER_ID_COUNT_ASC',
  TickerExternalAgentsByCallerIdCountDesc = 'TICKER_EXTERNAL_AGENTS_BY_CALLER_ID_COUNT_DESC',
  TickerExternalAgentHistoriesCountAsc = 'TICKER_EXTERNAL_AGENT_HISTORIES_COUNT_ASC',
  TickerExternalAgentHistoriesCountDesc = 'TICKER_EXTERNAL_AGENT_HISTORIES_COUNT_DESC',
  PortfoliosCountAsc = 'PORTFOLIOS_COUNT_ASC',
  PortfoliosCountDesc = 'PORTFOLIOS_COUNT_DESC',
  PortfoliosByCustodianIdCountAsc = 'PORTFOLIOS_BY_CUSTODIAN_ID_COUNT_ASC',
  PortfoliosByCustodianIdCountDesc = 'PORTFOLIOS_BY_CUSTODIAN_ID_COUNT_DESC',
  VenuesByOwnerIdCountAsc = 'VENUES_BY_OWNER_ID_COUNT_ASC',
  VenuesByOwnerIdCountDesc = 'VENUES_BY_OWNER_ID_COUNT_DESC',
  DistributionsCountAsc = 'DISTRIBUTIONS_COUNT_ASC',
  DistributionsCountDesc = 'DISTRIBUTIONS_COUNT_DESC',
  DistributionPaymentsByTargetIdCountAsc = 'DISTRIBUTION_PAYMENTS_BY_TARGET_ID_COUNT_ASC',
  DistributionPaymentsByTargetIdCountDesc = 'DISTRIBUTION_PAYMENTS_BY_TARGET_ID_COUNT_DESC',
  ProposalsByOwnerIdCountAsc = 'PROPOSALS_BY_OWNER_ID_COUNT_ASC',
  ProposalsByOwnerIdCountDesc = 'PROPOSALS_BY_OWNER_ID_COUNT_DESC',
  ClaimsByTargetIdCountAsc = 'CLAIMS_BY_TARGET_ID_COUNT_ASC',
  ClaimsByTargetIdCountDesc = 'CLAIMS_BY_TARGET_ID_COUNT_DESC',
  ClaimsByIssuerIdCountAsc = 'CLAIMS_BY_ISSUER_ID_COUNT_ASC',
  ClaimsByIssuerIdCountDesc = 'CLAIMS_BY_ISSUER_ID_COUNT_DESC',
  StatTypesByClaimIssuerIdCountAsc = 'STAT_TYPES_BY_CLAIM_ISSUER_ID_COUNT_ASC',
  StatTypesByClaimIssuerIdCountDesc = 'STAT_TYPES_BY_CLAIM_ISSUER_ID_COUNT_DESC',
  TransferCompliancesByClaimIssuerIdCountAsc = 'TRANSFER_COMPLIANCES_BY_CLAIM_ISSUER_ID_COUNT_ASC',
  TransferCompliancesByClaimIssuerIdCountDesc = 'TRANSFER_COMPLIANCES_BY_CLAIM_ISSUER_ID_COUNT_DESC',
  HeldAssetsCountAsc = 'HELD_ASSETS_COUNT_ASC',
  HeldAssetsCountDesc = 'HELD_ASSETS_COUNT_DESC',
}

export type Identity = Node & {
  __typename?: 'Identity';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  did: Scalars['String'];
  primaryAccount: Scalars['String'];
  secondaryKeysFrozen: Scalars['Boolean'];
  eventId: Scalars['String'];
  datetime: Scalars['Datetime'];
  createdBlockId: Scalars['String'];
  updatedBlockId: Scalars['String'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Block` that is related to this `Identity`. */
  createdBlock?: Maybe<Block>;
  /** Reads a single `Block` that is related to this `Identity`. */
  updatedBlock?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Account`. */
  secondaryAccounts: AccountsConnection;
  /** Reads and enables pagination through a set of `BridgeEvent`. */
  bridgeEvents: BridgeEventsConnection;
  /** Reads and enables pagination through a set of `StakingEvent`. */
  stakingEvents: StakingEventsConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByOwnerId: AssetsConnection;
  /** Reads and enables pagination through a set of `TickerExternalAgentAction`. */
  tickerExternalAgentActionsByCallerId: TickerExternalAgentActionsConnection;
  /** Reads and enables pagination through a set of `Authorization`. */
  authorizationsByFromId: AuthorizationsConnection;
  /** Reads and enables pagination through a set of `Authorization`. */
  authorizationsByToId: AuthorizationsConnection;
  /** Reads and enables pagination through a set of `Investment`. */
  investmentsByInvestorId: InvestmentsConnection;
  /** Reads and enables pagination through a set of `TickerExternalAgent`. */
  tickerExternalAgentsByCallerId: TickerExternalAgentsConnection;
  /** Reads and enables pagination through a set of `TickerExternalAgentHistory`. */
  tickerExternalAgentHistories: TickerExternalAgentHistoriesConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfolios: PortfoliosConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByCustodianId: PortfoliosConnection;
  /** Reads and enables pagination through a set of `Venue`. */
  venuesByOwnerId: VenuesConnection;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributions: DistributionsConnection;
  /** Reads and enables pagination through a set of `DistributionPayment`. */
  distributionPaymentsByTargetId: DistributionPaymentsConnection;
  /** Reads and enables pagination through a set of `Proposal`. */
  proposalsByOwnerId: ProposalsConnection;
  /** Reads and enables pagination through a set of `Claim`. */
  claimsByTargetId: ClaimsConnection;
  /** Reads and enables pagination through a set of `Claim`. */
  claimsByIssuerId: ClaimsConnection;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypesByClaimIssuerId: StatTypesConnection;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliancesByClaimIssuerId: TransferCompliancesConnection;
  /** Reads and enables pagination through a set of `AssetHolder`. */
  heldAssets: AssetHoldersConnection;
  /** Reads and enables pagination through a set of `Permission`. */
  permissionsByAccountIdentityIdAndPermissionsId: IdentityPermissionsByAccountIdentityIdAndPermissionsIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAccountIdentityIdAndCreatedBlockId: IdentityBlocksByAccountIdentityIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAccountIdentityIdAndUpdatedBlockId: IdentityBlocksByAccountIdentityIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByBridgeEventIdentityIdAndCreatedBlockId: IdentityBlocksByBridgeEventIdentityIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByBridgeEventIdentityIdAndUpdatedBlockId: IdentityBlocksByBridgeEventIdentityIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByStakingEventIdentityIdAndCreatedBlockId: IdentityBlocksByStakingEventIdentityIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByStakingEventIdentityIdAndUpdatedBlockId: IdentityBlocksByStakingEventIdentityIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetOwnerIdAndCreatedBlockId: IdentityBlocksByAssetOwnerIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetOwnerIdAndUpdatedBlockId: IdentityBlocksByAssetOwnerIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTickerExternalAgentActionCallerIdAndAssetId: IdentityAssetsByTickerExternalAgentActionCallerIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTickerExternalAgentActionCallerIdAndCreatedBlockId: IdentityBlocksByTickerExternalAgentActionCallerIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTickerExternalAgentActionCallerIdAndUpdatedBlockId: IdentityBlocksByTickerExternalAgentActionCallerIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByAuthorizationFromIdAndToId: IdentityIdentitiesByAuthorizationFromIdAndToIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAuthorizationFromIdAndCreatedBlockId: IdentityBlocksByAuthorizationFromIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAuthorizationFromIdAndUpdatedBlockId: IdentityBlocksByAuthorizationFromIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByAuthorizationToIdAndFromId: IdentityIdentitiesByAuthorizationToIdAndFromIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAuthorizationToIdAndCreatedBlockId: IdentityBlocksByAuthorizationToIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAuthorizationToIdAndUpdatedBlockId: IdentityBlocksByAuthorizationToIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByInvestmentInvestorIdAndCreatedBlockId: IdentityBlocksByInvestmentInvestorIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByInvestmentInvestorIdAndUpdatedBlockId: IdentityBlocksByInvestmentInvestorIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTickerExternalAgentCallerIdAndAssetId: IdentityAssetsByTickerExternalAgentCallerIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTickerExternalAgentCallerIdAndCreatedBlockId: IdentityBlocksByTickerExternalAgentCallerIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTickerExternalAgentCallerIdAndUpdatedBlockId: IdentityBlocksByTickerExternalAgentCallerIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTickerExternalAgentHistoryIdentityIdAndAssetId: IdentityAssetsByTickerExternalAgentHistoryIdentityIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTickerExternalAgentHistoryIdentityIdAndCreatedBlockId: IdentityBlocksByTickerExternalAgentHistoryIdentityIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTickerExternalAgentHistoryIdentityIdAndUpdatedBlockId: IdentityBlocksByTickerExternalAgentHistoryIdentityIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByPortfolioIdentityIdAndCustodianId: IdentityIdentitiesByPortfolioIdentityIdAndCustodianIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByPortfolioIdentityIdAndCreatedBlockId: IdentityBlocksByPortfolioIdentityIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByPortfolioIdentityIdAndUpdatedBlockId: IdentityBlocksByPortfolioIdentityIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByPortfolioCustodianIdAndIdentityId: IdentityIdentitiesByPortfolioCustodianIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByPortfolioCustodianIdAndCreatedBlockId: IdentityBlocksByPortfolioCustodianIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByPortfolioCustodianIdAndUpdatedBlockId: IdentityBlocksByPortfolioCustodianIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByVenueOwnerIdAndCreatedBlockId: IdentityBlocksByVenueOwnerIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByVenueOwnerIdAndUpdatedBlockId: IdentityBlocksByVenueOwnerIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByDistributionIdentityIdAndAssetId: IdentityAssetsByDistributionIdentityIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByDistributionIdentityIdAndPortfolioId: IdentityPortfoliosByDistributionIdentityIdAndPortfolioIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByDistributionIdentityIdAndCreatedBlockId: IdentityBlocksByDistributionIdentityIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByDistributionIdentityIdAndUpdatedBlockId: IdentityBlocksByDistributionIdentityIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributionsByDistributionPaymentTargetIdAndDistributionId: IdentityDistributionsByDistributionPaymentTargetIdAndDistributionIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByDistributionPaymentTargetIdAndCreatedBlockId: IdentityBlocksByDistributionPaymentTargetIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByDistributionPaymentTargetIdAndUpdatedBlockId: IdentityBlocksByDistributionPaymentTargetIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByProposalOwnerIdAndCreatedBlockId: IdentityBlocksByProposalOwnerIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByProposalOwnerIdAndUpdatedBlockId: IdentityBlocksByProposalOwnerIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByClaimTargetIdAndIssuerId: IdentityIdentitiesByClaimTargetIdAndIssuerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByClaimTargetIdAndCreatedBlockId: IdentityBlocksByClaimTargetIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByClaimTargetIdAndUpdatedBlockId: IdentityBlocksByClaimTargetIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByClaimIssuerIdAndTargetId: IdentityIdentitiesByClaimIssuerIdAndTargetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByClaimIssuerIdAndCreatedBlockId: IdentityBlocksByClaimIssuerIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByClaimIssuerIdAndUpdatedBlockId: IdentityBlocksByClaimIssuerIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByStatTypeClaimIssuerIdAndAssetId: IdentityAssetsByStatTypeClaimIssuerIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByStatTypeClaimIssuerIdAndCreatedBlockId: IdentityBlocksByStatTypeClaimIssuerIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByStatTypeClaimIssuerIdAndUpdatedBlockId: IdentityBlocksByStatTypeClaimIssuerIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTransferComplianceClaimIssuerIdAndAssetId: IdentityAssetsByTransferComplianceClaimIssuerIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypesByTransferComplianceClaimIssuerIdAndStatTypeId: IdentityStatTypesByTransferComplianceClaimIssuerIdAndStatTypeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTransferComplianceClaimIssuerIdAndCreatedBlockId: IdentityBlocksByTransferComplianceClaimIssuerIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTransferComplianceClaimIssuerIdAndUpdatedBlockId: IdentityBlocksByTransferComplianceClaimIssuerIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByAssetHolderIdentityIdAndAssetId: IdentityAssetsByAssetHolderIdentityIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetHolderIdentityIdAndCreatedBlockId: IdentityBlocksByAssetHolderIdentityIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAssetHolderIdentityIdAndUpdatedBlockId: IdentityBlocksByAssetHolderIdentityIdAndUpdatedBlockIdManyToManyConnection;
};

export type IdentitySecondaryAccountsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AccountsOrderBy>>;
  filter?: Maybe<AccountFilter>;
};

export type IdentityBridgeEventsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BridgeEventsOrderBy>>;
  filter?: Maybe<BridgeEventFilter>;
};

export type IdentityStakingEventsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StakingEventsOrderBy>>;
  filter?: Maybe<StakingEventFilter>;
};

export type IdentityAssetsByOwnerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type IdentityTickerExternalAgentActionsByCallerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TickerExternalAgentActionsOrderBy>>;
  filter?: Maybe<TickerExternalAgentActionFilter>;
};

export type IdentityAuthorizationsByFromIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AuthorizationsOrderBy>>;
  filter?: Maybe<AuthorizationFilter>;
};

export type IdentityAuthorizationsByToIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AuthorizationsOrderBy>>;
  filter?: Maybe<AuthorizationFilter>;
};

export type IdentityInvestmentsByInvestorIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<InvestmentsOrderBy>>;
  filter?: Maybe<InvestmentFilter>;
};

export type IdentityTickerExternalAgentsByCallerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TickerExternalAgentsOrderBy>>;
  filter?: Maybe<TickerExternalAgentFilter>;
};

export type IdentityTickerExternalAgentHistoriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TickerExternalAgentHistoriesOrderBy>>;
  filter?: Maybe<TickerExternalAgentHistoryFilter>;
};

export type IdentityPortfoliosArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PortfoliosOrderBy>>;
  filter?: Maybe<PortfolioFilter>;
};

export type IdentityPortfoliosByCustodianIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PortfoliosOrderBy>>;
  filter?: Maybe<PortfolioFilter>;
};

export type IdentityVenuesByOwnerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VenuesOrderBy>>;
  filter?: Maybe<VenueFilter>;
};

export type IdentityDistributionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<DistributionsOrderBy>>;
  filter?: Maybe<DistributionFilter>;
};

export type IdentityDistributionPaymentsByTargetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<DistributionPaymentsOrderBy>>;
  filter?: Maybe<DistributionPaymentFilter>;
};

export type IdentityProposalsByOwnerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ProposalsOrderBy>>;
  filter?: Maybe<ProposalFilter>;
};

export type IdentityClaimsByTargetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ClaimsOrderBy>>;
  filter?: Maybe<ClaimFilter>;
};

export type IdentityClaimsByIssuerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ClaimsOrderBy>>;
  filter?: Maybe<ClaimFilter>;
};

export type IdentityStatTypesByClaimIssuerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StatTypesOrderBy>>;
  filter?: Maybe<StatTypeFilter>;
};

export type IdentityTransferCompliancesByClaimIssuerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TransferCompliancesOrderBy>>;
  filter?: Maybe<TransferComplianceFilter>;
};

export type IdentityHeldAssetsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetHoldersOrderBy>>;
  filter?: Maybe<AssetHolderFilter>;
};

export type IdentityPermissionsByAccountIdentityIdAndPermissionsIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PermissionsOrderBy>>;
  filter?: Maybe<PermissionFilter>;
};

export type IdentityBlocksByAccountIdentityIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityBlocksByAccountIdentityIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityBlocksByBridgeEventIdentityIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityBlocksByBridgeEventIdentityIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityBlocksByStakingEventIdentityIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityBlocksByStakingEventIdentityIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityBlocksByAssetOwnerIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityBlocksByAssetOwnerIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityAssetsByTickerExternalAgentActionCallerIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type IdentityBlocksByTickerExternalAgentActionCallerIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityBlocksByTickerExternalAgentActionCallerIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityIdentitiesByAuthorizationFromIdAndToIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type IdentityBlocksByAuthorizationFromIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityBlocksByAuthorizationFromIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityIdentitiesByAuthorizationToIdAndFromIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type IdentityBlocksByAuthorizationToIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityBlocksByAuthorizationToIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityBlocksByInvestmentInvestorIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityBlocksByInvestmentInvestorIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityAssetsByTickerExternalAgentCallerIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type IdentityBlocksByTickerExternalAgentCallerIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityBlocksByTickerExternalAgentCallerIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityAssetsByTickerExternalAgentHistoryIdentityIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type IdentityBlocksByTickerExternalAgentHistoryIdentityIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityBlocksByTickerExternalAgentHistoryIdentityIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityIdentitiesByPortfolioIdentityIdAndCustodianIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type IdentityBlocksByPortfolioIdentityIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityBlocksByPortfolioIdentityIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityIdentitiesByPortfolioCustodianIdAndIdentityIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type IdentityBlocksByPortfolioCustodianIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityBlocksByPortfolioCustodianIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityBlocksByVenueOwnerIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityBlocksByVenueOwnerIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityAssetsByDistributionIdentityIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type IdentityPortfoliosByDistributionIdentityIdAndPortfolioIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PortfoliosOrderBy>>;
  filter?: Maybe<PortfolioFilter>;
};

export type IdentityBlocksByDistributionIdentityIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityBlocksByDistributionIdentityIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityDistributionsByDistributionPaymentTargetIdAndDistributionIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<DistributionsOrderBy>>;
  filter?: Maybe<DistributionFilter>;
};

export type IdentityBlocksByDistributionPaymentTargetIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityBlocksByDistributionPaymentTargetIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityBlocksByProposalOwnerIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityBlocksByProposalOwnerIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityIdentitiesByClaimTargetIdAndIssuerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type IdentityBlocksByClaimTargetIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityBlocksByClaimTargetIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityIdentitiesByClaimIssuerIdAndTargetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type IdentityBlocksByClaimIssuerIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityBlocksByClaimIssuerIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityAssetsByStatTypeClaimIssuerIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type IdentityBlocksByStatTypeClaimIssuerIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityBlocksByStatTypeClaimIssuerIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityAssetsByTransferComplianceClaimIssuerIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type IdentityStatTypesByTransferComplianceClaimIssuerIdAndStatTypeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StatTypesOrderBy>>;
  filter?: Maybe<StatTypeFilter>;
};

export type IdentityBlocksByTransferComplianceClaimIssuerIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityBlocksByTransferComplianceClaimIssuerIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityAssetsByAssetHolderIdentityIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type IdentityBlocksByAssetHolderIdentityIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityBlocksByAssetHolderIdentityIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type IdentityAggregates = {
  __typename?: 'IdentityAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A connection to a list of `Asset` values, with data from `AssetHolder`. */
export type IdentityAssetsByAssetHolderIdentityIdAndAssetIdManyToManyConnection = {
  __typename?: 'IdentityAssetsByAssetHolderIdentityIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `AssetHolder`, and the cursor to aid in pagination. */
  edges: Array<IdentityAssetsByAssetHolderIdentityIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `AssetHolder`. */
export type IdentityAssetsByAssetHolderIdentityIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `AssetHolder`. */
export type IdentityAssetsByAssetHolderIdentityIdAndAssetIdManyToManyEdge = {
  __typename?: 'IdentityAssetsByAssetHolderIdentityIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `AssetHolder`. */
  holders: AssetHoldersConnection;
};

/** A `Asset` edge in the connection, with data from `AssetHolder`. */
export type IdentityAssetsByAssetHolderIdentityIdAndAssetIdManyToManyEdgeHoldersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetHoldersOrderBy>>;
  filter?: Maybe<AssetHolderFilter>;
};

/** A connection to a list of `Asset` values, with data from `Distribution`. */
export type IdentityAssetsByDistributionIdentityIdAndAssetIdManyToManyConnection = {
  __typename?: 'IdentityAssetsByDistributionIdentityIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<IdentityAssetsByDistributionIdentityIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `Distribution`. */
export type IdentityAssetsByDistributionIdentityIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `Distribution`. */
export type IdentityAssetsByDistributionIdentityIdAndAssetIdManyToManyEdge = {
  __typename?: 'IdentityAssetsByDistributionIdentityIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributions: DistributionsConnection;
};

/** A `Asset` edge in the connection, with data from `Distribution`. */
export type IdentityAssetsByDistributionIdentityIdAndAssetIdManyToManyEdgeDistributionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<DistributionsOrderBy>>;
  filter?: Maybe<DistributionFilter>;
};

/** A connection to a list of `Asset` values, with data from `StatType`. */
export type IdentityAssetsByStatTypeClaimIssuerIdAndAssetIdManyToManyConnection = {
  __typename?: 'IdentityAssetsByStatTypeClaimIssuerIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `StatType`, and the cursor to aid in pagination. */
  edges: Array<IdentityAssetsByStatTypeClaimIssuerIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `StatType`. */
export type IdentityAssetsByStatTypeClaimIssuerIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `StatType`. */
export type IdentityAssetsByStatTypeClaimIssuerIdAndAssetIdManyToManyEdge = {
  __typename?: 'IdentityAssetsByStatTypeClaimIssuerIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypes: StatTypesConnection;
};

/** A `Asset` edge in the connection, with data from `StatType`. */
export type IdentityAssetsByStatTypeClaimIssuerIdAndAssetIdManyToManyEdgeStatTypesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StatTypesOrderBy>>;
  filter?: Maybe<StatTypeFilter>;
};

/** A connection to a list of `Asset` values, with data from `TickerExternalAgentAction`. */
export type IdentityAssetsByTickerExternalAgentActionCallerIdAndAssetIdManyToManyConnection = {
  __typename?: 'IdentityAssetsByTickerExternalAgentActionCallerIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `TickerExternalAgentAction`, and the cursor to aid in pagination. */
  edges: Array<IdentityAssetsByTickerExternalAgentActionCallerIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `TickerExternalAgentAction`. */
export type IdentityAssetsByTickerExternalAgentActionCallerIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TickerExternalAgentAction`. */
export type IdentityAssetsByTickerExternalAgentActionCallerIdAndAssetIdManyToManyEdge = {
  __typename?: 'IdentityAssetsByTickerExternalAgentActionCallerIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TickerExternalAgentAction`. */
  tickerExternalAgentActions: TickerExternalAgentActionsConnection;
};

/** A `Asset` edge in the connection, with data from `TickerExternalAgentAction`. */
export type IdentityAssetsByTickerExternalAgentActionCallerIdAndAssetIdManyToManyEdgeTickerExternalAgentActionsArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TickerExternalAgentActionsOrderBy>>;
    filter?: Maybe<TickerExternalAgentActionFilter>;
  };

/** A connection to a list of `Asset` values, with data from `TickerExternalAgent`. */
export type IdentityAssetsByTickerExternalAgentCallerIdAndAssetIdManyToManyConnection = {
  __typename?: 'IdentityAssetsByTickerExternalAgentCallerIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `TickerExternalAgent`, and the cursor to aid in pagination. */
  edges: Array<IdentityAssetsByTickerExternalAgentCallerIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `TickerExternalAgent`. */
export type IdentityAssetsByTickerExternalAgentCallerIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TickerExternalAgent`. */
export type IdentityAssetsByTickerExternalAgentCallerIdAndAssetIdManyToManyEdge = {
  __typename?: 'IdentityAssetsByTickerExternalAgentCallerIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TickerExternalAgent`. */
  tickerExternalAgents: TickerExternalAgentsConnection;
};

/** A `Asset` edge in the connection, with data from `TickerExternalAgent`. */
export type IdentityAssetsByTickerExternalAgentCallerIdAndAssetIdManyToManyEdgeTickerExternalAgentsArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TickerExternalAgentsOrderBy>>;
    filter?: Maybe<TickerExternalAgentFilter>;
  };

/** A connection to a list of `Asset` values, with data from `TickerExternalAgentHistory`. */
export type IdentityAssetsByTickerExternalAgentHistoryIdentityIdAndAssetIdManyToManyConnection = {
  __typename?: 'IdentityAssetsByTickerExternalAgentHistoryIdentityIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `TickerExternalAgentHistory`, and the cursor to aid in pagination. */
  edges: Array<IdentityAssetsByTickerExternalAgentHistoryIdentityIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `TickerExternalAgentHistory`. */
export type IdentityAssetsByTickerExternalAgentHistoryIdentityIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type IdentityAssetsByTickerExternalAgentHistoryIdentityIdAndAssetIdManyToManyEdge = {
  __typename?: 'IdentityAssetsByTickerExternalAgentHistoryIdentityIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TickerExternalAgentHistory`. */
  tickerExternalAgentHistories: TickerExternalAgentHistoriesConnection;
};

/** A `Asset` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type IdentityAssetsByTickerExternalAgentHistoryIdentityIdAndAssetIdManyToManyEdgeTickerExternalAgentHistoriesArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TickerExternalAgentHistoriesOrderBy>>;
    filter?: Maybe<TickerExternalAgentHistoryFilter>;
  };

/** A connection to a list of `Asset` values, with data from `TransferCompliance`. */
export type IdentityAssetsByTransferComplianceClaimIssuerIdAndAssetIdManyToManyConnection = {
  __typename?: 'IdentityAssetsByTransferComplianceClaimIssuerIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
  edges: Array<IdentityAssetsByTransferComplianceClaimIssuerIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `TransferCompliance`. */
export type IdentityAssetsByTransferComplianceClaimIssuerIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TransferCompliance`. */
export type IdentityAssetsByTransferComplianceClaimIssuerIdAndAssetIdManyToManyEdge = {
  __typename?: 'IdentityAssetsByTransferComplianceClaimIssuerIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliances: TransferCompliancesConnection;
};

/** A `Asset` edge in the connection, with data from `TransferCompliance`. */
export type IdentityAssetsByTransferComplianceClaimIssuerIdAndAssetIdManyToManyEdgeTransferCompliancesArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TransferCompliancesOrderBy>>;
    filter?: Maybe<TransferComplianceFilter>;
  };

/** A connection to a list of `Block` values, with data from `Account`. */
export type IdentityBlocksByAccountIdentityIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByAccountIdentityIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Account`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByAccountIdentityIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Account`. */
export type IdentityBlocksByAccountIdentityIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Account`. */
export type IdentityBlocksByAccountIdentityIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByAccountIdentityIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Account`. */
  accountsByCreatedBlockId: AccountsConnection;
};

/** A `Block` edge in the connection, with data from `Account`. */
export type IdentityBlocksByAccountIdentityIdAndCreatedBlockIdManyToManyEdgeAccountsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AccountsOrderBy>>;
    filter?: Maybe<AccountFilter>;
  };

/** A connection to a list of `Block` values, with data from `Account`. */
export type IdentityBlocksByAccountIdentityIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByAccountIdentityIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Account`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByAccountIdentityIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Account`. */
export type IdentityBlocksByAccountIdentityIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Account`. */
export type IdentityBlocksByAccountIdentityIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByAccountIdentityIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Account`. */
  accountsByUpdatedBlockId: AccountsConnection;
};

/** A `Block` edge in the connection, with data from `Account`. */
export type IdentityBlocksByAccountIdentityIdAndUpdatedBlockIdManyToManyEdgeAccountsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AccountsOrderBy>>;
    filter?: Maybe<AccountFilter>;
  };

/** A connection to a list of `Block` values, with data from `AssetHolder`. */
export type IdentityBlocksByAssetHolderIdentityIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByAssetHolderIdentityIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `AssetHolder`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByAssetHolderIdentityIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `AssetHolder`. */
export type IdentityBlocksByAssetHolderIdentityIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AssetHolder`. */
export type IdentityBlocksByAssetHolderIdentityIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByAssetHolderIdentityIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `AssetHolder`. */
  assetHoldersByCreatedBlockId: AssetHoldersConnection;
};

/** A `Block` edge in the connection, with data from `AssetHolder`. */
export type IdentityBlocksByAssetHolderIdentityIdAndCreatedBlockIdManyToManyEdgeAssetHoldersByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AssetHoldersOrderBy>>;
    filter?: Maybe<AssetHolderFilter>;
  };

/** A connection to a list of `Block` values, with data from `AssetHolder`. */
export type IdentityBlocksByAssetHolderIdentityIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByAssetHolderIdentityIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `AssetHolder`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByAssetHolderIdentityIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `AssetHolder`. */
export type IdentityBlocksByAssetHolderIdentityIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `AssetHolder`. */
export type IdentityBlocksByAssetHolderIdentityIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByAssetHolderIdentityIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `AssetHolder`. */
  assetHoldersByUpdatedBlockId: AssetHoldersConnection;
};

/** A `Block` edge in the connection, with data from `AssetHolder`. */
export type IdentityBlocksByAssetHolderIdentityIdAndUpdatedBlockIdManyToManyEdgeAssetHoldersByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AssetHoldersOrderBy>>;
    filter?: Maybe<AssetHolderFilter>;
  };

/** A connection to a list of `Block` values, with data from `Asset`. */
export type IdentityBlocksByAssetOwnerIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByAssetOwnerIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Asset`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByAssetOwnerIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Asset`. */
export type IdentityBlocksByAssetOwnerIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Asset`. */
export type IdentityBlocksByAssetOwnerIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByAssetOwnerIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByCreatedBlockId: AssetsConnection;
};

/** A `Block` edge in the connection, with data from `Asset`. */
export type IdentityBlocksByAssetOwnerIdAndCreatedBlockIdManyToManyEdgeAssetsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AssetsOrderBy>>;
    filter?: Maybe<AssetFilter>;
  };

/** A connection to a list of `Block` values, with data from `Asset`. */
export type IdentityBlocksByAssetOwnerIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByAssetOwnerIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Asset`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByAssetOwnerIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Asset`. */
export type IdentityBlocksByAssetOwnerIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Asset`. */
export type IdentityBlocksByAssetOwnerIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByAssetOwnerIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByUpdatedBlockId: AssetsConnection;
};

/** A `Block` edge in the connection, with data from `Asset`. */
export type IdentityBlocksByAssetOwnerIdAndUpdatedBlockIdManyToManyEdgeAssetsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AssetsOrderBy>>;
    filter?: Maybe<AssetFilter>;
  };

/** A connection to a list of `Block` values, with data from `Authorization`. */
export type IdentityBlocksByAuthorizationFromIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByAuthorizationFromIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Authorization`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByAuthorizationFromIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Authorization`. */
export type IdentityBlocksByAuthorizationFromIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Authorization`. */
export type IdentityBlocksByAuthorizationFromIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByAuthorizationFromIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Authorization`. */
  authorizationsByCreatedBlockId: AuthorizationsConnection;
};

/** A `Block` edge in the connection, with data from `Authorization`. */
export type IdentityBlocksByAuthorizationFromIdAndCreatedBlockIdManyToManyEdgeAuthorizationsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AuthorizationsOrderBy>>;
    filter?: Maybe<AuthorizationFilter>;
  };

/** A connection to a list of `Block` values, with data from `Authorization`. */
export type IdentityBlocksByAuthorizationFromIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByAuthorizationFromIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Authorization`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByAuthorizationFromIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Authorization`. */
export type IdentityBlocksByAuthorizationFromIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Authorization`. */
export type IdentityBlocksByAuthorizationFromIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByAuthorizationFromIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Authorization`. */
  authorizationsByUpdatedBlockId: AuthorizationsConnection;
};

/** A `Block` edge in the connection, with data from `Authorization`. */
export type IdentityBlocksByAuthorizationFromIdAndUpdatedBlockIdManyToManyEdgeAuthorizationsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AuthorizationsOrderBy>>;
    filter?: Maybe<AuthorizationFilter>;
  };

/** A connection to a list of `Block` values, with data from `Authorization`. */
export type IdentityBlocksByAuthorizationToIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByAuthorizationToIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Authorization`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByAuthorizationToIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Authorization`. */
export type IdentityBlocksByAuthorizationToIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Authorization`. */
export type IdentityBlocksByAuthorizationToIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByAuthorizationToIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Authorization`. */
  authorizationsByCreatedBlockId: AuthorizationsConnection;
};

/** A `Block` edge in the connection, with data from `Authorization`. */
export type IdentityBlocksByAuthorizationToIdAndCreatedBlockIdManyToManyEdgeAuthorizationsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AuthorizationsOrderBy>>;
    filter?: Maybe<AuthorizationFilter>;
  };

/** A connection to a list of `Block` values, with data from `Authorization`. */
export type IdentityBlocksByAuthorizationToIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByAuthorizationToIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Authorization`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByAuthorizationToIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Authorization`. */
export type IdentityBlocksByAuthorizationToIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Authorization`. */
export type IdentityBlocksByAuthorizationToIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByAuthorizationToIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Authorization`. */
  authorizationsByUpdatedBlockId: AuthorizationsConnection;
};

/** A `Block` edge in the connection, with data from `Authorization`. */
export type IdentityBlocksByAuthorizationToIdAndUpdatedBlockIdManyToManyEdgeAuthorizationsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AuthorizationsOrderBy>>;
    filter?: Maybe<AuthorizationFilter>;
  };

/** A connection to a list of `Block` values, with data from `BridgeEvent`. */
export type IdentityBlocksByBridgeEventIdentityIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByBridgeEventIdentityIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `BridgeEvent`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByBridgeEventIdentityIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `BridgeEvent`. */
export type IdentityBlocksByBridgeEventIdentityIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `BridgeEvent`. */
export type IdentityBlocksByBridgeEventIdentityIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByBridgeEventIdentityIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `BridgeEvent`. */
  bridgeEventsByCreatedBlockId: BridgeEventsConnection;
};

/** A `Block` edge in the connection, with data from `BridgeEvent`. */
export type IdentityBlocksByBridgeEventIdentityIdAndCreatedBlockIdManyToManyEdgeBridgeEventsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<BridgeEventsOrderBy>>;
    filter?: Maybe<BridgeEventFilter>;
  };

/** A connection to a list of `Block` values, with data from `BridgeEvent`. */
export type IdentityBlocksByBridgeEventIdentityIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByBridgeEventIdentityIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `BridgeEvent`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByBridgeEventIdentityIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `BridgeEvent`. */
export type IdentityBlocksByBridgeEventIdentityIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `BridgeEvent`. */
export type IdentityBlocksByBridgeEventIdentityIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByBridgeEventIdentityIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `BridgeEvent`. */
  bridgeEventsByUpdatedBlockId: BridgeEventsConnection;
};

/** A `Block` edge in the connection, with data from `BridgeEvent`. */
export type IdentityBlocksByBridgeEventIdentityIdAndUpdatedBlockIdManyToManyEdgeBridgeEventsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<BridgeEventsOrderBy>>;
    filter?: Maybe<BridgeEventFilter>;
  };

/** A connection to a list of `Block` values, with data from `Claim`. */
export type IdentityBlocksByClaimIssuerIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByClaimIssuerIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Claim`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByClaimIssuerIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Claim`. */
export type IdentityBlocksByClaimIssuerIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Claim`. */
export type IdentityBlocksByClaimIssuerIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByClaimIssuerIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Claim`. */
  claimsByCreatedBlockId: ClaimsConnection;
};

/** A `Block` edge in the connection, with data from `Claim`. */
export type IdentityBlocksByClaimIssuerIdAndCreatedBlockIdManyToManyEdgeClaimsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<ClaimsOrderBy>>;
    filter?: Maybe<ClaimFilter>;
  };

/** A connection to a list of `Block` values, with data from `Claim`. */
export type IdentityBlocksByClaimIssuerIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByClaimIssuerIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Claim`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByClaimIssuerIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Claim`. */
export type IdentityBlocksByClaimIssuerIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Claim`. */
export type IdentityBlocksByClaimIssuerIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByClaimIssuerIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Claim`. */
  claimsByUpdatedBlockId: ClaimsConnection;
};

/** A `Block` edge in the connection, with data from `Claim`. */
export type IdentityBlocksByClaimIssuerIdAndUpdatedBlockIdManyToManyEdgeClaimsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<ClaimsOrderBy>>;
    filter?: Maybe<ClaimFilter>;
  };

/** A connection to a list of `Block` values, with data from `Claim`. */
export type IdentityBlocksByClaimTargetIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByClaimTargetIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Claim`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByClaimTargetIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Claim`. */
export type IdentityBlocksByClaimTargetIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Claim`. */
export type IdentityBlocksByClaimTargetIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByClaimTargetIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Claim`. */
  claimsByCreatedBlockId: ClaimsConnection;
};

/** A `Block` edge in the connection, with data from `Claim`. */
export type IdentityBlocksByClaimTargetIdAndCreatedBlockIdManyToManyEdgeClaimsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<ClaimsOrderBy>>;
    filter?: Maybe<ClaimFilter>;
  };

/** A connection to a list of `Block` values, with data from `Claim`. */
export type IdentityBlocksByClaimTargetIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByClaimTargetIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Claim`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByClaimTargetIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Claim`. */
export type IdentityBlocksByClaimTargetIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Claim`. */
export type IdentityBlocksByClaimTargetIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByClaimTargetIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Claim`. */
  claimsByUpdatedBlockId: ClaimsConnection;
};

/** A `Block` edge in the connection, with data from `Claim`. */
export type IdentityBlocksByClaimTargetIdAndUpdatedBlockIdManyToManyEdgeClaimsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<ClaimsOrderBy>>;
    filter?: Maybe<ClaimFilter>;
  };

/** A connection to a list of `Block` values, with data from `Distribution`. */
export type IdentityBlocksByDistributionIdentityIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByDistributionIdentityIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByDistributionIdentityIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Distribution`. */
export type IdentityBlocksByDistributionIdentityIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Distribution`. */
export type IdentityBlocksByDistributionIdentityIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByDistributionIdentityIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributionsByCreatedBlockId: DistributionsConnection;
};

/** A `Block` edge in the connection, with data from `Distribution`. */
export type IdentityBlocksByDistributionIdentityIdAndCreatedBlockIdManyToManyEdgeDistributionsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<DistributionsOrderBy>>;
    filter?: Maybe<DistributionFilter>;
  };

/** A connection to a list of `Block` values, with data from `Distribution`. */
export type IdentityBlocksByDistributionIdentityIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByDistributionIdentityIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByDistributionIdentityIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Distribution`. */
export type IdentityBlocksByDistributionIdentityIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Distribution`. */
export type IdentityBlocksByDistributionIdentityIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByDistributionIdentityIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributionsByUpdatedBlockId: DistributionsConnection;
};

/** A `Block` edge in the connection, with data from `Distribution`. */
export type IdentityBlocksByDistributionIdentityIdAndUpdatedBlockIdManyToManyEdgeDistributionsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<DistributionsOrderBy>>;
    filter?: Maybe<DistributionFilter>;
  };

/** A connection to a list of `Block` values, with data from `DistributionPayment`. */
export type IdentityBlocksByDistributionPaymentTargetIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByDistributionPaymentTargetIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `DistributionPayment`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByDistributionPaymentTargetIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `DistributionPayment`. */
export type IdentityBlocksByDistributionPaymentTargetIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `DistributionPayment`. */
export type IdentityBlocksByDistributionPaymentTargetIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByDistributionPaymentTargetIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `DistributionPayment`. */
  distributionPaymentsByCreatedBlockId: DistributionPaymentsConnection;
};

/** A `Block` edge in the connection, with data from `DistributionPayment`. */
export type IdentityBlocksByDistributionPaymentTargetIdAndCreatedBlockIdManyToManyEdgeDistributionPaymentsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<DistributionPaymentsOrderBy>>;
    filter?: Maybe<DistributionPaymentFilter>;
  };

/** A connection to a list of `Block` values, with data from `DistributionPayment`. */
export type IdentityBlocksByDistributionPaymentTargetIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByDistributionPaymentTargetIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `DistributionPayment`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByDistributionPaymentTargetIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `DistributionPayment`. */
export type IdentityBlocksByDistributionPaymentTargetIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `DistributionPayment`. */
export type IdentityBlocksByDistributionPaymentTargetIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByDistributionPaymentTargetIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `DistributionPayment`. */
  distributionPaymentsByUpdatedBlockId: DistributionPaymentsConnection;
};

/** A `Block` edge in the connection, with data from `DistributionPayment`. */
export type IdentityBlocksByDistributionPaymentTargetIdAndUpdatedBlockIdManyToManyEdgeDistributionPaymentsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<DistributionPaymentsOrderBy>>;
    filter?: Maybe<DistributionPaymentFilter>;
  };

/** A connection to a list of `Block` values, with data from `Investment`. */
export type IdentityBlocksByInvestmentInvestorIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByInvestmentInvestorIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Investment`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByInvestmentInvestorIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Investment`. */
export type IdentityBlocksByInvestmentInvestorIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Investment`. */
export type IdentityBlocksByInvestmentInvestorIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByInvestmentInvestorIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Investment`. */
  investmentsByCreatedBlockId: InvestmentsConnection;
};

/** A `Block` edge in the connection, with data from `Investment`. */
export type IdentityBlocksByInvestmentInvestorIdAndCreatedBlockIdManyToManyEdgeInvestmentsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<InvestmentsOrderBy>>;
    filter?: Maybe<InvestmentFilter>;
  };

/** A connection to a list of `Block` values, with data from `Investment`. */
export type IdentityBlocksByInvestmentInvestorIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByInvestmentInvestorIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Investment`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByInvestmentInvestorIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Investment`. */
export type IdentityBlocksByInvestmentInvestorIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Investment`. */
export type IdentityBlocksByInvestmentInvestorIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByInvestmentInvestorIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Investment`. */
  investmentsByUpdatedBlockId: InvestmentsConnection;
};

/** A `Block` edge in the connection, with data from `Investment`. */
export type IdentityBlocksByInvestmentInvestorIdAndUpdatedBlockIdManyToManyEdgeInvestmentsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<InvestmentsOrderBy>>;
    filter?: Maybe<InvestmentFilter>;
  };

/** A connection to a list of `Block` values, with data from `Portfolio`. */
export type IdentityBlocksByPortfolioCustodianIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByPortfolioCustodianIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Portfolio`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByPortfolioCustodianIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Portfolio`. */
export type IdentityBlocksByPortfolioCustodianIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Portfolio`. */
export type IdentityBlocksByPortfolioCustodianIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByPortfolioCustodianIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByCreatedBlockId: PortfoliosConnection;
};

/** A `Block` edge in the connection, with data from `Portfolio`. */
export type IdentityBlocksByPortfolioCustodianIdAndCreatedBlockIdManyToManyEdgePortfoliosByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<PortfoliosOrderBy>>;
    filter?: Maybe<PortfolioFilter>;
  };

/** A connection to a list of `Block` values, with data from `Portfolio`. */
export type IdentityBlocksByPortfolioCustodianIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByPortfolioCustodianIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Portfolio`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByPortfolioCustodianIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Portfolio`. */
export type IdentityBlocksByPortfolioCustodianIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Portfolio`. */
export type IdentityBlocksByPortfolioCustodianIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByPortfolioCustodianIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByUpdatedBlockId: PortfoliosConnection;
};

/** A `Block` edge in the connection, with data from `Portfolio`. */
export type IdentityBlocksByPortfolioCustodianIdAndUpdatedBlockIdManyToManyEdgePortfoliosByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<PortfoliosOrderBy>>;
    filter?: Maybe<PortfolioFilter>;
  };

/** A connection to a list of `Block` values, with data from `Portfolio`. */
export type IdentityBlocksByPortfolioIdentityIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByPortfolioIdentityIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Portfolio`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByPortfolioIdentityIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Portfolio`. */
export type IdentityBlocksByPortfolioIdentityIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Portfolio`. */
export type IdentityBlocksByPortfolioIdentityIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByPortfolioIdentityIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByCreatedBlockId: PortfoliosConnection;
};

/** A `Block` edge in the connection, with data from `Portfolio`. */
export type IdentityBlocksByPortfolioIdentityIdAndCreatedBlockIdManyToManyEdgePortfoliosByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<PortfoliosOrderBy>>;
    filter?: Maybe<PortfolioFilter>;
  };

/** A connection to a list of `Block` values, with data from `Portfolio`. */
export type IdentityBlocksByPortfolioIdentityIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByPortfolioIdentityIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Portfolio`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByPortfolioIdentityIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Portfolio`. */
export type IdentityBlocksByPortfolioIdentityIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Portfolio`. */
export type IdentityBlocksByPortfolioIdentityIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByPortfolioIdentityIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByUpdatedBlockId: PortfoliosConnection;
};

/** A `Block` edge in the connection, with data from `Portfolio`. */
export type IdentityBlocksByPortfolioIdentityIdAndUpdatedBlockIdManyToManyEdgePortfoliosByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<PortfoliosOrderBy>>;
    filter?: Maybe<PortfolioFilter>;
  };

/** A connection to a list of `Block` values, with data from `Proposal`. */
export type IdentityBlocksByProposalOwnerIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByProposalOwnerIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Proposal`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByProposalOwnerIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Proposal`. */
export type IdentityBlocksByProposalOwnerIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Proposal`. */
export type IdentityBlocksByProposalOwnerIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByProposalOwnerIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Proposal`. */
  proposalsByCreatedBlockId: ProposalsConnection;
};

/** A `Block` edge in the connection, with data from `Proposal`. */
export type IdentityBlocksByProposalOwnerIdAndCreatedBlockIdManyToManyEdgeProposalsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<ProposalsOrderBy>>;
    filter?: Maybe<ProposalFilter>;
  };

/** A connection to a list of `Block` values, with data from `Proposal`. */
export type IdentityBlocksByProposalOwnerIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByProposalOwnerIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Proposal`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByProposalOwnerIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Proposal`. */
export type IdentityBlocksByProposalOwnerIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Proposal`. */
export type IdentityBlocksByProposalOwnerIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByProposalOwnerIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Proposal`. */
  proposalsByUpdatedBlockId: ProposalsConnection;
};

/** A `Block` edge in the connection, with data from `Proposal`. */
export type IdentityBlocksByProposalOwnerIdAndUpdatedBlockIdManyToManyEdgeProposalsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<ProposalsOrderBy>>;
    filter?: Maybe<ProposalFilter>;
  };

/** A connection to a list of `Block` values, with data from `StakingEvent`. */
export type IdentityBlocksByStakingEventIdentityIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByStakingEventIdentityIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `StakingEvent`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByStakingEventIdentityIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `StakingEvent`. */
export type IdentityBlocksByStakingEventIdentityIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `StakingEvent`. */
export type IdentityBlocksByStakingEventIdentityIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByStakingEventIdentityIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `StakingEvent`. */
  stakingEventsByCreatedBlockId: StakingEventsConnection;
};

/** A `Block` edge in the connection, with data from `StakingEvent`. */
export type IdentityBlocksByStakingEventIdentityIdAndCreatedBlockIdManyToManyEdgeStakingEventsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<StakingEventsOrderBy>>;
    filter?: Maybe<StakingEventFilter>;
  };

/** A connection to a list of `Block` values, with data from `StakingEvent`. */
export type IdentityBlocksByStakingEventIdentityIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByStakingEventIdentityIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `StakingEvent`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByStakingEventIdentityIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `StakingEvent`. */
export type IdentityBlocksByStakingEventIdentityIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `StakingEvent`. */
export type IdentityBlocksByStakingEventIdentityIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByStakingEventIdentityIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `StakingEvent`. */
  stakingEventsByUpdatedBlockId: StakingEventsConnection;
};

/** A `Block` edge in the connection, with data from `StakingEvent`. */
export type IdentityBlocksByStakingEventIdentityIdAndUpdatedBlockIdManyToManyEdgeStakingEventsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<StakingEventsOrderBy>>;
    filter?: Maybe<StakingEventFilter>;
  };

/** A connection to a list of `Block` values, with data from `StatType`. */
export type IdentityBlocksByStatTypeClaimIssuerIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByStatTypeClaimIssuerIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `StatType`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByStatTypeClaimIssuerIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `StatType`. */
export type IdentityBlocksByStatTypeClaimIssuerIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `StatType`. */
export type IdentityBlocksByStatTypeClaimIssuerIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByStatTypeClaimIssuerIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypesByCreatedBlockId: StatTypesConnection;
};

/** A `Block` edge in the connection, with data from `StatType`. */
export type IdentityBlocksByStatTypeClaimIssuerIdAndCreatedBlockIdManyToManyEdgeStatTypesByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<StatTypesOrderBy>>;
    filter?: Maybe<StatTypeFilter>;
  };

/** A connection to a list of `Block` values, with data from `StatType`. */
export type IdentityBlocksByStatTypeClaimIssuerIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByStatTypeClaimIssuerIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `StatType`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByStatTypeClaimIssuerIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `StatType`. */
export type IdentityBlocksByStatTypeClaimIssuerIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `StatType`. */
export type IdentityBlocksByStatTypeClaimIssuerIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByStatTypeClaimIssuerIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypesByUpdatedBlockId: StatTypesConnection;
};

/** A `Block` edge in the connection, with data from `StatType`. */
export type IdentityBlocksByStatTypeClaimIssuerIdAndUpdatedBlockIdManyToManyEdgeStatTypesByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<StatTypesOrderBy>>;
    filter?: Maybe<StatTypeFilter>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentAction`. */
export type IdentityBlocksByTickerExternalAgentActionCallerIdAndCreatedBlockIdManyToManyConnection =
  {
    __typename?: 'IdentityBlocksByTickerExternalAgentActionCallerIdAndCreatedBlockIdManyToManyConnection';
    /** A list of `Block` objects. */
    nodes: Array<Maybe<Block>>;
    /** A list of edges which contains the `Block`, info from the `TickerExternalAgentAction`, and the cursor to aid in pagination. */
    edges: Array<IdentityBlocksByTickerExternalAgentActionCallerIdAndCreatedBlockIdManyToManyEdge>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Block` you could get from the connection. */
    totalCount: Scalars['Int'];
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<BlockAggregates>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<BlockAggregates>>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentAction`. */
export type IdentityBlocksByTickerExternalAgentActionCallerIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TickerExternalAgentAction`. */
export type IdentityBlocksByTickerExternalAgentActionCallerIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByTickerExternalAgentActionCallerIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TickerExternalAgentAction`. */
  tickerExternalAgentActionsByCreatedBlockId: TickerExternalAgentActionsConnection;
};

/** A `Block` edge in the connection, with data from `TickerExternalAgentAction`. */
export type IdentityBlocksByTickerExternalAgentActionCallerIdAndCreatedBlockIdManyToManyEdgeTickerExternalAgentActionsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TickerExternalAgentActionsOrderBy>>;
    filter?: Maybe<TickerExternalAgentActionFilter>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentAction`. */
export type IdentityBlocksByTickerExternalAgentActionCallerIdAndUpdatedBlockIdManyToManyConnection =
  {
    __typename?: 'IdentityBlocksByTickerExternalAgentActionCallerIdAndUpdatedBlockIdManyToManyConnection';
    /** A list of `Block` objects. */
    nodes: Array<Maybe<Block>>;
    /** A list of edges which contains the `Block`, info from the `TickerExternalAgentAction`, and the cursor to aid in pagination. */
    edges: Array<IdentityBlocksByTickerExternalAgentActionCallerIdAndUpdatedBlockIdManyToManyEdge>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Block` you could get from the connection. */
    totalCount: Scalars['Int'];
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<BlockAggregates>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<BlockAggregates>>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentAction`. */
export type IdentityBlocksByTickerExternalAgentActionCallerIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TickerExternalAgentAction`. */
export type IdentityBlocksByTickerExternalAgentActionCallerIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByTickerExternalAgentActionCallerIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TickerExternalAgentAction`. */
  tickerExternalAgentActionsByUpdatedBlockId: TickerExternalAgentActionsConnection;
};

/** A `Block` edge in the connection, with data from `TickerExternalAgentAction`. */
export type IdentityBlocksByTickerExternalAgentActionCallerIdAndUpdatedBlockIdManyToManyEdgeTickerExternalAgentActionsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TickerExternalAgentActionsOrderBy>>;
    filter?: Maybe<TickerExternalAgentActionFilter>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgent`. */
export type IdentityBlocksByTickerExternalAgentCallerIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByTickerExternalAgentCallerIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `TickerExternalAgent`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByTickerExternalAgentCallerIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `TickerExternalAgent`. */
export type IdentityBlocksByTickerExternalAgentCallerIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TickerExternalAgent`. */
export type IdentityBlocksByTickerExternalAgentCallerIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByTickerExternalAgentCallerIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TickerExternalAgent`. */
  tickerExternalAgentsByCreatedBlockId: TickerExternalAgentsConnection;
};

/** A `Block` edge in the connection, with data from `TickerExternalAgent`. */
export type IdentityBlocksByTickerExternalAgentCallerIdAndCreatedBlockIdManyToManyEdgeTickerExternalAgentsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TickerExternalAgentsOrderBy>>;
    filter?: Maybe<TickerExternalAgentFilter>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgent`. */
export type IdentityBlocksByTickerExternalAgentCallerIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByTickerExternalAgentCallerIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `TickerExternalAgent`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByTickerExternalAgentCallerIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `TickerExternalAgent`. */
export type IdentityBlocksByTickerExternalAgentCallerIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TickerExternalAgent`. */
export type IdentityBlocksByTickerExternalAgentCallerIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByTickerExternalAgentCallerIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TickerExternalAgent`. */
  tickerExternalAgentsByUpdatedBlockId: TickerExternalAgentsConnection;
};

/** A `Block` edge in the connection, with data from `TickerExternalAgent`. */
export type IdentityBlocksByTickerExternalAgentCallerIdAndUpdatedBlockIdManyToManyEdgeTickerExternalAgentsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TickerExternalAgentsOrderBy>>;
    filter?: Maybe<TickerExternalAgentFilter>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentHistory`. */
export type IdentityBlocksByTickerExternalAgentHistoryIdentityIdAndCreatedBlockIdManyToManyConnection =
  {
    __typename?: 'IdentityBlocksByTickerExternalAgentHistoryIdentityIdAndCreatedBlockIdManyToManyConnection';
    /** A list of `Block` objects. */
    nodes: Array<Maybe<Block>>;
    /** A list of edges which contains the `Block`, info from the `TickerExternalAgentHistory`, and the cursor to aid in pagination. */
    edges: Array<IdentityBlocksByTickerExternalAgentHistoryIdentityIdAndCreatedBlockIdManyToManyEdge>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Block` you could get from the connection. */
    totalCount: Scalars['Int'];
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<BlockAggregates>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<BlockAggregates>>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentHistory`. */
export type IdentityBlocksByTickerExternalAgentHistoryIdentityIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type IdentityBlocksByTickerExternalAgentHistoryIdentityIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByTickerExternalAgentHistoryIdentityIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TickerExternalAgentHistory`. */
  tickerExternalAgentHistoriesByCreatedBlockId: TickerExternalAgentHistoriesConnection;
};

/** A `Block` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type IdentityBlocksByTickerExternalAgentHistoryIdentityIdAndCreatedBlockIdManyToManyEdgeTickerExternalAgentHistoriesByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TickerExternalAgentHistoriesOrderBy>>;
    filter?: Maybe<TickerExternalAgentHistoryFilter>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentHistory`. */
export type IdentityBlocksByTickerExternalAgentHistoryIdentityIdAndUpdatedBlockIdManyToManyConnection =
  {
    __typename?: 'IdentityBlocksByTickerExternalAgentHistoryIdentityIdAndUpdatedBlockIdManyToManyConnection';
    /** A list of `Block` objects. */
    nodes: Array<Maybe<Block>>;
    /** A list of edges which contains the `Block`, info from the `TickerExternalAgentHistory`, and the cursor to aid in pagination. */
    edges: Array<IdentityBlocksByTickerExternalAgentHistoryIdentityIdAndUpdatedBlockIdManyToManyEdge>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Block` you could get from the connection. */
    totalCount: Scalars['Int'];
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<BlockAggregates>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<BlockAggregates>>;
  };

/** A connection to a list of `Block` values, with data from `TickerExternalAgentHistory`. */
export type IdentityBlocksByTickerExternalAgentHistoryIdentityIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type IdentityBlocksByTickerExternalAgentHistoryIdentityIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByTickerExternalAgentHistoryIdentityIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TickerExternalAgentHistory`. */
  tickerExternalAgentHistoriesByUpdatedBlockId: TickerExternalAgentHistoriesConnection;
};

/** A `Block` edge in the connection, with data from `TickerExternalAgentHistory`. */
export type IdentityBlocksByTickerExternalAgentHistoryIdentityIdAndUpdatedBlockIdManyToManyEdgeTickerExternalAgentHistoriesByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TickerExternalAgentHistoriesOrderBy>>;
    filter?: Maybe<TickerExternalAgentHistoryFilter>;
  };

/** A connection to a list of `Block` values, with data from `TransferCompliance`. */
export type IdentityBlocksByTransferComplianceClaimIssuerIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByTransferComplianceClaimIssuerIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByTransferComplianceClaimIssuerIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `TransferCompliance`. */
export type IdentityBlocksByTransferComplianceClaimIssuerIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TransferCompliance`. */
export type IdentityBlocksByTransferComplianceClaimIssuerIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByTransferComplianceClaimIssuerIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliancesByCreatedBlockId: TransferCompliancesConnection;
};

/** A `Block` edge in the connection, with data from `TransferCompliance`. */
export type IdentityBlocksByTransferComplianceClaimIssuerIdAndCreatedBlockIdManyToManyEdgeTransferCompliancesByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TransferCompliancesOrderBy>>;
    filter?: Maybe<TransferComplianceFilter>;
  };

/** A connection to a list of `Block` values, with data from `TransferCompliance`. */
export type IdentityBlocksByTransferComplianceClaimIssuerIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByTransferComplianceClaimIssuerIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByTransferComplianceClaimIssuerIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `TransferCompliance`. */
export type IdentityBlocksByTransferComplianceClaimIssuerIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TransferCompliance`. */
export type IdentityBlocksByTransferComplianceClaimIssuerIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByTransferComplianceClaimIssuerIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliancesByUpdatedBlockId: TransferCompliancesConnection;
};

/** A `Block` edge in the connection, with data from `TransferCompliance`. */
export type IdentityBlocksByTransferComplianceClaimIssuerIdAndUpdatedBlockIdManyToManyEdgeTransferCompliancesByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TransferCompliancesOrderBy>>;
    filter?: Maybe<TransferComplianceFilter>;
  };

/** A connection to a list of `Block` values, with data from `Venue`. */
export type IdentityBlocksByVenueOwnerIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByVenueOwnerIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Venue`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByVenueOwnerIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Venue`. */
export type IdentityBlocksByVenueOwnerIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Venue`. */
export type IdentityBlocksByVenueOwnerIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByVenueOwnerIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Venue`. */
  venuesByCreatedBlockId: VenuesConnection;
};

/** A `Block` edge in the connection, with data from `Venue`. */
export type IdentityBlocksByVenueOwnerIdAndCreatedBlockIdManyToManyEdgeVenuesByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<VenuesOrderBy>>;
    filter?: Maybe<VenueFilter>;
  };

/** A connection to a list of `Block` values, with data from `Venue`. */
export type IdentityBlocksByVenueOwnerIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'IdentityBlocksByVenueOwnerIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Venue`, and the cursor to aid in pagination. */
  edges: Array<IdentityBlocksByVenueOwnerIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Venue`. */
export type IdentityBlocksByVenueOwnerIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Venue`. */
export type IdentityBlocksByVenueOwnerIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'IdentityBlocksByVenueOwnerIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Venue`. */
  venuesByUpdatedBlockId: VenuesConnection;
};

/** A `Block` edge in the connection, with data from `Venue`. */
export type IdentityBlocksByVenueOwnerIdAndUpdatedBlockIdManyToManyEdgeVenuesByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<VenuesOrderBy>>;
    filter?: Maybe<VenueFilter>;
  };

/** A connection to a list of `Distribution` values, with data from `DistributionPayment`. */
export type IdentityDistributionsByDistributionPaymentTargetIdAndDistributionIdManyToManyConnection =
  {
    __typename?: 'IdentityDistributionsByDistributionPaymentTargetIdAndDistributionIdManyToManyConnection';
    /** A list of `Distribution` objects. */
    nodes: Array<Maybe<Distribution>>;
    /** A list of edges which contains the `Distribution`, info from the `DistributionPayment`, and the cursor to aid in pagination. */
    edges: Array<IdentityDistributionsByDistributionPaymentTargetIdAndDistributionIdManyToManyEdge>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
    /** The count of *all* `Distribution` you could get from the connection. */
    totalCount: Scalars['Int'];
    /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
    aggregates?: Maybe<DistributionAggregates>;
    /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
    groupedAggregates?: Maybe<Array<DistributionAggregates>>;
  };

/** A connection to a list of `Distribution` values, with data from `DistributionPayment`. */
export type IdentityDistributionsByDistributionPaymentTargetIdAndDistributionIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<DistributionsGroupBy>;
    having?: Maybe<DistributionsHavingInput>;
  };

/** A `Distribution` edge in the connection, with data from `DistributionPayment`. */
export type IdentityDistributionsByDistributionPaymentTargetIdAndDistributionIdManyToManyEdge = {
  __typename?: 'IdentityDistributionsByDistributionPaymentTargetIdAndDistributionIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Distribution` at the end of the edge. */
  node?: Maybe<Distribution>;
  /** Reads and enables pagination through a set of `DistributionPayment`. */
  distributionPayments: DistributionPaymentsConnection;
};

/** A `Distribution` edge in the connection, with data from `DistributionPayment`. */
export type IdentityDistributionsByDistributionPaymentTargetIdAndDistributionIdManyToManyEdgeDistributionPaymentsArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<DistributionPaymentsOrderBy>>;
    filter?: Maybe<DistributionPaymentFilter>;
  };

/** A filter to be used against `Identity` object types. All fields are combined with a logical ‘and.’ */
export type IdentityFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `did` field. */
  did?: Maybe<StringFilter>;
  /** Filter by the object’s `primaryAccount` field. */
  primaryAccount?: Maybe<StringFilter>;
  /** Filter by the object’s `secondaryKeysFrozen` field. */
  secondaryKeysFrozen?: Maybe<BooleanFilter>;
  /** Filter by the object’s `eventId` field. */
  eventId?: Maybe<StringFilter>;
  /** Filter by the object’s `datetime` field. */
  datetime?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<IdentityFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<IdentityFilter>>;
  /** Negates the expression. */
  not?: Maybe<IdentityFilter>;
};

/** A connection to a list of `Identity` values, with data from `Authorization`. */
export type IdentityIdentitiesByAuthorizationFromIdAndToIdManyToManyConnection = {
  __typename?: 'IdentityIdentitiesByAuthorizationFromIdAndToIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `Authorization`, and the cursor to aid in pagination. */
  edges: Array<IdentityIdentitiesByAuthorizationFromIdAndToIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `Authorization`. */
export type IdentityIdentitiesByAuthorizationFromIdAndToIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Authorization`. */
export type IdentityIdentitiesByAuthorizationFromIdAndToIdManyToManyEdge = {
  __typename?: 'IdentityIdentitiesByAuthorizationFromIdAndToIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Authorization`. */
  authorizationsByToId: AuthorizationsConnection;
};

/** A `Identity` edge in the connection, with data from `Authorization`. */
export type IdentityIdentitiesByAuthorizationFromIdAndToIdManyToManyEdgeAuthorizationsByToIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AuthorizationsOrderBy>>;
  filter?: Maybe<AuthorizationFilter>;
};

/** A connection to a list of `Identity` values, with data from `Authorization`. */
export type IdentityIdentitiesByAuthorizationToIdAndFromIdManyToManyConnection = {
  __typename?: 'IdentityIdentitiesByAuthorizationToIdAndFromIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `Authorization`, and the cursor to aid in pagination. */
  edges: Array<IdentityIdentitiesByAuthorizationToIdAndFromIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `Authorization`. */
export type IdentityIdentitiesByAuthorizationToIdAndFromIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Authorization`. */
export type IdentityIdentitiesByAuthorizationToIdAndFromIdManyToManyEdge = {
  __typename?: 'IdentityIdentitiesByAuthorizationToIdAndFromIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Authorization`. */
  authorizationsByFromId: AuthorizationsConnection;
};

/** A `Identity` edge in the connection, with data from `Authorization`. */
export type IdentityIdentitiesByAuthorizationToIdAndFromIdManyToManyEdgeAuthorizationsByFromIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AuthorizationsOrderBy>>;
    filter?: Maybe<AuthorizationFilter>;
  };

/** A connection to a list of `Identity` values, with data from `Claim`. */
export type IdentityIdentitiesByClaimIssuerIdAndTargetIdManyToManyConnection = {
  __typename?: 'IdentityIdentitiesByClaimIssuerIdAndTargetIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `Claim`, and the cursor to aid in pagination. */
  edges: Array<IdentityIdentitiesByClaimIssuerIdAndTargetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `Claim`. */
export type IdentityIdentitiesByClaimIssuerIdAndTargetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Claim`. */
export type IdentityIdentitiesByClaimIssuerIdAndTargetIdManyToManyEdge = {
  __typename?: 'IdentityIdentitiesByClaimIssuerIdAndTargetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Claim`. */
  claimsByTargetId: ClaimsConnection;
};

/** A `Identity` edge in the connection, with data from `Claim`. */
export type IdentityIdentitiesByClaimIssuerIdAndTargetIdManyToManyEdgeClaimsByTargetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ClaimsOrderBy>>;
  filter?: Maybe<ClaimFilter>;
};

/** A connection to a list of `Identity` values, with data from `Claim`. */
export type IdentityIdentitiesByClaimTargetIdAndIssuerIdManyToManyConnection = {
  __typename?: 'IdentityIdentitiesByClaimTargetIdAndIssuerIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `Claim`, and the cursor to aid in pagination. */
  edges: Array<IdentityIdentitiesByClaimTargetIdAndIssuerIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `Claim`. */
export type IdentityIdentitiesByClaimTargetIdAndIssuerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Claim`. */
export type IdentityIdentitiesByClaimTargetIdAndIssuerIdManyToManyEdge = {
  __typename?: 'IdentityIdentitiesByClaimTargetIdAndIssuerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Claim`. */
  claimsByIssuerId: ClaimsConnection;
};

/** A `Identity` edge in the connection, with data from `Claim`. */
export type IdentityIdentitiesByClaimTargetIdAndIssuerIdManyToManyEdgeClaimsByIssuerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ClaimsOrderBy>>;
  filter?: Maybe<ClaimFilter>;
};

/** A connection to a list of `Identity` values, with data from `Portfolio`. */
export type IdentityIdentitiesByPortfolioCustodianIdAndIdentityIdManyToManyConnection = {
  __typename?: 'IdentityIdentitiesByPortfolioCustodianIdAndIdentityIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `Portfolio`, and the cursor to aid in pagination. */
  edges: Array<IdentityIdentitiesByPortfolioCustodianIdAndIdentityIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `Portfolio`. */
export type IdentityIdentitiesByPortfolioCustodianIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Portfolio`. */
export type IdentityIdentitiesByPortfolioCustodianIdAndIdentityIdManyToManyEdge = {
  __typename?: 'IdentityIdentitiesByPortfolioCustodianIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfolios: PortfoliosConnection;
};

/** A `Identity` edge in the connection, with data from `Portfolio`. */
export type IdentityIdentitiesByPortfolioCustodianIdAndIdentityIdManyToManyEdgePortfoliosArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PortfoliosOrderBy>>;
  filter?: Maybe<PortfolioFilter>;
};

/** A connection to a list of `Identity` values, with data from `Portfolio`. */
export type IdentityIdentitiesByPortfolioIdentityIdAndCustodianIdManyToManyConnection = {
  __typename?: 'IdentityIdentitiesByPortfolioIdentityIdAndCustodianIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `Portfolio`, and the cursor to aid in pagination. */
  edges: Array<IdentityIdentitiesByPortfolioIdentityIdAndCustodianIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `Portfolio`. */
export type IdentityIdentitiesByPortfolioIdentityIdAndCustodianIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Portfolio`. */
export type IdentityIdentitiesByPortfolioIdentityIdAndCustodianIdManyToManyEdge = {
  __typename?: 'IdentityIdentitiesByPortfolioIdentityIdAndCustodianIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByCustodianId: PortfoliosConnection;
};

/** A `Identity` edge in the connection, with data from `Portfolio`. */
export type IdentityIdentitiesByPortfolioIdentityIdAndCustodianIdManyToManyEdgePortfoliosByCustodianIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<PortfoliosOrderBy>>;
    filter?: Maybe<PortfolioFilter>;
  };

/** A connection to a list of `Permission` values, with data from `Account`. */
export type IdentityPermissionsByAccountIdentityIdAndPermissionsIdManyToManyConnection = {
  __typename?: 'IdentityPermissionsByAccountIdentityIdAndPermissionsIdManyToManyConnection';
  /** A list of `Permission` objects. */
  nodes: Array<Maybe<Permission>>;
  /** A list of edges which contains the `Permission`, info from the `Account`, and the cursor to aid in pagination. */
  edges: Array<IdentityPermissionsByAccountIdentityIdAndPermissionsIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Permission` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PermissionAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PermissionAggregates>>;
};

/** A connection to a list of `Permission` values, with data from `Account`. */
export type IdentityPermissionsByAccountIdentityIdAndPermissionsIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PermissionsGroupBy>;
    having?: Maybe<PermissionsHavingInput>;
  };

/** A `Permission` edge in the connection, with data from `Account`. */
export type IdentityPermissionsByAccountIdentityIdAndPermissionsIdManyToManyEdge = {
  __typename?: 'IdentityPermissionsByAccountIdentityIdAndPermissionsIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Permission` at the end of the edge. */
  node?: Maybe<Permission>;
  /** Reads and enables pagination through a set of `Account`. */
  accountsByPermissionsId: AccountsConnection;
};

/** A `Permission` edge in the connection, with data from `Account`. */
export type IdentityPermissionsByAccountIdentityIdAndPermissionsIdManyToManyEdgeAccountsByPermissionsIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AccountsOrderBy>>;
    filter?: Maybe<AccountFilter>;
  };

/** A connection to a list of `Portfolio` values, with data from `Distribution`. */
export type IdentityPortfoliosByDistributionIdentityIdAndPortfolioIdManyToManyConnection = {
  __typename?: 'IdentityPortfoliosByDistributionIdentityIdAndPortfolioIdManyToManyConnection';
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** A list of edges which contains the `Portfolio`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<IdentityPortfoliosByDistributionIdentityIdAndPortfolioIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
};

/** A connection to a list of `Portfolio` values, with data from `Distribution`. */
export type IdentityPortfoliosByDistributionIdentityIdAndPortfolioIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: Maybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `Distribution`. */
export type IdentityPortfoliosByDistributionIdentityIdAndPortfolioIdManyToManyEdge = {
  __typename?: 'IdentityPortfoliosByDistributionIdentityIdAndPortfolioIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributions: DistributionsConnection;
};

/** A `Portfolio` edge in the connection, with data from `Distribution`. */
export type IdentityPortfoliosByDistributionIdentityIdAndPortfolioIdManyToManyEdgeDistributionsArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<DistributionsOrderBy>>;
    filter?: Maybe<DistributionFilter>;
  };

/** A connection to a list of `StatType` values, with data from `TransferCompliance`. */
export type IdentityStatTypesByTransferComplianceClaimIssuerIdAndStatTypeIdManyToManyConnection = {
  __typename?: 'IdentityStatTypesByTransferComplianceClaimIssuerIdAndStatTypeIdManyToManyConnection';
  /** A list of `StatType` objects. */
  nodes: Array<Maybe<StatType>>;
  /** A list of edges which contains the `StatType`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
  edges: Array<IdentityStatTypesByTransferComplianceClaimIssuerIdAndStatTypeIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `StatType` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<StatTypeAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<StatTypeAggregates>>;
};

/** A connection to a list of `StatType` values, with data from `TransferCompliance`. */
export type IdentityStatTypesByTransferComplianceClaimIssuerIdAndStatTypeIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<StatTypesGroupBy>;
    having?: Maybe<StatTypesHavingInput>;
  };

/** A `StatType` edge in the connection, with data from `TransferCompliance`. */
export type IdentityStatTypesByTransferComplianceClaimIssuerIdAndStatTypeIdManyToManyEdge = {
  __typename?: 'IdentityStatTypesByTransferComplianceClaimIssuerIdAndStatTypeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `StatType` at the end of the edge. */
  node?: Maybe<StatType>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliances: TransferCompliancesConnection;
};

/** A `StatType` edge in the connection, with data from `TransferCompliance`. */
export type IdentityStatTypesByTransferComplianceClaimIssuerIdAndStatTypeIdManyToManyEdgeTransferCompliancesArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TransferCompliancesOrderBy>>;
    filter?: Maybe<TransferComplianceFilter>;
  };

export type Instruction = Node & {
  __typename?: 'Instruction';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  eventId: Scalars['String'];
  eventIdx: Scalars['Int'];
  status: Scalars['String'];
  venueId: Scalars['String'];
  settlementType: Scalars['String'];
  endBlock?: Maybe<Scalars['Int']>;
  tradeDate?: Maybe<Scalars['Datetime']>;
  valueDate?: Maybe<Scalars['Datetime']>;
  addresses: Scalars['JSON'];
  createdBlockId: Scalars['String'];
  updatedBlockId: Scalars['String'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Venue` that is related to this `Instruction`. */
  venue?: Maybe<Venue>;
  /** Reads a single `Block` that is related to this `Instruction`. */
  createdBlock?: Maybe<Block>;
  /** Reads a single `Block` that is related to this `Instruction`. */
  updatedBlock?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Leg`. */
  legs: LegsConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByLegInstructionIdAndFromId: InstructionPortfoliosByLegInstructionIdAndFromIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByLegInstructionIdAndToId: InstructionPortfoliosByLegInstructionIdAndToIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Settlement`. */
  settlementsByLegInstructionIdAndSettlementId: InstructionSettlementsByLegInstructionIdAndSettlementIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByLegInstructionIdAndCreatedBlockId: InstructionBlocksByLegInstructionIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByLegInstructionIdAndUpdatedBlockId: InstructionBlocksByLegInstructionIdAndUpdatedBlockIdManyToManyConnection;
};

export type InstructionLegsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<LegsOrderBy>>;
  filter?: Maybe<LegFilter>;
};

export type InstructionPortfoliosByLegInstructionIdAndFromIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PortfoliosOrderBy>>;
  filter?: Maybe<PortfolioFilter>;
};

export type InstructionPortfoliosByLegInstructionIdAndToIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PortfoliosOrderBy>>;
  filter?: Maybe<PortfolioFilter>;
};

export type InstructionSettlementsByLegInstructionIdAndSettlementIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<SettlementsOrderBy>>;
  filter?: Maybe<SettlementFilter>;
};

export type InstructionBlocksByLegInstructionIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type InstructionBlocksByLegInstructionIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type InstructionAggregates = {
  __typename?: 'InstructionAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A connection to a list of `Block` values, with data from `Leg`. */
export type InstructionBlocksByLegInstructionIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'InstructionBlocksByLegInstructionIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<InstructionBlocksByLegInstructionIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Leg`. */
export type InstructionBlocksByLegInstructionIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Leg`. */
export type InstructionBlocksByLegInstructionIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'InstructionBlocksByLegInstructionIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByCreatedBlockId: LegsConnection;
};

/** A `Block` edge in the connection, with data from `Leg`. */
export type InstructionBlocksByLegInstructionIdAndCreatedBlockIdManyToManyEdgeLegsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<LegsOrderBy>>;
    filter?: Maybe<LegFilter>;
  };

/** A connection to a list of `Block` values, with data from `Leg`. */
export type InstructionBlocksByLegInstructionIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'InstructionBlocksByLegInstructionIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<InstructionBlocksByLegInstructionIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Leg`. */
export type InstructionBlocksByLegInstructionIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Leg`. */
export type InstructionBlocksByLegInstructionIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'InstructionBlocksByLegInstructionIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByUpdatedBlockId: LegsConnection;
};

/** A `Block` edge in the connection, with data from `Leg`. */
export type InstructionBlocksByLegInstructionIdAndUpdatedBlockIdManyToManyEdgeLegsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<LegsOrderBy>>;
    filter?: Maybe<LegFilter>;
  };

/** A filter to be used against `Instruction` object types. All fields are combined with a logical ‘and.’ */
export type InstructionFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `eventId` field. */
  eventId?: Maybe<StringFilter>;
  /** Filter by the object’s `eventIdx` field. */
  eventIdx?: Maybe<IntFilter>;
  /** Filter by the object’s `status` field. */
  status?: Maybe<StringFilter>;
  /** Filter by the object’s `venueId` field. */
  venueId?: Maybe<StringFilter>;
  /** Filter by the object’s `settlementType` field. */
  settlementType?: Maybe<StringFilter>;
  /** Filter by the object’s `endBlock` field. */
  endBlock?: Maybe<IntFilter>;
  /** Filter by the object’s `tradeDate` field. */
  tradeDate?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `valueDate` field. */
  valueDate?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `addresses` field. */
  addresses?: Maybe<JsonFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<InstructionFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<InstructionFilter>>;
  /** Negates the expression. */
  not?: Maybe<InstructionFilter>;
};

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type InstructionPortfoliosByLegInstructionIdAndFromIdManyToManyConnection = {
  __typename?: 'InstructionPortfoliosByLegInstructionIdAndFromIdManyToManyConnection';
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** A list of edges which contains the `Portfolio`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<InstructionPortfoliosByLegInstructionIdAndFromIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
};

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type InstructionPortfoliosByLegInstructionIdAndFromIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: Maybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type InstructionPortfoliosByLegInstructionIdAndFromIdManyToManyEdge = {
  __typename?: 'InstructionPortfoliosByLegInstructionIdAndFromIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByFromId: LegsConnection;
};

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type InstructionPortfoliosByLegInstructionIdAndFromIdManyToManyEdgeLegsByFromIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<LegsOrderBy>>;
  filter?: Maybe<LegFilter>;
};

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type InstructionPortfoliosByLegInstructionIdAndToIdManyToManyConnection = {
  __typename?: 'InstructionPortfoliosByLegInstructionIdAndToIdManyToManyConnection';
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** A list of edges which contains the `Portfolio`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<InstructionPortfoliosByLegInstructionIdAndToIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
};

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type InstructionPortfoliosByLegInstructionIdAndToIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: Maybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type InstructionPortfoliosByLegInstructionIdAndToIdManyToManyEdge = {
  __typename?: 'InstructionPortfoliosByLegInstructionIdAndToIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByToId: LegsConnection;
};

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type InstructionPortfoliosByLegInstructionIdAndToIdManyToManyEdgeLegsByToIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<LegsOrderBy>>;
  filter?: Maybe<LegFilter>;
};

/** A connection to a list of `Settlement` values, with data from `Leg`. */
export type InstructionSettlementsByLegInstructionIdAndSettlementIdManyToManyConnection = {
  __typename?: 'InstructionSettlementsByLegInstructionIdAndSettlementIdManyToManyConnection';
  /** A list of `Settlement` objects. */
  nodes: Array<Maybe<Settlement>>;
  /** A list of edges which contains the `Settlement`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<InstructionSettlementsByLegInstructionIdAndSettlementIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Settlement` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<SettlementAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<SettlementAggregates>>;
};

/** A connection to a list of `Settlement` values, with data from `Leg`. */
export type InstructionSettlementsByLegInstructionIdAndSettlementIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<SettlementsGroupBy>;
    having?: Maybe<SettlementsHavingInput>;
  };

/** A `Settlement` edge in the connection, with data from `Leg`. */
export type InstructionSettlementsByLegInstructionIdAndSettlementIdManyToManyEdge = {
  __typename?: 'InstructionSettlementsByLegInstructionIdAndSettlementIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Settlement` at the end of the edge. */
  node?: Maybe<Settlement>;
  /** Reads and enables pagination through a set of `Leg`. */
  legs: LegsConnection;
};

/** A `Settlement` edge in the connection, with data from `Leg`. */
export type InstructionSettlementsByLegInstructionIdAndSettlementIdManyToManyEdgeLegsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<LegsOrderBy>>;
  filter?: Maybe<LegFilter>;
};

/** A connection to a list of `Instruction` values. */
export type InstructionsConnection = {
  __typename?: 'InstructionsConnection';
  /** A list of `Instruction` objects. */
  nodes: Array<Maybe<Instruction>>;
  /** A list of edges which contains the `Instruction` and cursor to aid in pagination. */
  edges: Array<InstructionsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Instruction` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<InstructionAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<InstructionAggregates>>;
};

/** A connection to a list of `Instruction` values. */
export type InstructionsConnectionGroupedAggregatesArgs = {
  groupBy: Array<InstructionsGroupBy>;
  having?: Maybe<InstructionsHavingInput>;
};

/** A `Instruction` edge in the connection. */
export type InstructionsEdge = {
  __typename?: 'InstructionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Instruction` at the end of the edge. */
  node?: Maybe<Instruction>;
};

/** Grouping methods for `Instruction` for usage during aggregation. */
export enum InstructionsGroupBy {
  EventId = 'EVENT_ID',
  EventIdx = 'EVENT_IDX',
  Status = 'STATUS',
  VenueId = 'VENUE_ID',
  SettlementType = 'SETTLEMENT_TYPE',
  EndBlock = 'END_BLOCK',
  TradeDate = 'TRADE_DATE',
  ValueDate = 'VALUE_DATE',
  Addresses = 'ADDRESSES',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `Instruction` aggregates. */
export type InstructionsHavingInput = {
  AND?: Maybe<Array<InstructionsHavingInput>>;
  OR?: Maybe<Array<InstructionsHavingInput>>;
};

/** Methods to use when ordering `Instruction`. */
export enum InstructionsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  EventIdAsc = 'EVENT_ID_ASC',
  EventIdDesc = 'EVENT_ID_DESC',
  EventIdxAsc = 'EVENT_IDX_ASC',
  EventIdxDesc = 'EVENT_IDX_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  VenueIdAsc = 'VENUE_ID_ASC',
  VenueIdDesc = 'VENUE_ID_DESC',
  SettlementTypeAsc = 'SETTLEMENT_TYPE_ASC',
  SettlementTypeDesc = 'SETTLEMENT_TYPE_DESC',
  EndBlockAsc = 'END_BLOCK_ASC',
  EndBlockDesc = 'END_BLOCK_DESC',
  TradeDateAsc = 'TRADE_DATE_ASC',
  TradeDateDesc = 'TRADE_DATE_DESC',
  ValueDateAsc = 'VALUE_DATE_ASC',
  ValueDateDesc = 'VALUE_DATE_DESC',
  AddressesAsc = 'ADDRESSES_ASC',
  AddressesDesc = 'ADDRESSES_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  LegsCountAsc = 'LEGS_COUNT_ASC',
  LegsCountDesc = 'LEGS_COUNT_DESC',
}

/** A filter to be used against Int fields. All fields are combined with a logical ‘and.’ */
export type IntFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Int']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Int']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Int']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Int']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Int']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Int']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Int']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Int']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Int']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Int']>;
};

export type Investment = Node & {
  __typename?: 'Investment';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  investorId: Scalars['String'];
  stoId: Scalars['Int'];
  offeringToken: Scalars['String'];
  raiseToken: Scalars['String'];
  offeringTokenAmount: Scalars['BigFloat'];
  raiseTokenAmount: Scalars['BigFloat'];
  datetime: Scalars['Datetime'];
  createdBlockId: Scalars['String'];
  updatedBlockId: Scalars['String'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Identity` that is related to this `Investment`. */
  investor?: Maybe<Identity>;
  /** Reads a single `Block` that is related to this `Investment`. */
  createdBlock?: Maybe<Block>;
  /** Reads a single `Block` that is related to this `Investment`. */
  updatedBlock?: Maybe<Block>;
};

export type InvestmentAggregates = {
  __typename?: 'InvestmentAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `Investment` object types. All fields are combined with a logical ‘and.’ */
export type InvestmentFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `investorId` field. */
  investorId?: Maybe<StringFilter>;
  /** Filter by the object’s `stoId` field. */
  stoId?: Maybe<IntFilter>;
  /** Filter by the object’s `offeringToken` field. */
  offeringToken?: Maybe<StringFilter>;
  /** Filter by the object’s `raiseToken` field. */
  raiseToken?: Maybe<StringFilter>;
  /** Filter by the object’s `offeringTokenAmount` field. */
  offeringTokenAmount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `raiseTokenAmount` field. */
  raiseTokenAmount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `datetime` field. */
  datetime?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<InvestmentFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<InvestmentFilter>>;
  /** Negates the expression. */
  not?: Maybe<InvestmentFilter>;
};

/** A connection to a list of `Investment` values. */
export type InvestmentsConnection = {
  __typename?: 'InvestmentsConnection';
  /** A list of `Investment` objects. */
  nodes: Array<Maybe<Investment>>;
  /** A list of edges which contains the `Investment` and cursor to aid in pagination. */
  edges: Array<InvestmentsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Investment` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<InvestmentAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<InvestmentAggregates>>;
};

/** A connection to a list of `Investment` values. */
export type InvestmentsConnectionGroupedAggregatesArgs = {
  groupBy: Array<InvestmentsGroupBy>;
  having?: Maybe<InvestmentsHavingInput>;
};

/** A `Investment` edge in the connection. */
export type InvestmentsEdge = {
  __typename?: 'InvestmentsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Investment` at the end of the edge. */
  node?: Maybe<Investment>;
};

/** Grouping methods for `Investment` for usage during aggregation. */
export enum InvestmentsGroupBy {
  InvestorId = 'INVESTOR_ID',
  StoId = 'STO_ID',
  OfferingToken = 'OFFERING_TOKEN',
  RaiseToken = 'RAISE_TOKEN',
  OfferingTokenAmount = 'OFFERING_TOKEN_AMOUNT',
  RaiseTokenAmount = 'RAISE_TOKEN_AMOUNT',
  Datetime = 'DATETIME',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `Investment` aggregates. */
export type InvestmentsHavingInput = {
  AND?: Maybe<Array<InvestmentsHavingInput>>;
  OR?: Maybe<Array<InvestmentsHavingInput>>;
};

/** Methods to use when ordering `Investment`. */
export enum InvestmentsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InvestorIdAsc = 'INVESTOR_ID_ASC',
  InvestorIdDesc = 'INVESTOR_ID_DESC',
  StoIdAsc = 'STO_ID_ASC',
  StoIdDesc = 'STO_ID_DESC',
  OfferingTokenAsc = 'OFFERING_TOKEN_ASC',
  OfferingTokenDesc = 'OFFERING_TOKEN_DESC',
  RaiseTokenAsc = 'RAISE_TOKEN_ASC',
  RaiseTokenDesc = 'RAISE_TOKEN_DESC',
  OfferingTokenAmountAsc = 'OFFERING_TOKEN_AMOUNT_ASC',
  OfferingTokenAmountDesc = 'OFFERING_TOKEN_AMOUNT_DESC',
  RaiseTokenAmountAsc = 'RAISE_TOKEN_AMOUNT_ASC',
  RaiseTokenAmountDesc = 'RAISE_TOKEN_AMOUNT_DESC',
  DatetimeAsc = 'DATETIME_ASC',
  DatetimeDesc = 'DATETIME_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
}

/** A filter to be used against JSON fields. All fields are combined with a logical ‘and.’ */
export type JsonFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['JSON']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['JSON']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['JSON']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['JSON']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['JSON']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['JSON']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['JSON']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['JSON']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['JSON']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['JSON']>;
  /** Contains the specified JSON. */
  contains?: Maybe<Scalars['JSON']>;
  /** Contains the specified key. */
  containsKey?: Maybe<Scalars['String']>;
  /** Contains all of the specified keys. */
  containsAllKeys?: Maybe<Array<Scalars['String']>>;
  /** Contains any of the specified keys. */
  containsAnyKeys?: Maybe<Array<Scalars['String']>>;
  /** Contained by the specified JSON. */
  containedBy?: Maybe<Scalars['JSON']>;
};

export type Leg = Node & {
  __typename?: 'Leg';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  ticker: Scalars['String'];
  amount: Scalars['BigFloat'];
  fromId: Scalars['String'];
  toId: Scalars['String'];
  instructionId?: Maybe<Scalars['String']>;
  settlementId?: Maybe<Scalars['String']>;
  createdBlockId: Scalars['String'];
  updatedBlockId: Scalars['String'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Portfolio` that is related to this `Leg`. */
  from?: Maybe<Portfolio>;
  /** Reads a single `Portfolio` that is related to this `Leg`. */
  to?: Maybe<Portfolio>;
  /** Reads a single `Instruction` that is related to this `Leg`. */
  instruction?: Maybe<Instruction>;
  /** Reads a single `Settlement` that is related to this `Leg`. */
  settlement?: Maybe<Settlement>;
  /** Reads a single `Block` that is related to this `Leg`. */
  createdBlock?: Maybe<Block>;
  /** Reads a single `Block` that is related to this `Leg`. */
  updatedBlock?: Maybe<Block>;
};

export type LegAggregates = {
  __typename?: 'LegAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `Leg` object types. All fields are combined with a logical ‘and.’ */
export type LegFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `ticker` field. */
  ticker?: Maybe<StringFilter>;
  /** Filter by the object’s `amount` field. */
  amount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `fromId` field. */
  fromId?: Maybe<StringFilter>;
  /** Filter by the object’s `toId` field. */
  toId?: Maybe<StringFilter>;
  /** Filter by the object’s `instructionId` field. */
  instructionId?: Maybe<StringFilter>;
  /** Filter by the object’s `settlementId` field. */
  settlementId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<LegFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<LegFilter>>;
  /** Negates the expression. */
  not?: Maybe<LegFilter>;
};

/** A connection to a list of `Leg` values. */
export type LegsConnection = {
  __typename?: 'LegsConnection';
  /** A list of `Leg` objects. */
  nodes: Array<Maybe<Leg>>;
  /** A list of edges which contains the `Leg` and cursor to aid in pagination. */
  edges: Array<LegsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Leg` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<LegAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<LegAggregates>>;
};

/** A connection to a list of `Leg` values. */
export type LegsConnectionGroupedAggregatesArgs = {
  groupBy: Array<LegsGroupBy>;
  having?: Maybe<LegsHavingInput>;
};

/** A `Leg` edge in the connection. */
export type LegsEdge = {
  __typename?: 'LegsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Leg` at the end of the edge. */
  node?: Maybe<Leg>;
};

/** Grouping methods for `Leg` for usage during aggregation. */
export enum LegsGroupBy {
  Ticker = 'TICKER',
  Amount = 'AMOUNT',
  FromId = 'FROM_ID',
  ToId = 'TO_ID',
  InstructionId = 'INSTRUCTION_ID',
  SettlementId = 'SETTLEMENT_ID',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `Leg` aggregates. */
export type LegsHavingInput = {
  AND?: Maybe<Array<LegsHavingInput>>;
  OR?: Maybe<Array<LegsHavingInput>>;
};

/** Methods to use when ordering `Leg`. */
export enum LegsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  TickerAsc = 'TICKER_ASC',
  TickerDesc = 'TICKER_DESC',
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  FromIdAsc = 'FROM_ID_ASC',
  FromIdDesc = 'FROM_ID_DESC',
  ToIdAsc = 'TO_ID_ASC',
  ToIdDesc = 'TO_ID_DESC',
  InstructionIdAsc = 'INSTRUCTION_ID_ASC',
  InstructionIdDesc = 'INSTRUCTION_ID_DESC',
  SettlementIdAsc = 'SETTLEMENT_ID_ASC',
  SettlementIdDesc = 'SETTLEMENT_ID_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
}

/** An object with a globally unique `ID`. */
export type Node = {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']>;
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']>;
};

export type Permission = Node & {
  __typename?: 'Permission';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  assets?: Maybe<Scalars['JSON']>;
  portfolios?: Maybe<Scalars['JSON']>;
  transactions?: Maybe<Scalars['JSON']>;
  transactionGroups: Scalars['JSON'];
  datetime: Scalars['Datetime'];
  createdBlockId: Scalars['String'];
  updatedBlockId: Scalars['String'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Block` that is related to this `Permission`. */
  createdBlock?: Maybe<Block>;
  /** Reads a single `Block` that is related to this `Permission`. */
  updatedBlock?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Account`. */
  accountsByPermissionsId: AccountsConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByAccountPermissionsIdAndIdentityId: PermissionIdentitiesByAccountPermissionsIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAccountPermissionsIdAndCreatedBlockId: PermissionBlocksByAccountPermissionsIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByAccountPermissionsIdAndUpdatedBlockId: PermissionBlocksByAccountPermissionsIdAndUpdatedBlockIdManyToManyConnection;
};

export type PermissionAccountsByPermissionsIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AccountsOrderBy>>;
  filter?: Maybe<AccountFilter>;
};

export type PermissionIdentitiesByAccountPermissionsIdAndIdentityIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type PermissionBlocksByAccountPermissionsIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type PermissionBlocksByAccountPermissionsIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type PermissionAggregates = {
  __typename?: 'PermissionAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A connection to a list of `Block` values, with data from `Account`. */
export type PermissionBlocksByAccountPermissionsIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'PermissionBlocksByAccountPermissionsIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Account`, and the cursor to aid in pagination. */
  edges: Array<PermissionBlocksByAccountPermissionsIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Account`. */
export type PermissionBlocksByAccountPermissionsIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Account`. */
export type PermissionBlocksByAccountPermissionsIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'PermissionBlocksByAccountPermissionsIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Account`. */
  accountsByCreatedBlockId: AccountsConnection;
};

/** A `Block` edge in the connection, with data from `Account`. */
export type PermissionBlocksByAccountPermissionsIdAndCreatedBlockIdManyToManyEdgeAccountsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AccountsOrderBy>>;
    filter?: Maybe<AccountFilter>;
  };

/** A connection to a list of `Block` values, with data from `Account`. */
export type PermissionBlocksByAccountPermissionsIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'PermissionBlocksByAccountPermissionsIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Account`, and the cursor to aid in pagination. */
  edges: Array<PermissionBlocksByAccountPermissionsIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Account`. */
export type PermissionBlocksByAccountPermissionsIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Account`. */
export type PermissionBlocksByAccountPermissionsIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'PermissionBlocksByAccountPermissionsIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Account`. */
  accountsByUpdatedBlockId: AccountsConnection;
};

/** A `Block` edge in the connection, with data from `Account`. */
export type PermissionBlocksByAccountPermissionsIdAndUpdatedBlockIdManyToManyEdgeAccountsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AccountsOrderBy>>;
    filter?: Maybe<AccountFilter>;
  };

/** A filter to be used against `Permission` object types. All fields are combined with a logical ‘and.’ */
export type PermissionFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `assets` field. */
  assets?: Maybe<JsonFilter>;
  /** Filter by the object’s `portfolios` field. */
  portfolios?: Maybe<JsonFilter>;
  /** Filter by the object’s `transactions` field. */
  transactions?: Maybe<JsonFilter>;
  /** Filter by the object’s `transactionGroups` field. */
  transactionGroups?: Maybe<JsonFilter>;
  /** Filter by the object’s `datetime` field. */
  datetime?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PermissionFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PermissionFilter>>;
  /** Negates the expression. */
  not?: Maybe<PermissionFilter>;
};

/** A connection to a list of `Identity` values, with data from `Account`. */
export type PermissionIdentitiesByAccountPermissionsIdAndIdentityIdManyToManyConnection = {
  __typename?: 'PermissionIdentitiesByAccountPermissionsIdAndIdentityIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `Account`, and the cursor to aid in pagination. */
  edges: Array<PermissionIdentitiesByAccountPermissionsIdAndIdentityIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `Account`. */
export type PermissionIdentitiesByAccountPermissionsIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Account`. */
export type PermissionIdentitiesByAccountPermissionsIdAndIdentityIdManyToManyEdge = {
  __typename?: 'PermissionIdentitiesByAccountPermissionsIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Account`. */
  secondaryAccounts: AccountsConnection;
};

/** A `Identity` edge in the connection, with data from `Account`. */
export type PermissionIdentitiesByAccountPermissionsIdAndIdentityIdManyToManyEdgeSecondaryAccountsArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<AccountsOrderBy>>;
    filter?: Maybe<AccountFilter>;
  };

/** A connection to a list of `Permission` values. */
export type PermissionsConnection = {
  __typename?: 'PermissionsConnection';
  /** A list of `Permission` objects. */
  nodes: Array<Maybe<Permission>>;
  /** A list of edges which contains the `Permission` and cursor to aid in pagination. */
  edges: Array<PermissionsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Permission` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PermissionAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PermissionAggregates>>;
};

/** A connection to a list of `Permission` values. */
export type PermissionsConnectionGroupedAggregatesArgs = {
  groupBy: Array<PermissionsGroupBy>;
  having?: Maybe<PermissionsHavingInput>;
};

/** A `Permission` edge in the connection. */
export type PermissionsEdge = {
  __typename?: 'PermissionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Permission` at the end of the edge. */
  node?: Maybe<Permission>;
};

/** Grouping methods for `Permission` for usage during aggregation. */
export enum PermissionsGroupBy {
  Assets = 'ASSETS',
  Portfolios = 'PORTFOLIOS',
  Transactions = 'TRANSACTIONS',
  TransactionGroups = 'TRANSACTION_GROUPS',
  Datetime = 'DATETIME',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `Permission` aggregates. */
export type PermissionsHavingInput = {
  AND?: Maybe<Array<PermissionsHavingInput>>;
  OR?: Maybe<Array<PermissionsHavingInput>>;
};

/** Methods to use when ordering `Permission`. */
export enum PermissionsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  AssetsAsc = 'ASSETS_ASC',
  AssetsDesc = 'ASSETS_DESC',
  PortfoliosAsc = 'PORTFOLIOS_ASC',
  PortfoliosDesc = 'PORTFOLIOS_DESC',
  TransactionsAsc = 'TRANSACTIONS_ASC',
  TransactionsDesc = 'TRANSACTIONS_DESC',
  TransactionGroupsAsc = 'TRANSACTION_GROUPS_ASC',
  TransactionGroupsDesc = 'TRANSACTION_GROUPS_DESC',
  DatetimeAsc = 'DATETIME_ASC',
  DatetimeDesc = 'DATETIME_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  AccountsByPermissionsIdCountAsc = 'ACCOUNTS_BY_PERMISSIONS_ID_COUNT_ASC',
  AccountsByPermissionsIdCountDesc = 'ACCOUNTS_BY_PERMISSIONS_ID_COUNT_DESC',
}

export type Portfolio = Node & {
  __typename?: 'Portfolio';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  identityId: Scalars['String'];
  number: Scalars['Int'];
  name?: Maybe<Scalars['String']>;
  custodianId?: Maybe<Scalars['String']>;
  eventIdx: Scalars['Int'];
  createdBlockId: Scalars['String'];
  updatedBlockId: Scalars['String'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Identity` that is related to this `Portfolio`. */
  identity?: Maybe<Identity>;
  /** Reads a single `Identity` that is related to this `Portfolio`. */
  custodian?: Maybe<Identity>;
  /** Reads a single `Block` that is related to this `Portfolio`. */
  createdBlock?: Maybe<Block>;
  /** Reads a single `Block` that is related to this `Portfolio`. */
  updatedBlock?: Maybe<Block>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByFromId: PortfolioMovementsConnection;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByToId: PortfolioMovementsConnection;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByFromId: LegsConnection;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByToId: LegsConnection;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributions: DistributionsConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByPortfolioMovementFromIdAndToId: PortfolioPortfoliosByPortfolioMovementFromIdAndToIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByPortfolioMovementFromIdAndAssetId: PortfolioAssetsByPortfolioMovementFromIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByPortfolioMovementFromIdAndCreatedBlockId: PortfolioBlocksByPortfolioMovementFromIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByPortfolioMovementFromIdAndUpdatedBlockId: PortfolioBlocksByPortfolioMovementFromIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByPortfolioMovementToIdAndFromId: PortfolioPortfoliosByPortfolioMovementToIdAndFromIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByPortfolioMovementToIdAndAssetId: PortfolioAssetsByPortfolioMovementToIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByPortfolioMovementToIdAndCreatedBlockId: PortfolioBlocksByPortfolioMovementToIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByPortfolioMovementToIdAndUpdatedBlockId: PortfolioBlocksByPortfolioMovementToIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByLegFromIdAndToId: PortfolioPortfoliosByLegFromIdAndToIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Instruction`. */
  instructionsByLegFromIdAndInstructionId: PortfolioInstructionsByLegFromIdAndInstructionIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Settlement`. */
  settlementsByLegFromIdAndSettlementId: PortfolioSettlementsByLegFromIdAndSettlementIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByLegFromIdAndCreatedBlockId: PortfolioBlocksByLegFromIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByLegFromIdAndUpdatedBlockId: PortfolioBlocksByLegFromIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByLegToIdAndFromId: PortfolioPortfoliosByLegToIdAndFromIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Instruction`. */
  instructionsByLegToIdAndInstructionId: PortfolioInstructionsByLegToIdAndInstructionIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Settlement`. */
  settlementsByLegToIdAndSettlementId: PortfolioSettlementsByLegToIdAndSettlementIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByLegToIdAndCreatedBlockId: PortfolioBlocksByLegToIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByLegToIdAndUpdatedBlockId: PortfolioBlocksByLegToIdAndUpdatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByDistributionPortfolioIdAndIdentityId: PortfolioIdentitiesByDistributionPortfolioIdAndIdentityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByDistributionPortfolioIdAndAssetId: PortfolioAssetsByDistributionPortfolioIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByDistributionPortfolioIdAndCreatedBlockId: PortfolioBlocksByDistributionPortfolioIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByDistributionPortfolioIdAndUpdatedBlockId: PortfolioBlocksByDistributionPortfolioIdAndUpdatedBlockIdManyToManyConnection;
};

export type PortfolioPortfolioMovementsByFromIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PortfolioMovementsOrderBy>>;
  filter?: Maybe<PortfolioMovementFilter>;
};

export type PortfolioPortfolioMovementsByToIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PortfolioMovementsOrderBy>>;
  filter?: Maybe<PortfolioMovementFilter>;
};

export type PortfolioLegsByFromIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<LegsOrderBy>>;
  filter?: Maybe<LegFilter>;
};

export type PortfolioLegsByToIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<LegsOrderBy>>;
  filter?: Maybe<LegFilter>;
};

export type PortfolioDistributionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<DistributionsOrderBy>>;
  filter?: Maybe<DistributionFilter>;
};

export type PortfolioPortfoliosByPortfolioMovementFromIdAndToIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PortfoliosOrderBy>>;
  filter?: Maybe<PortfolioFilter>;
};

export type PortfolioAssetsByPortfolioMovementFromIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type PortfolioBlocksByPortfolioMovementFromIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type PortfolioBlocksByPortfolioMovementFromIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type PortfolioPortfoliosByPortfolioMovementToIdAndFromIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PortfoliosOrderBy>>;
  filter?: Maybe<PortfolioFilter>;
};

export type PortfolioAssetsByPortfolioMovementToIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type PortfolioBlocksByPortfolioMovementToIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type PortfolioBlocksByPortfolioMovementToIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type PortfolioPortfoliosByLegFromIdAndToIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PortfoliosOrderBy>>;
  filter?: Maybe<PortfolioFilter>;
};

export type PortfolioInstructionsByLegFromIdAndInstructionIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<InstructionsOrderBy>>;
  filter?: Maybe<InstructionFilter>;
};

export type PortfolioSettlementsByLegFromIdAndSettlementIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<SettlementsOrderBy>>;
  filter?: Maybe<SettlementFilter>;
};

export type PortfolioBlocksByLegFromIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type PortfolioBlocksByLegFromIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type PortfolioPortfoliosByLegToIdAndFromIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PortfoliosOrderBy>>;
  filter?: Maybe<PortfolioFilter>;
};

export type PortfolioInstructionsByLegToIdAndInstructionIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<InstructionsOrderBy>>;
  filter?: Maybe<InstructionFilter>;
};

export type PortfolioSettlementsByLegToIdAndSettlementIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<SettlementsOrderBy>>;
  filter?: Maybe<SettlementFilter>;
};

export type PortfolioBlocksByLegToIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type PortfolioBlocksByLegToIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type PortfolioIdentitiesByDistributionPortfolioIdAndIdentityIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type PortfolioAssetsByDistributionPortfolioIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type PortfolioBlocksByDistributionPortfolioIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type PortfolioBlocksByDistributionPortfolioIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type PortfolioAggregates = {
  __typename?: 'PortfolioAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A connection to a list of `Asset` values, with data from `Distribution`. */
export type PortfolioAssetsByDistributionPortfolioIdAndAssetIdManyToManyConnection = {
  __typename?: 'PortfolioAssetsByDistributionPortfolioIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<PortfolioAssetsByDistributionPortfolioIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `Distribution`. */
export type PortfolioAssetsByDistributionPortfolioIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `Distribution`. */
export type PortfolioAssetsByDistributionPortfolioIdAndAssetIdManyToManyEdge = {
  __typename?: 'PortfolioAssetsByDistributionPortfolioIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributions: DistributionsConnection;
};

/** A `Asset` edge in the connection, with data from `Distribution`. */
export type PortfolioAssetsByDistributionPortfolioIdAndAssetIdManyToManyEdgeDistributionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<DistributionsOrderBy>>;
  filter?: Maybe<DistributionFilter>;
};

/** A connection to a list of `Asset` values, with data from `PortfolioMovement`. */
export type PortfolioAssetsByPortfolioMovementFromIdAndAssetIdManyToManyConnection = {
  __typename?: 'PortfolioAssetsByPortfolioMovementFromIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<PortfolioAssetsByPortfolioMovementFromIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `PortfolioMovement`. */
export type PortfolioAssetsByPortfolioMovementFromIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `PortfolioMovement`. */
export type PortfolioAssetsByPortfolioMovementFromIdAndAssetIdManyToManyEdge = {
  __typename?: 'PortfolioAssetsByPortfolioMovementFromIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovements: PortfolioMovementsConnection;
};

/** A `Asset` edge in the connection, with data from `PortfolioMovement`. */
export type PortfolioAssetsByPortfolioMovementFromIdAndAssetIdManyToManyEdgePortfolioMovementsArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<PortfolioMovementsOrderBy>>;
    filter?: Maybe<PortfolioMovementFilter>;
  };

/** A connection to a list of `Asset` values, with data from `PortfolioMovement`. */
export type PortfolioAssetsByPortfolioMovementToIdAndAssetIdManyToManyConnection = {
  __typename?: 'PortfolioAssetsByPortfolioMovementToIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<PortfolioAssetsByPortfolioMovementToIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `PortfolioMovement`. */
export type PortfolioAssetsByPortfolioMovementToIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `PortfolioMovement`. */
export type PortfolioAssetsByPortfolioMovementToIdAndAssetIdManyToManyEdge = {
  __typename?: 'PortfolioAssetsByPortfolioMovementToIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovements: PortfolioMovementsConnection;
};

/** A `Asset` edge in the connection, with data from `PortfolioMovement`. */
export type PortfolioAssetsByPortfolioMovementToIdAndAssetIdManyToManyEdgePortfolioMovementsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PortfolioMovementsOrderBy>>;
  filter?: Maybe<PortfolioMovementFilter>;
};

/** A connection to a list of `Block` values, with data from `Distribution`. */
export type PortfolioBlocksByDistributionPortfolioIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'PortfolioBlocksByDistributionPortfolioIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<PortfolioBlocksByDistributionPortfolioIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Distribution`. */
export type PortfolioBlocksByDistributionPortfolioIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Distribution`. */
export type PortfolioBlocksByDistributionPortfolioIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'PortfolioBlocksByDistributionPortfolioIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributionsByCreatedBlockId: DistributionsConnection;
};

/** A `Block` edge in the connection, with data from `Distribution`. */
export type PortfolioBlocksByDistributionPortfolioIdAndCreatedBlockIdManyToManyEdgeDistributionsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<DistributionsOrderBy>>;
    filter?: Maybe<DistributionFilter>;
  };

/** A connection to a list of `Block` values, with data from `Distribution`. */
export type PortfolioBlocksByDistributionPortfolioIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'PortfolioBlocksByDistributionPortfolioIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<PortfolioBlocksByDistributionPortfolioIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Distribution`. */
export type PortfolioBlocksByDistributionPortfolioIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Distribution`. */
export type PortfolioBlocksByDistributionPortfolioIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'PortfolioBlocksByDistributionPortfolioIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributionsByUpdatedBlockId: DistributionsConnection;
};

/** A `Block` edge in the connection, with data from `Distribution`. */
export type PortfolioBlocksByDistributionPortfolioIdAndUpdatedBlockIdManyToManyEdgeDistributionsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<DistributionsOrderBy>>;
    filter?: Maybe<DistributionFilter>;
  };

/** A connection to a list of `Block` values, with data from `Leg`. */
export type PortfolioBlocksByLegFromIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'PortfolioBlocksByLegFromIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<PortfolioBlocksByLegFromIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Leg`. */
export type PortfolioBlocksByLegFromIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs = {
  groupBy: Array<BlocksGroupBy>;
  having?: Maybe<BlocksHavingInput>;
};

/** A `Block` edge in the connection, with data from `Leg`. */
export type PortfolioBlocksByLegFromIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'PortfolioBlocksByLegFromIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByCreatedBlockId: LegsConnection;
};

/** A `Block` edge in the connection, with data from `Leg`. */
export type PortfolioBlocksByLegFromIdAndCreatedBlockIdManyToManyEdgeLegsByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<LegsOrderBy>>;
  filter?: Maybe<LegFilter>;
};

/** A connection to a list of `Block` values, with data from `Leg`. */
export type PortfolioBlocksByLegFromIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'PortfolioBlocksByLegFromIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<PortfolioBlocksByLegFromIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Leg`. */
export type PortfolioBlocksByLegFromIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs = {
  groupBy: Array<BlocksGroupBy>;
  having?: Maybe<BlocksHavingInput>;
};

/** A `Block` edge in the connection, with data from `Leg`. */
export type PortfolioBlocksByLegFromIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'PortfolioBlocksByLegFromIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByUpdatedBlockId: LegsConnection;
};

/** A `Block` edge in the connection, with data from `Leg`. */
export type PortfolioBlocksByLegFromIdAndUpdatedBlockIdManyToManyEdgeLegsByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<LegsOrderBy>>;
  filter?: Maybe<LegFilter>;
};

/** A connection to a list of `Block` values, with data from `Leg`. */
export type PortfolioBlocksByLegToIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'PortfolioBlocksByLegToIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<PortfolioBlocksByLegToIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Leg`. */
export type PortfolioBlocksByLegToIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs = {
  groupBy: Array<BlocksGroupBy>;
  having?: Maybe<BlocksHavingInput>;
};

/** A `Block` edge in the connection, with data from `Leg`. */
export type PortfolioBlocksByLegToIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'PortfolioBlocksByLegToIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByCreatedBlockId: LegsConnection;
};

/** A `Block` edge in the connection, with data from `Leg`. */
export type PortfolioBlocksByLegToIdAndCreatedBlockIdManyToManyEdgeLegsByCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<LegsOrderBy>>;
  filter?: Maybe<LegFilter>;
};

/** A connection to a list of `Block` values, with data from `Leg`. */
export type PortfolioBlocksByLegToIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'PortfolioBlocksByLegToIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<PortfolioBlocksByLegToIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Leg`. */
export type PortfolioBlocksByLegToIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs = {
  groupBy: Array<BlocksGroupBy>;
  having?: Maybe<BlocksHavingInput>;
};

/** A `Block` edge in the connection, with data from `Leg`. */
export type PortfolioBlocksByLegToIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'PortfolioBlocksByLegToIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByUpdatedBlockId: LegsConnection;
};

/** A `Block` edge in the connection, with data from `Leg`. */
export type PortfolioBlocksByLegToIdAndUpdatedBlockIdManyToManyEdgeLegsByUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<LegsOrderBy>>;
  filter?: Maybe<LegFilter>;
};

/** A connection to a list of `Block` values, with data from `PortfolioMovement`. */
export type PortfolioBlocksByPortfolioMovementFromIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'PortfolioBlocksByPortfolioMovementFromIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<PortfolioBlocksByPortfolioMovementFromIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `PortfolioMovement`. */
export type PortfolioBlocksByPortfolioMovementFromIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `PortfolioMovement`. */
export type PortfolioBlocksByPortfolioMovementFromIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'PortfolioBlocksByPortfolioMovementFromIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByCreatedBlockId: PortfolioMovementsConnection;
};

/** A `Block` edge in the connection, with data from `PortfolioMovement`. */
export type PortfolioBlocksByPortfolioMovementFromIdAndCreatedBlockIdManyToManyEdgePortfolioMovementsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<PortfolioMovementsOrderBy>>;
    filter?: Maybe<PortfolioMovementFilter>;
  };

/** A connection to a list of `Block` values, with data from `PortfolioMovement`. */
export type PortfolioBlocksByPortfolioMovementFromIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'PortfolioBlocksByPortfolioMovementFromIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<PortfolioBlocksByPortfolioMovementFromIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `PortfolioMovement`. */
export type PortfolioBlocksByPortfolioMovementFromIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `PortfolioMovement`. */
export type PortfolioBlocksByPortfolioMovementFromIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'PortfolioBlocksByPortfolioMovementFromIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByUpdatedBlockId: PortfolioMovementsConnection;
};

/** A `Block` edge in the connection, with data from `PortfolioMovement`. */
export type PortfolioBlocksByPortfolioMovementFromIdAndUpdatedBlockIdManyToManyEdgePortfolioMovementsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<PortfolioMovementsOrderBy>>;
    filter?: Maybe<PortfolioMovementFilter>;
  };

/** A connection to a list of `Block` values, with data from `PortfolioMovement`. */
export type PortfolioBlocksByPortfolioMovementToIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'PortfolioBlocksByPortfolioMovementToIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<PortfolioBlocksByPortfolioMovementToIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `PortfolioMovement`. */
export type PortfolioBlocksByPortfolioMovementToIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `PortfolioMovement`. */
export type PortfolioBlocksByPortfolioMovementToIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'PortfolioBlocksByPortfolioMovementToIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByCreatedBlockId: PortfolioMovementsConnection;
};

/** A `Block` edge in the connection, with data from `PortfolioMovement`. */
export type PortfolioBlocksByPortfolioMovementToIdAndCreatedBlockIdManyToManyEdgePortfolioMovementsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<PortfolioMovementsOrderBy>>;
    filter?: Maybe<PortfolioMovementFilter>;
  };

/** A connection to a list of `Block` values, with data from `PortfolioMovement`. */
export type PortfolioBlocksByPortfolioMovementToIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'PortfolioBlocksByPortfolioMovementToIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<PortfolioBlocksByPortfolioMovementToIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `PortfolioMovement`. */
export type PortfolioBlocksByPortfolioMovementToIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `PortfolioMovement`. */
export type PortfolioBlocksByPortfolioMovementToIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'PortfolioBlocksByPortfolioMovementToIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByUpdatedBlockId: PortfolioMovementsConnection;
};

/** A `Block` edge in the connection, with data from `PortfolioMovement`. */
export type PortfolioBlocksByPortfolioMovementToIdAndUpdatedBlockIdManyToManyEdgePortfolioMovementsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<PortfolioMovementsOrderBy>>;
    filter?: Maybe<PortfolioMovementFilter>;
  };

/** A filter to be used against `Portfolio` object types. All fields are combined with a logical ‘and.’ */
export type PortfolioFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `identityId` field. */
  identityId?: Maybe<StringFilter>;
  /** Filter by the object’s `number` field. */
  number?: Maybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `custodianId` field. */
  custodianId?: Maybe<StringFilter>;
  /** Filter by the object’s `eventIdx` field. */
  eventIdx?: Maybe<IntFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PortfolioFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PortfolioFilter>>;
  /** Negates the expression. */
  not?: Maybe<PortfolioFilter>;
};

/** A connection to a list of `Identity` values, with data from `Distribution`. */
export type PortfolioIdentitiesByDistributionPortfolioIdAndIdentityIdManyToManyConnection = {
  __typename?: 'PortfolioIdentitiesByDistributionPortfolioIdAndIdentityIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `Distribution`, and the cursor to aid in pagination. */
  edges: Array<PortfolioIdentitiesByDistributionPortfolioIdAndIdentityIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `Distribution`. */
export type PortfolioIdentitiesByDistributionPortfolioIdAndIdentityIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `Distribution`. */
export type PortfolioIdentitiesByDistributionPortfolioIdAndIdentityIdManyToManyEdge = {
  __typename?: 'PortfolioIdentitiesByDistributionPortfolioIdAndIdentityIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributions: DistributionsConnection;
};

/** A `Identity` edge in the connection, with data from `Distribution`. */
export type PortfolioIdentitiesByDistributionPortfolioIdAndIdentityIdManyToManyEdgeDistributionsArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<DistributionsOrderBy>>;
    filter?: Maybe<DistributionFilter>;
  };

/** A connection to a list of `Instruction` values, with data from `Leg`. */
export type PortfolioInstructionsByLegFromIdAndInstructionIdManyToManyConnection = {
  __typename?: 'PortfolioInstructionsByLegFromIdAndInstructionIdManyToManyConnection';
  /** A list of `Instruction` objects. */
  nodes: Array<Maybe<Instruction>>;
  /** A list of edges which contains the `Instruction`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<PortfolioInstructionsByLegFromIdAndInstructionIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Instruction` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<InstructionAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<InstructionAggregates>>;
};

/** A connection to a list of `Instruction` values, with data from `Leg`. */
export type PortfolioInstructionsByLegFromIdAndInstructionIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<InstructionsGroupBy>;
    having?: Maybe<InstructionsHavingInput>;
  };

/** A `Instruction` edge in the connection, with data from `Leg`. */
export type PortfolioInstructionsByLegFromIdAndInstructionIdManyToManyEdge = {
  __typename?: 'PortfolioInstructionsByLegFromIdAndInstructionIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Instruction` at the end of the edge. */
  node?: Maybe<Instruction>;
  /** Reads and enables pagination through a set of `Leg`. */
  legs: LegsConnection;
};

/** A `Instruction` edge in the connection, with data from `Leg`. */
export type PortfolioInstructionsByLegFromIdAndInstructionIdManyToManyEdgeLegsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<LegsOrderBy>>;
  filter?: Maybe<LegFilter>;
};

/** A connection to a list of `Instruction` values, with data from `Leg`. */
export type PortfolioInstructionsByLegToIdAndInstructionIdManyToManyConnection = {
  __typename?: 'PortfolioInstructionsByLegToIdAndInstructionIdManyToManyConnection';
  /** A list of `Instruction` objects. */
  nodes: Array<Maybe<Instruction>>;
  /** A list of edges which contains the `Instruction`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<PortfolioInstructionsByLegToIdAndInstructionIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Instruction` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<InstructionAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<InstructionAggregates>>;
};

/** A connection to a list of `Instruction` values, with data from `Leg`. */
export type PortfolioInstructionsByLegToIdAndInstructionIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<InstructionsGroupBy>;
    having?: Maybe<InstructionsHavingInput>;
  };

/** A `Instruction` edge in the connection, with data from `Leg`. */
export type PortfolioInstructionsByLegToIdAndInstructionIdManyToManyEdge = {
  __typename?: 'PortfolioInstructionsByLegToIdAndInstructionIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Instruction` at the end of the edge. */
  node?: Maybe<Instruction>;
  /** Reads and enables pagination through a set of `Leg`. */
  legs: LegsConnection;
};

/** A `Instruction` edge in the connection, with data from `Leg`. */
export type PortfolioInstructionsByLegToIdAndInstructionIdManyToManyEdgeLegsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<LegsOrderBy>>;
  filter?: Maybe<LegFilter>;
};

export type PortfolioMovement = Node & {
  __typename?: 'PortfolioMovement';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  fromId: Scalars['String'];
  toId: Scalars['String'];
  assetId: Scalars['String'];
  amount: Scalars['BigFloat'];
  address: Scalars['String'];
  createdBlockId: Scalars['String'];
  updatedBlockId: Scalars['String'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Portfolio` that is related to this `PortfolioMovement`. */
  from?: Maybe<Portfolio>;
  /** Reads a single `Portfolio` that is related to this `PortfolioMovement`. */
  to?: Maybe<Portfolio>;
  /** Reads a single `Asset` that is related to this `PortfolioMovement`. */
  asset?: Maybe<Asset>;
  /** Reads a single `Block` that is related to this `PortfolioMovement`. */
  createdBlock?: Maybe<Block>;
  /** Reads a single `Block` that is related to this `PortfolioMovement`. */
  updatedBlock?: Maybe<Block>;
};

export type PortfolioMovementAggregates = {
  __typename?: 'PortfolioMovementAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `PortfolioMovement` object types. All fields are combined with a logical ‘and.’ */
export type PortfolioMovementFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `fromId` field. */
  fromId?: Maybe<StringFilter>;
  /** Filter by the object’s `toId` field. */
  toId?: Maybe<StringFilter>;
  /** Filter by the object’s `assetId` field. */
  assetId?: Maybe<StringFilter>;
  /** Filter by the object’s `amount` field. */
  amount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `address` field. */
  address?: Maybe<StringFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PortfolioMovementFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PortfolioMovementFilter>>;
  /** Negates the expression. */
  not?: Maybe<PortfolioMovementFilter>;
};

/** A connection to a list of `PortfolioMovement` values. */
export type PortfolioMovementsConnection = {
  __typename?: 'PortfolioMovementsConnection';
  /** A list of `PortfolioMovement` objects. */
  nodes: Array<Maybe<PortfolioMovement>>;
  /** A list of edges which contains the `PortfolioMovement` and cursor to aid in pagination. */
  edges: Array<PortfolioMovementsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PortfolioMovement` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioMovementAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioMovementAggregates>>;
};

/** A connection to a list of `PortfolioMovement` values. */
export type PortfolioMovementsConnectionGroupedAggregatesArgs = {
  groupBy: Array<PortfolioMovementsGroupBy>;
  having?: Maybe<PortfolioMovementsHavingInput>;
};

/** A `PortfolioMovement` edge in the connection. */
export type PortfolioMovementsEdge = {
  __typename?: 'PortfolioMovementsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PortfolioMovement` at the end of the edge. */
  node?: Maybe<PortfolioMovement>;
};

/** Grouping methods for `PortfolioMovement` for usage during aggregation. */
export enum PortfolioMovementsGroupBy {
  FromId = 'FROM_ID',
  ToId = 'TO_ID',
  AssetId = 'ASSET_ID',
  Amount = 'AMOUNT',
  Address = 'ADDRESS',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `PortfolioMovement` aggregates. */
export type PortfolioMovementsHavingInput = {
  AND?: Maybe<Array<PortfolioMovementsHavingInput>>;
  OR?: Maybe<Array<PortfolioMovementsHavingInput>>;
};

/** Methods to use when ordering `PortfolioMovement`. */
export enum PortfolioMovementsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  FromIdAsc = 'FROM_ID_ASC',
  FromIdDesc = 'FROM_ID_DESC',
  ToIdAsc = 'TO_ID_ASC',
  ToIdDesc = 'TO_ID_DESC',
  AssetIdAsc = 'ASSET_ID_ASC',
  AssetIdDesc = 'ASSET_ID_DESC',
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  AddressAsc = 'ADDRESS_ASC',
  AddressDesc = 'ADDRESS_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
}

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type PortfolioPortfoliosByLegFromIdAndToIdManyToManyConnection = {
  __typename?: 'PortfolioPortfoliosByLegFromIdAndToIdManyToManyConnection';
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** A list of edges which contains the `Portfolio`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<PortfolioPortfoliosByLegFromIdAndToIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
};

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type PortfolioPortfoliosByLegFromIdAndToIdManyToManyConnectionGroupedAggregatesArgs = {
  groupBy: Array<PortfoliosGroupBy>;
  having?: Maybe<PortfoliosHavingInput>;
};

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type PortfolioPortfoliosByLegFromIdAndToIdManyToManyEdge = {
  __typename?: 'PortfolioPortfoliosByLegFromIdAndToIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByToId: LegsConnection;
};

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type PortfolioPortfoliosByLegFromIdAndToIdManyToManyEdgeLegsByToIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<LegsOrderBy>>;
  filter?: Maybe<LegFilter>;
};

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type PortfolioPortfoliosByLegToIdAndFromIdManyToManyConnection = {
  __typename?: 'PortfolioPortfoliosByLegToIdAndFromIdManyToManyConnection';
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** A list of edges which contains the `Portfolio`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<PortfolioPortfoliosByLegToIdAndFromIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
};

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type PortfolioPortfoliosByLegToIdAndFromIdManyToManyConnectionGroupedAggregatesArgs = {
  groupBy: Array<PortfoliosGroupBy>;
  having?: Maybe<PortfoliosHavingInput>;
};

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type PortfolioPortfoliosByLegToIdAndFromIdManyToManyEdge = {
  __typename?: 'PortfolioPortfoliosByLegToIdAndFromIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByFromId: LegsConnection;
};

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type PortfolioPortfoliosByLegToIdAndFromIdManyToManyEdgeLegsByFromIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<LegsOrderBy>>;
  filter?: Maybe<LegFilter>;
};

/** A connection to a list of `Portfolio` values, with data from `PortfolioMovement`. */
export type PortfolioPortfoliosByPortfolioMovementFromIdAndToIdManyToManyConnection = {
  __typename?: 'PortfolioPortfoliosByPortfolioMovementFromIdAndToIdManyToManyConnection';
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** A list of edges which contains the `Portfolio`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<PortfolioPortfoliosByPortfolioMovementFromIdAndToIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
};

/** A connection to a list of `Portfolio` values, with data from `PortfolioMovement`. */
export type PortfolioPortfoliosByPortfolioMovementFromIdAndToIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: Maybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `PortfolioMovement`. */
export type PortfolioPortfoliosByPortfolioMovementFromIdAndToIdManyToManyEdge = {
  __typename?: 'PortfolioPortfoliosByPortfolioMovementFromIdAndToIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByToId: PortfolioMovementsConnection;
};

/** A `Portfolio` edge in the connection, with data from `PortfolioMovement`. */
export type PortfolioPortfoliosByPortfolioMovementFromIdAndToIdManyToManyEdgePortfolioMovementsByToIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<PortfolioMovementsOrderBy>>;
    filter?: Maybe<PortfolioMovementFilter>;
  };

/** A connection to a list of `Portfolio` values, with data from `PortfolioMovement`. */
export type PortfolioPortfoliosByPortfolioMovementToIdAndFromIdManyToManyConnection = {
  __typename?: 'PortfolioPortfoliosByPortfolioMovementToIdAndFromIdManyToManyConnection';
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** A list of edges which contains the `Portfolio`, info from the `PortfolioMovement`, and the cursor to aid in pagination. */
  edges: Array<PortfolioPortfoliosByPortfolioMovementToIdAndFromIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
};

/** A connection to a list of `Portfolio` values, with data from `PortfolioMovement`. */
export type PortfolioPortfoliosByPortfolioMovementToIdAndFromIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: Maybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `PortfolioMovement`. */
export type PortfolioPortfoliosByPortfolioMovementToIdAndFromIdManyToManyEdge = {
  __typename?: 'PortfolioPortfoliosByPortfolioMovementToIdAndFromIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovementsByFromId: PortfolioMovementsConnection;
};

/** A `Portfolio` edge in the connection, with data from `PortfolioMovement`. */
export type PortfolioPortfoliosByPortfolioMovementToIdAndFromIdManyToManyEdgePortfolioMovementsByFromIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<PortfolioMovementsOrderBy>>;
    filter?: Maybe<PortfolioMovementFilter>;
  };

/** A connection to a list of `Settlement` values, with data from `Leg`. */
export type PortfolioSettlementsByLegFromIdAndSettlementIdManyToManyConnection = {
  __typename?: 'PortfolioSettlementsByLegFromIdAndSettlementIdManyToManyConnection';
  /** A list of `Settlement` objects. */
  nodes: Array<Maybe<Settlement>>;
  /** A list of edges which contains the `Settlement`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<PortfolioSettlementsByLegFromIdAndSettlementIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Settlement` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<SettlementAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<SettlementAggregates>>;
};

/** A connection to a list of `Settlement` values, with data from `Leg`. */
export type PortfolioSettlementsByLegFromIdAndSettlementIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<SettlementsGroupBy>;
    having?: Maybe<SettlementsHavingInput>;
  };

/** A `Settlement` edge in the connection, with data from `Leg`. */
export type PortfolioSettlementsByLegFromIdAndSettlementIdManyToManyEdge = {
  __typename?: 'PortfolioSettlementsByLegFromIdAndSettlementIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Settlement` at the end of the edge. */
  node?: Maybe<Settlement>;
  /** Reads and enables pagination through a set of `Leg`. */
  legs: LegsConnection;
};

/** A `Settlement` edge in the connection, with data from `Leg`. */
export type PortfolioSettlementsByLegFromIdAndSettlementIdManyToManyEdgeLegsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<LegsOrderBy>>;
  filter?: Maybe<LegFilter>;
};

/** A connection to a list of `Settlement` values, with data from `Leg`. */
export type PortfolioSettlementsByLegToIdAndSettlementIdManyToManyConnection = {
  __typename?: 'PortfolioSettlementsByLegToIdAndSettlementIdManyToManyConnection';
  /** A list of `Settlement` objects. */
  nodes: Array<Maybe<Settlement>>;
  /** A list of edges which contains the `Settlement`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<PortfolioSettlementsByLegToIdAndSettlementIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Settlement` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<SettlementAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<SettlementAggregates>>;
};

/** A connection to a list of `Settlement` values, with data from `Leg`. */
export type PortfolioSettlementsByLegToIdAndSettlementIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<SettlementsGroupBy>;
    having?: Maybe<SettlementsHavingInput>;
  };

/** A `Settlement` edge in the connection, with data from `Leg`. */
export type PortfolioSettlementsByLegToIdAndSettlementIdManyToManyEdge = {
  __typename?: 'PortfolioSettlementsByLegToIdAndSettlementIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Settlement` at the end of the edge. */
  node?: Maybe<Settlement>;
  /** Reads and enables pagination through a set of `Leg`. */
  legs: LegsConnection;
};

/** A `Settlement` edge in the connection, with data from `Leg`. */
export type PortfolioSettlementsByLegToIdAndSettlementIdManyToManyEdgeLegsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<LegsOrderBy>>;
  filter?: Maybe<LegFilter>;
};

/** A connection to a list of `Portfolio` values. */
export type PortfoliosConnection = {
  __typename?: 'PortfoliosConnection';
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** A list of edges which contains the `Portfolio` and cursor to aid in pagination. */
  edges: Array<PortfoliosEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
};

/** A connection to a list of `Portfolio` values. */
export type PortfoliosConnectionGroupedAggregatesArgs = {
  groupBy: Array<PortfoliosGroupBy>;
  having?: Maybe<PortfoliosHavingInput>;
};

/** A `Portfolio` edge in the connection. */
export type PortfoliosEdge = {
  __typename?: 'PortfoliosEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
};

/** Grouping methods for `Portfolio` for usage during aggregation. */
export enum PortfoliosGroupBy {
  IdentityId = 'IDENTITY_ID',
  Number = 'NUMBER',
  Name = 'NAME',
  CustodianId = 'CUSTODIAN_ID',
  EventIdx = 'EVENT_IDX',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `Portfolio` aggregates. */
export type PortfoliosHavingInput = {
  AND?: Maybe<Array<PortfoliosHavingInput>>;
  OR?: Maybe<Array<PortfoliosHavingInput>>;
};

/** Methods to use when ordering `Portfolio`. */
export enum PortfoliosOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IdentityIdAsc = 'IDENTITY_ID_ASC',
  IdentityIdDesc = 'IDENTITY_ID_DESC',
  NumberAsc = 'NUMBER_ASC',
  NumberDesc = 'NUMBER_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  CustodianIdAsc = 'CUSTODIAN_ID_ASC',
  CustodianIdDesc = 'CUSTODIAN_ID_DESC',
  EventIdxAsc = 'EVENT_IDX_ASC',
  EventIdxDesc = 'EVENT_IDX_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PortfolioMovementsByFromIdCountAsc = 'PORTFOLIO_MOVEMENTS_BY_FROM_ID_COUNT_ASC',
  PortfolioMovementsByFromIdCountDesc = 'PORTFOLIO_MOVEMENTS_BY_FROM_ID_COUNT_DESC',
  PortfolioMovementsByToIdCountAsc = 'PORTFOLIO_MOVEMENTS_BY_TO_ID_COUNT_ASC',
  PortfolioMovementsByToIdCountDesc = 'PORTFOLIO_MOVEMENTS_BY_TO_ID_COUNT_DESC',
  LegsByFromIdCountAsc = 'LEGS_BY_FROM_ID_COUNT_ASC',
  LegsByFromIdCountDesc = 'LEGS_BY_FROM_ID_COUNT_DESC',
  LegsByToIdCountAsc = 'LEGS_BY_TO_ID_COUNT_ASC',
  LegsByToIdCountDesc = 'LEGS_BY_TO_ID_COUNT_DESC',
  DistributionsCountAsc = 'DISTRIBUTIONS_COUNT_ASC',
  DistributionsCountDesc = 'DISTRIBUTIONS_COUNT_DESC',
}

export type Proposal = Node & {
  __typename?: 'Proposal';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  proposer: Scalars['String'];
  state: Scalars['String'];
  ownerId: Scalars['String'];
  balance: Scalars['BigFloat'];
  url?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  snapshotted: Scalars['Boolean'];
  totalAyeWeight: Scalars['BigFloat'];
  totalNayWeight: Scalars['BigFloat'];
  createdBlockId: Scalars['String'];
  updatedBlockId: Scalars['String'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Identity` that is related to this `Proposal`. */
  owner?: Maybe<Identity>;
  /** Reads a single `Block` that is related to this `Proposal`. */
  createdBlock?: Maybe<Block>;
  /** Reads a single `Block` that is related to this `Proposal`. */
  updatedBlock?: Maybe<Block>;
  /** Reads and enables pagination through a set of `ProposalVote`. */
  votes: ProposalVotesConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByProposalVoteProposalIdAndCreatedBlockId: ProposalBlocksByProposalVoteProposalIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByProposalVoteProposalIdAndUpdatedBlockId: ProposalBlocksByProposalVoteProposalIdAndUpdatedBlockIdManyToManyConnection;
};

export type ProposalVotesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ProposalVotesOrderBy>>;
  filter?: Maybe<ProposalVoteFilter>;
};

export type ProposalBlocksByProposalVoteProposalIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type ProposalBlocksByProposalVoteProposalIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type ProposalAggregates = {
  __typename?: 'ProposalAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A connection to a list of `Block` values, with data from `ProposalVote`. */
export type ProposalBlocksByProposalVoteProposalIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'ProposalBlocksByProposalVoteProposalIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `ProposalVote`, and the cursor to aid in pagination. */
  edges: Array<ProposalBlocksByProposalVoteProposalIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `ProposalVote`. */
export type ProposalBlocksByProposalVoteProposalIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `ProposalVote`. */
export type ProposalBlocksByProposalVoteProposalIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'ProposalBlocksByProposalVoteProposalIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `ProposalVote`. */
  proposalVotesByCreatedBlockId: ProposalVotesConnection;
};

/** A `Block` edge in the connection, with data from `ProposalVote`. */
export type ProposalBlocksByProposalVoteProposalIdAndCreatedBlockIdManyToManyEdgeProposalVotesByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<ProposalVotesOrderBy>>;
    filter?: Maybe<ProposalVoteFilter>;
  };

/** A connection to a list of `Block` values, with data from `ProposalVote`. */
export type ProposalBlocksByProposalVoteProposalIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'ProposalBlocksByProposalVoteProposalIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `ProposalVote`, and the cursor to aid in pagination. */
  edges: Array<ProposalBlocksByProposalVoteProposalIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `ProposalVote`. */
export type ProposalBlocksByProposalVoteProposalIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `ProposalVote`. */
export type ProposalBlocksByProposalVoteProposalIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'ProposalBlocksByProposalVoteProposalIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `ProposalVote`. */
  proposalVotesByUpdatedBlockId: ProposalVotesConnection;
};

/** A `Block` edge in the connection, with data from `ProposalVote`. */
export type ProposalBlocksByProposalVoteProposalIdAndUpdatedBlockIdManyToManyEdgeProposalVotesByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<ProposalVotesOrderBy>>;
    filter?: Maybe<ProposalVoteFilter>;
  };

/** A filter to be used against `Proposal` object types. All fields are combined with a logical ‘and.’ */
export type ProposalFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `proposer` field. */
  proposer?: Maybe<StringFilter>;
  /** Filter by the object’s `state` field. */
  state?: Maybe<StringFilter>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: Maybe<StringFilter>;
  /** Filter by the object’s `balance` field. */
  balance?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `url` field. */
  url?: Maybe<StringFilter>;
  /** Filter by the object’s `description` field. */
  description?: Maybe<StringFilter>;
  /** Filter by the object’s `snapshotted` field. */
  snapshotted?: Maybe<BooleanFilter>;
  /** Filter by the object’s `totalAyeWeight` field. */
  totalAyeWeight?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `totalNayWeight` field. */
  totalNayWeight?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ProposalFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ProposalFilter>>;
  /** Negates the expression. */
  not?: Maybe<ProposalFilter>;
};

export type ProposalVote = Node & {
  __typename?: 'ProposalVote';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  proposalId: Scalars['String'];
  account: Scalars['String'];
  vote: Scalars['Boolean'];
  weight: Scalars['BigFloat'];
  createdBlockId: Scalars['String'];
  updatedBlockId: Scalars['String'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Proposal` that is related to this `ProposalVote`. */
  proposal?: Maybe<Proposal>;
  /** Reads a single `Block` that is related to this `ProposalVote`. */
  createdBlock?: Maybe<Block>;
  /** Reads a single `Block` that is related to this `ProposalVote`. */
  updatedBlock?: Maybe<Block>;
};

export type ProposalVoteAggregates = {
  __typename?: 'ProposalVoteAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `ProposalVote` object types. All fields are combined with a logical ‘and.’ */
export type ProposalVoteFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `proposalId` field. */
  proposalId?: Maybe<StringFilter>;
  /** Filter by the object’s `account` field. */
  account?: Maybe<StringFilter>;
  /** Filter by the object’s `vote` field. */
  vote?: Maybe<BooleanFilter>;
  /** Filter by the object’s `weight` field. */
  weight?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ProposalVoteFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ProposalVoteFilter>>;
  /** Negates the expression. */
  not?: Maybe<ProposalVoteFilter>;
};

/** A connection to a list of `ProposalVote` values. */
export type ProposalVotesConnection = {
  __typename?: 'ProposalVotesConnection';
  /** A list of `ProposalVote` objects. */
  nodes: Array<Maybe<ProposalVote>>;
  /** A list of edges which contains the `ProposalVote` and cursor to aid in pagination. */
  edges: Array<ProposalVotesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ProposalVote` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<ProposalVoteAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<ProposalVoteAggregates>>;
};

/** A connection to a list of `ProposalVote` values. */
export type ProposalVotesConnectionGroupedAggregatesArgs = {
  groupBy: Array<ProposalVotesGroupBy>;
  having?: Maybe<ProposalVotesHavingInput>;
};

/** A `ProposalVote` edge in the connection. */
export type ProposalVotesEdge = {
  __typename?: 'ProposalVotesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ProposalVote` at the end of the edge. */
  node?: Maybe<ProposalVote>;
};

/** Grouping methods for `ProposalVote` for usage during aggregation. */
export enum ProposalVotesGroupBy {
  ProposalId = 'PROPOSAL_ID',
  Account = 'ACCOUNT',
  Vote = 'VOTE',
  Weight = 'WEIGHT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `ProposalVote` aggregates. */
export type ProposalVotesHavingInput = {
  AND?: Maybe<Array<ProposalVotesHavingInput>>;
  OR?: Maybe<Array<ProposalVotesHavingInput>>;
};

/** Methods to use when ordering `ProposalVote`. */
export enum ProposalVotesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ProposalIdAsc = 'PROPOSAL_ID_ASC',
  ProposalIdDesc = 'PROPOSAL_ID_DESC',
  AccountAsc = 'ACCOUNT_ASC',
  AccountDesc = 'ACCOUNT_DESC',
  VoteAsc = 'VOTE_ASC',
  VoteDesc = 'VOTE_DESC',
  WeightAsc = 'WEIGHT_ASC',
  WeightDesc = 'WEIGHT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
}

/** A connection to a list of `Proposal` values. */
export type ProposalsConnection = {
  __typename?: 'ProposalsConnection';
  /** A list of `Proposal` objects. */
  nodes: Array<Maybe<Proposal>>;
  /** A list of edges which contains the `Proposal` and cursor to aid in pagination. */
  edges: Array<ProposalsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Proposal` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<ProposalAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<ProposalAggregates>>;
};

/** A connection to a list of `Proposal` values. */
export type ProposalsConnectionGroupedAggregatesArgs = {
  groupBy: Array<ProposalsGroupBy>;
  having?: Maybe<ProposalsHavingInput>;
};

/** A `Proposal` edge in the connection. */
export type ProposalsEdge = {
  __typename?: 'ProposalsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Proposal` at the end of the edge. */
  node?: Maybe<Proposal>;
};

/** Grouping methods for `Proposal` for usage during aggregation. */
export enum ProposalsGroupBy {
  Proposer = 'PROPOSER',
  State = 'STATE',
  OwnerId = 'OWNER_ID',
  Balance = 'BALANCE',
  Url = 'URL',
  Description = 'DESCRIPTION',
  Snapshotted = 'SNAPSHOTTED',
  TotalAyeWeight = 'TOTAL_AYE_WEIGHT',
  TotalNayWeight = 'TOTAL_NAY_WEIGHT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `Proposal` aggregates. */
export type ProposalsHavingInput = {
  AND?: Maybe<Array<ProposalsHavingInput>>;
  OR?: Maybe<Array<ProposalsHavingInput>>;
};

/** Methods to use when ordering `Proposal`. */
export enum ProposalsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ProposerAsc = 'PROPOSER_ASC',
  ProposerDesc = 'PROPOSER_DESC',
  StateAsc = 'STATE_ASC',
  StateDesc = 'STATE_DESC',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  BalanceAsc = 'BALANCE_ASC',
  BalanceDesc = 'BALANCE_DESC',
  UrlAsc = 'URL_ASC',
  UrlDesc = 'URL_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  SnapshottedAsc = 'SNAPSHOTTED_ASC',
  SnapshottedDesc = 'SNAPSHOTTED_DESC',
  TotalAyeWeightAsc = 'TOTAL_AYE_WEIGHT_ASC',
  TotalAyeWeightDesc = 'TOTAL_AYE_WEIGHT_DESC',
  TotalNayWeightAsc = 'TOTAL_NAY_WEIGHT_ASC',
  TotalNayWeightDesc = 'TOTAL_NAY_WEIGHT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  VotesCountAsc = 'VOTES_COUNT_ASC',
  VotesCountDesc = 'VOTES_COUNT_DESC',
}

/** The root query type which gives access points into the data universe. */
export type Query = Node & {
  __typename?: 'Query';
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query;
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
  nodeId: Scalars['ID'];
  /** Fetches an object given its globally unique `ID`. */
  node?: Maybe<Node>;
  /** Reads and enables pagination through a set of `Account`. */
  accounts?: Maybe<AccountsConnection>;
  /** Reads and enables pagination through a set of `AgentGroupMembership`. */
  agentGroupMemberships?: Maybe<AgentGroupMembershipsConnection>;
  /** Reads and enables pagination through a set of `AgentGroup`. */
  agentGroups?: Maybe<AgentGroupsConnection>;
  /** Reads and enables pagination through a set of `AssetDocument`. */
  assetDocuments?: Maybe<AssetDocumentsConnection>;
  /** Reads and enables pagination through a set of `AssetHolder`. */
  assetHolders?: Maybe<AssetHoldersConnection>;
  /** Reads and enables pagination through a set of `AssetPendingOwnershipTransfer`. */
  assetPendingOwnershipTransfers?: Maybe<AssetPendingOwnershipTransfersConnection>;
  /** Reads and enables pagination through a set of `Asset`. */
  assets?: Maybe<AssetsConnection>;
  /** Reads and enables pagination through a set of `Authorization`. */
  authorizations?: Maybe<AuthorizationsConnection>;
  /** Reads and enables pagination through a set of `Block`. */
  blocks?: Maybe<BlocksConnection>;
  /** Reads and enables pagination through a set of `BridgeEvent`. */
  bridgeEvents?: Maybe<BridgeEventsConnection>;
  /** Reads and enables pagination through a set of `ClaimScope`. */
  claimScopes?: Maybe<ClaimScopesConnection>;
  /** Reads and enables pagination through a set of `Claim`. */
  claims?: Maybe<ClaimsConnection>;
  /** Reads and enables pagination through a set of `Compliance`. */
  compliances?: Maybe<CompliancesConnection>;
  /** Reads and enables pagination through a set of `Debug`. */
  debugs?: Maybe<DebugsConnection>;
  /** Reads and enables pagination through a set of `DistributionPayment`. */
  distributionPayments?: Maybe<DistributionPaymentsConnection>;
  /** Reads and enables pagination through a set of `Distribution`. */
  distributions?: Maybe<DistributionsConnection>;
  /** Reads and enables pagination through a set of `Event`. */
  events?: Maybe<EventsConnection>;
  /** Reads and enables pagination through a set of `Extrinsic`. */
  extrinsics?: Maybe<ExtrinsicsConnection>;
  /** Reads and enables pagination through a set of `FoundType`. */
  foundTypes?: Maybe<FoundTypesConnection>;
  /** Reads and enables pagination through a set of `Funding`. */
  fundings?: Maybe<FundingsConnection>;
  /** Reads and enables pagination through a set of `Identity`. */
  identities?: Maybe<IdentitiesConnection>;
  /** Reads and enables pagination through a set of `Instruction`. */
  instructions?: Maybe<InstructionsConnection>;
  /** Reads and enables pagination through a set of `Investment`. */
  investments?: Maybe<InvestmentsConnection>;
  /** Reads and enables pagination through a set of `Leg`. */
  legs?: Maybe<LegsConnection>;
  /** Reads and enables pagination through a set of `Permission`. */
  permissions?: Maybe<PermissionsConnection>;
  /** Reads and enables pagination through a set of `PortfolioMovement`. */
  portfolioMovements?: Maybe<PortfolioMovementsConnection>;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfolios?: Maybe<PortfoliosConnection>;
  /** Reads and enables pagination through a set of `ProposalVote`. */
  proposalVotes?: Maybe<ProposalVotesConnection>;
  /** Reads and enables pagination through a set of `Proposal`. */
  proposals?: Maybe<ProposalsConnection>;
  /** Reads and enables pagination through a set of `Settlement`. */
  settlements?: Maybe<SettlementsConnection>;
  /** Reads and enables pagination through a set of `StakingEvent`. */
  stakingEvents?: Maybe<StakingEventsConnection>;
  /** Reads and enables pagination through a set of `StatType`. */
  statTypes?: Maybe<StatTypesConnection>;
  /** Reads and enables pagination through a set of `Sto`. */
  stos?: Maybe<StosConnection>;
  /** Reads and enables pagination through a set of `Subquery`. */
  subqueries?: Maybe<SubqueriesConnection>;
  /** Reads and enables pagination through a set of `TickerExternalAgentAction`. */
  tickerExternalAgentActions?: Maybe<TickerExternalAgentActionsConnection>;
  /** Reads and enables pagination through a set of `TickerExternalAgentHistory`. */
  tickerExternalAgentHistories?: Maybe<TickerExternalAgentHistoriesConnection>;
  /** Reads and enables pagination through a set of `TickerExternalAgent`. */
  tickerExternalAgents?: Maybe<TickerExternalAgentsConnection>;
  /** Reads and enables pagination through a set of `TransferComplianceExemption`. */
  transferComplianceExemptions?: Maybe<TransferComplianceExemptionsConnection>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliances?: Maybe<TransferCompliancesConnection>;
  /** Reads and enables pagination through a set of `TransferManager`. */
  transferManagers?: Maybe<TransferManagersConnection>;
  /** Reads and enables pagination through a set of `TrustedClaimIssuer`. */
  trustedClaimIssuers?: Maybe<TrustedClaimIssuersConnection>;
  /** Reads and enables pagination through a set of `Venue`. */
  venues?: Maybe<VenuesConnection>;
  account?: Maybe<Account>;
  agentGroupMembership?: Maybe<AgentGroupMembership>;
  agentGroup?: Maybe<AgentGroup>;
  assetDocument?: Maybe<AssetDocument>;
  assetHolder?: Maybe<AssetHolder>;
  assetPendingOwnershipTransfer?: Maybe<AssetPendingOwnershipTransfer>;
  asset?: Maybe<Asset>;
  authorization?: Maybe<Authorization>;
  block?: Maybe<Block>;
  bridgeEvent?: Maybe<BridgeEvent>;
  claimScope?: Maybe<ClaimScope>;
  claim?: Maybe<Claim>;
  compliance?: Maybe<Compliance>;
  debug?: Maybe<Debug>;
  distributionPayment?: Maybe<DistributionPayment>;
  distribution?: Maybe<Distribution>;
  event?: Maybe<Event>;
  extrinsic?: Maybe<Extrinsic>;
  foundType?: Maybe<FoundType>;
  funding?: Maybe<Funding>;
  identity?: Maybe<Identity>;
  instruction?: Maybe<Instruction>;
  investment?: Maybe<Investment>;
  leg?: Maybe<Leg>;
  permission?: Maybe<Permission>;
  portfolioMovement?: Maybe<PortfolioMovement>;
  portfolio?: Maybe<Portfolio>;
  proposalVote?: Maybe<ProposalVote>;
  proposal?: Maybe<Proposal>;
  settlement?: Maybe<Settlement>;
  stakingEvent?: Maybe<StakingEvent>;
  statType?: Maybe<StatType>;
  sto?: Maybe<Sto>;
  subquery?: Maybe<Subquery>;
  subqueryByName?: Maybe<Subquery>;
  tickerExternalAgentAction?: Maybe<TickerExternalAgentAction>;
  tickerExternalAgentHistory?: Maybe<TickerExternalAgentHistory>;
  tickerExternalAgent?: Maybe<TickerExternalAgent>;
  transferComplianceExemption?: Maybe<TransferComplianceExemption>;
  transferCompliance?: Maybe<TransferCompliance>;
  transferManager?: Maybe<TransferManager>;
  trustedClaimIssuer?: Maybe<TrustedClaimIssuer>;
  venue?: Maybe<Venue>;
  /** Reads a single `Account` using its globally unique `ID`. */
  accountByNodeId?: Maybe<Account>;
  /** Reads a single `AgentGroupMembership` using its globally unique `ID`. */
  agentGroupMembershipByNodeId?: Maybe<AgentGroupMembership>;
  /** Reads a single `AgentGroup` using its globally unique `ID`. */
  agentGroupByNodeId?: Maybe<AgentGroup>;
  /** Reads a single `AssetDocument` using its globally unique `ID`. */
  assetDocumentByNodeId?: Maybe<AssetDocument>;
  /** Reads a single `AssetHolder` using its globally unique `ID`. */
  assetHolderByNodeId?: Maybe<AssetHolder>;
  /** Reads a single `AssetPendingOwnershipTransfer` using its globally unique `ID`. */
  assetPendingOwnershipTransferByNodeId?: Maybe<AssetPendingOwnershipTransfer>;
  /** Reads a single `Asset` using its globally unique `ID`. */
  assetByNodeId?: Maybe<Asset>;
  /** Reads a single `Authorization` using its globally unique `ID`. */
  authorizationByNodeId?: Maybe<Authorization>;
  /** Reads a single `Block` using its globally unique `ID`. */
  blockByNodeId?: Maybe<Block>;
  /** Reads a single `BridgeEvent` using its globally unique `ID`. */
  bridgeEventByNodeId?: Maybe<BridgeEvent>;
  /** Reads a single `ClaimScope` using its globally unique `ID`. */
  claimScopeByNodeId?: Maybe<ClaimScope>;
  /** Reads a single `Claim` using its globally unique `ID`. */
  claimByNodeId?: Maybe<Claim>;
  /** Reads a single `Compliance` using its globally unique `ID`. */
  complianceByNodeId?: Maybe<Compliance>;
  /** Reads a single `Debug` using its globally unique `ID`. */
  debugByNodeId?: Maybe<Debug>;
  /** Reads a single `DistributionPayment` using its globally unique `ID`. */
  distributionPaymentByNodeId?: Maybe<DistributionPayment>;
  /** Reads a single `Distribution` using its globally unique `ID`. */
  distributionByNodeId?: Maybe<Distribution>;
  /** Reads a single `Event` using its globally unique `ID`. */
  eventByNodeId?: Maybe<Event>;
  /** Reads a single `Extrinsic` using its globally unique `ID`. */
  extrinsicByNodeId?: Maybe<Extrinsic>;
  /** Reads a single `FoundType` using its globally unique `ID`. */
  foundTypeByNodeId?: Maybe<FoundType>;
  /** Reads a single `Funding` using its globally unique `ID`. */
  fundingByNodeId?: Maybe<Funding>;
  /** Reads a single `Identity` using its globally unique `ID`. */
  identityByNodeId?: Maybe<Identity>;
  /** Reads a single `Instruction` using its globally unique `ID`. */
  instructionByNodeId?: Maybe<Instruction>;
  /** Reads a single `Investment` using its globally unique `ID`. */
  investmentByNodeId?: Maybe<Investment>;
  /** Reads a single `Leg` using its globally unique `ID`. */
  legByNodeId?: Maybe<Leg>;
  /** Reads a single `Permission` using its globally unique `ID`. */
  permissionByNodeId?: Maybe<Permission>;
  /** Reads a single `PortfolioMovement` using its globally unique `ID`. */
  portfolioMovementByNodeId?: Maybe<PortfolioMovement>;
  /** Reads a single `Portfolio` using its globally unique `ID`. */
  portfolioByNodeId?: Maybe<Portfolio>;
  /** Reads a single `ProposalVote` using its globally unique `ID`. */
  proposalVoteByNodeId?: Maybe<ProposalVote>;
  /** Reads a single `Proposal` using its globally unique `ID`. */
  proposalByNodeId?: Maybe<Proposal>;
  /** Reads a single `Settlement` using its globally unique `ID`. */
  settlementByNodeId?: Maybe<Settlement>;
  /** Reads a single `StakingEvent` using its globally unique `ID`. */
  stakingEventByNodeId?: Maybe<StakingEvent>;
  /** Reads a single `StatType` using its globally unique `ID`. */
  statTypeByNodeId?: Maybe<StatType>;
  /** Reads a single `Sto` using its globally unique `ID`. */
  stoByNodeId?: Maybe<Sto>;
  /** Reads a single `Subquery` using its globally unique `ID`. */
  subqueryByNodeId?: Maybe<Subquery>;
  /** Reads a single `TickerExternalAgentAction` using its globally unique `ID`. */
  tickerExternalAgentActionByNodeId?: Maybe<TickerExternalAgentAction>;
  /** Reads a single `TickerExternalAgentHistory` using its globally unique `ID`. */
  tickerExternalAgentHistoryByNodeId?: Maybe<TickerExternalAgentHistory>;
  /** Reads a single `TickerExternalAgent` using its globally unique `ID`. */
  tickerExternalAgentByNodeId?: Maybe<TickerExternalAgent>;
  /** Reads a single `TransferComplianceExemption` using its globally unique `ID`. */
  transferComplianceExemptionByNodeId?: Maybe<TransferComplianceExemption>;
  /** Reads a single `TransferCompliance` using its globally unique `ID`. */
  transferComplianceByNodeId?: Maybe<TransferCompliance>;
  /** Reads a single `TransferManager` using its globally unique `ID`. */
  transferManagerByNodeId?: Maybe<TransferManager>;
  /** Reads a single `TrustedClaimIssuer` using its globally unique `ID`. */
  trustedClaimIssuerByNodeId?: Maybe<TrustedClaimIssuer>;
  /** Reads a single `Venue` using its globally unique `ID`. */
  venueByNodeId?: Maybe<Venue>;
  _metadata?: Maybe<_Metadata>;
};

/** The root query type which gives access points into the data universe. */
export type QueryNodeArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryAccountsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AccountsOrderBy>>;
  filter?: Maybe<AccountFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryAgentGroupMembershipsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AgentGroupMembershipsOrderBy>>;
  filter?: Maybe<AgentGroupMembershipFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryAgentGroupsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AgentGroupsOrderBy>>;
  filter?: Maybe<AgentGroupFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryAssetDocumentsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetDocumentsOrderBy>>;
  filter?: Maybe<AssetDocumentFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryAssetHoldersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetHoldersOrderBy>>;
  filter?: Maybe<AssetHolderFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryAssetPendingOwnershipTransfersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetPendingOwnershipTransfersOrderBy>>;
  filter?: Maybe<AssetPendingOwnershipTransferFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryAssetsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryAuthorizationsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AuthorizationsOrderBy>>;
  filter?: Maybe<AuthorizationFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryBlocksArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryBridgeEventsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BridgeEventsOrderBy>>;
  filter?: Maybe<BridgeEventFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryClaimScopesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ClaimScopesOrderBy>>;
  filter?: Maybe<ClaimScopeFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryClaimsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ClaimsOrderBy>>;
  filter?: Maybe<ClaimFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryCompliancesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CompliancesOrderBy>>;
  filter?: Maybe<ComplianceFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryDebugsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<DebugsOrderBy>>;
  filter?: Maybe<DebugFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryDistributionPaymentsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<DistributionPaymentsOrderBy>>;
  filter?: Maybe<DistributionPaymentFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryDistributionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<DistributionsOrderBy>>;
  filter?: Maybe<DistributionFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryEventsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<EventsOrderBy>>;
  filter?: Maybe<EventFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryExtrinsicsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ExtrinsicsOrderBy>>;
  filter?: Maybe<ExtrinsicFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryFoundTypesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<FoundTypesOrderBy>>;
  filter?: Maybe<FoundTypeFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryFundingsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<FundingsOrderBy>>;
  filter?: Maybe<FundingFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryIdentitiesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryInstructionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<InstructionsOrderBy>>;
  filter?: Maybe<InstructionFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryInvestmentsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<InvestmentsOrderBy>>;
  filter?: Maybe<InvestmentFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryLegsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<LegsOrderBy>>;
  filter?: Maybe<LegFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryPermissionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PermissionsOrderBy>>;
  filter?: Maybe<PermissionFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryPortfolioMovementsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PortfolioMovementsOrderBy>>;
  filter?: Maybe<PortfolioMovementFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryPortfoliosArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PortfoliosOrderBy>>;
  filter?: Maybe<PortfolioFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryProposalVotesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ProposalVotesOrderBy>>;
  filter?: Maybe<ProposalVoteFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryProposalsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ProposalsOrderBy>>;
  filter?: Maybe<ProposalFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QuerySettlementsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<SettlementsOrderBy>>;
  filter?: Maybe<SettlementFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryStakingEventsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StakingEventsOrderBy>>;
  filter?: Maybe<StakingEventFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryStatTypesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StatTypesOrderBy>>;
  filter?: Maybe<StatTypeFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryStosArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<StosOrderBy>>;
  filter?: Maybe<StoFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QuerySubqueriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<SubqueriesOrderBy>>;
  filter?: Maybe<SubqueryFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryTickerExternalAgentActionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TickerExternalAgentActionsOrderBy>>;
  filter?: Maybe<TickerExternalAgentActionFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryTickerExternalAgentHistoriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TickerExternalAgentHistoriesOrderBy>>;
  filter?: Maybe<TickerExternalAgentHistoryFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryTickerExternalAgentsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TickerExternalAgentsOrderBy>>;
  filter?: Maybe<TickerExternalAgentFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryTransferComplianceExemptionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TransferComplianceExemptionsOrderBy>>;
  filter?: Maybe<TransferComplianceExemptionFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryTransferCompliancesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TransferCompliancesOrderBy>>;
  filter?: Maybe<TransferComplianceFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryTransferManagersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TransferManagersOrderBy>>;
  filter?: Maybe<TransferManagerFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryTrustedClaimIssuersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TrustedClaimIssuersOrderBy>>;
  filter?: Maybe<TrustedClaimIssuerFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryVenuesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VenuesOrderBy>>;
  filter?: Maybe<VenueFilter>;
};

/** The root query type which gives access points into the data universe. */
export type QueryAccountArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryAgentGroupMembershipArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryAgentGroupArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryAssetDocumentArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryAssetHolderArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryAssetPendingOwnershipTransferArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryAssetArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryAuthorizationArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryBlockArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryBridgeEventArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryClaimScopeArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryClaimArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryComplianceArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryDebugArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryDistributionPaymentArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryDistributionArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryEventArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryExtrinsicArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryFoundTypeArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryFundingArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryIdentityArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryInstructionArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryInvestmentArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryLegArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryPermissionArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryPortfolioMovementArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryPortfolioArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryProposalVoteArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryProposalArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QuerySettlementArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryStakingEventArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryStatTypeArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryStoArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QuerySubqueryArgs = {
  id: Scalars['Int'];
};

/** The root query type which gives access points into the data universe. */
export type QuerySubqueryByNameArgs = {
  name: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryTickerExternalAgentActionArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryTickerExternalAgentHistoryArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryTickerExternalAgentArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryTransferComplianceExemptionArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryTransferComplianceArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryTransferManagerArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryTrustedClaimIssuerArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryVenueArgs = {
  id: Scalars['String'];
};

/** The root query type which gives access points into the data universe. */
export type QueryAccountByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryAgentGroupMembershipByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryAgentGroupByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryAssetDocumentByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryAssetHolderByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryAssetPendingOwnershipTransferByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryAssetByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryAuthorizationByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryBlockByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryBridgeEventByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryClaimScopeByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryClaimByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryComplianceByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryDebugByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryDistributionPaymentByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryDistributionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryEventByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryExtrinsicByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryFoundTypeByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryFundingByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryIdentityByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryInstructionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryInvestmentByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryLegByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryPermissionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryPortfolioMovementByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryPortfolioByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryProposalVoteByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryProposalByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QuerySettlementByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryStakingEventByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryStatTypeByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryStoByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QuerySubqueryByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryTickerExternalAgentActionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryTickerExternalAgentHistoryByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryTickerExternalAgentByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryTransferComplianceExemptionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryTransferComplianceByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryTransferManagerByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryTrustedClaimIssuerByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** The root query type which gives access points into the data universe. */
export type QueryVenueByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

export type Settlement = Node & {
  __typename?: 'Settlement';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  addresses: Scalars['JSON'];
  result: Scalars['String'];
  createdBlockId: Scalars['String'];
  updatedBlockId: Scalars['String'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Block` that is related to this `Settlement`. */
  createdBlock?: Maybe<Block>;
  /** Reads a single `Block` that is related to this `Settlement`. */
  updatedBlock?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Leg`. */
  legs: LegsConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByLegSettlementIdAndFromId: SettlementPortfoliosByLegSettlementIdAndFromIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Portfolio`. */
  portfoliosByLegSettlementIdAndToId: SettlementPortfoliosByLegSettlementIdAndToIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Instruction`. */
  instructionsByLegSettlementIdAndInstructionId: SettlementInstructionsByLegSettlementIdAndInstructionIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByLegSettlementIdAndCreatedBlockId: SettlementBlocksByLegSettlementIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByLegSettlementIdAndUpdatedBlockId: SettlementBlocksByLegSettlementIdAndUpdatedBlockIdManyToManyConnection;
};

export type SettlementLegsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<LegsOrderBy>>;
  filter?: Maybe<LegFilter>;
};

export type SettlementPortfoliosByLegSettlementIdAndFromIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PortfoliosOrderBy>>;
  filter?: Maybe<PortfolioFilter>;
};

export type SettlementPortfoliosByLegSettlementIdAndToIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PortfoliosOrderBy>>;
  filter?: Maybe<PortfolioFilter>;
};

export type SettlementInstructionsByLegSettlementIdAndInstructionIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<InstructionsOrderBy>>;
  filter?: Maybe<InstructionFilter>;
};

export type SettlementBlocksByLegSettlementIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type SettlementBlocksByLegSettlementIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type SettlementAggregates = {
  __typename?: 'SettlementAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A connection to a list of `Block` values, with data from `Leg`. */
export type SettlementBlocksByLegSettlementIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'SettlementBlocksByLegSettlementIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<SettlementBlocksByLegSettlementIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Leg`. */
export type SettlementBlocksByLegSettlementIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Leg`. */
export type SettlementBlocksByLegSettlementIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'SettlementBlocksByLegSettlementIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByCreatedBlockId: LegsConnection;
};

/** A `Block` edge in the connection, with data from `Leg`. */
export type SettlementBlocksByLegSettlementIdAndCreatedBlockIdManyToManyEdgeLegsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<LegsOrderBy>>;
    filter?: Maybe<LegFilter>;
  };

/** A connection to a list of `Block` values, with data from `Leg`. */
export type SettlementBlocksByLegSettlementIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'SettlementBlocksByLegSettlementIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<SettlementBlocksByLegSettlementIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Leg`. */
export type SettlementBlocksByLegSettlementIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Leg`. */
export type SettlementBlocksByLegSettlementIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'SettlementBlocksByLegSettlementIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByUpdatedBlockId: LegsConnection;
};

/** A `Block` edge in the connection, with data from `Leg`. */
export type SettlementBlocksByLegSettlementIdAndUpdatedBlockIdManyToManyEdgeLegsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<LegsOrderBy>>;
    filter?: Maybe<LegFilter>;
  };

/** A filter to be used against `Settlement` object types. All fields are combined with a logical ‘and.’ */
export type SettlementFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `addresses` field. */
  addresses?: Maybe<JsonFilter>;
  /** Filter by the object’s `result` field. */
  result?: Maybe<StringFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<SettlementFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<SettlementFilter>>;
  /** Negates the expression. */
  not?: Maybe<SettlementFilter>;
};

/** A connection to a list of `Instruction` values, with data from `Leg`. */
export type SettlementInstructionsByLegSettlementIdAndInstructionIdManyToManyConnection = {
  __typename?: 'SettlementInstructionsByLegSettlementIdAndInstructionIdManyToManyConnection';
  /** A list of `Instruction` objects. */
  nodes: Array<Maybe<Instruction>>;
  /** A list of edges which contains the `Instruction`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<SettlementInstructionsByLegSettlementIdAndInstructionIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Instruction` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<InstructionAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<InstructionAggregates>>;
};

/** A connection to a list of `Instruction` values, with data from `Leg`. */
export type SettlementInstructionsByLegSettlementIdAndInstructionIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<InstructionsGroupBy>;
    having?: Maybe<InstructionsHavingInput>;
  };

/** A `Instruction` edge in the connection, with data from `Leg`. */
export type SettlementInstructionsByLegSettlementIdAndInstructionIdManyToManyEdge = {
  __typename?: 'SettlementInstructionsByLegSettlementIdAndInstructionIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Instruction` at the end of the edge. */
  node?: Maybe<Instruction>;
  /** Reads and enables pagination through a set of `Leg`. */
  legs: LegsConnection;
};

/** A `Instruction` edge in the connection, with data from `Leg`. */
export type SettlementInstructionsByLegSettlementIdAndInstructionIdManyToManyEdgeLegsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<LegsOrderBy>>;
  filter?: Maybe<LegFilter>;
};

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type SettlementPortfoliosByLegSettlementIdAndFromIdManyToManyConnection = {
  __typename?: 'SettlementPortfoliosByLegSettlementIdAndFromIdManyToManyConnection';
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** A list of edges which contains the `Portfolio`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<SettlementPortfoliosByLegSettlementIdAndFromIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
};

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type SettlementPortfoliosByLegSettlementIdAndFromIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: Maybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type SettlementPortfoliosByLegSettlementIdAndFromIdManyToManyEdge = {
  __typename?: 'SettlementPortfoliosByLegSettlementIdAndFromIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByFromId: LegsConnection;
};

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type SettlementPortfoliosByLegSettlementIdAndFromIdManyToManyEdgeLegsByFromIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<LegsOrderBy>>;
  filter?: Maybe<LegFilter>;
};

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type SettlementPortfoliosByLegSettlementIdAndToIdManyToManyConnection = {
  __typename?: 'SettlementPortfoliosByLegSettlementIdAndToIdManyToManyConnection';
  /** A list of `Portfolio` objects. */
  nodes: Array<Maybe<Portfolio>>;
  /** A list of edges which contains the `Portfolio`, info from the `Leg`, and the cursor to aid in pagination. */
  edges: Array<SettlementPortfoliosByLegSettlementIdAndToIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Portfolio` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PortfolioAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PortfolioAggregates>>;
};

/** A connection to a list of `Portfolio` values, with data from `Leg`. */
export type SettlementPortfoliosByLegSettlementIdAndToIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<PortfoliosGroupBy>;
    having?: Maybe<PortfoliosHavingInput>;
  };

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type SettlementPortfoliosByLegSettlementIdAndToIdManyToManyEdge = {
  __typename?: 'SettlementPortfoliosByLegSettlementIdAndToIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Portfolio` at the end of the edge. */
  node?: Maybe<Portfolio>;
  /** Reads and enables pagination through a set of `Leg`. */
  legsByToId: LegsConnection;
};

/** A `Portfolio` edge in the connection, with data from `Leg`. */
export type SettlementPortfoliosByLegSettlementIdAndToIdManyToManyEdgeLegsByToIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<LegsOrderBy>>;
  filter?: Maybe<LegFilter>;
};

/** A connection to a list of `Settlement` values. */
export type SettlementsConnection = {
  __typename?: 'SettlementsConnection';
  /** A list of `Settlement` objects. */
  nodes: Array<Maybe<Settlement>>;
  /** A list of edges which contains the `Settlement` and cursor to aid in pagination. */
  edges: Array<SettlementsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Settlement` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<SettlementAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<SettlementAggregates>>;
};

/** A connection to a list of `Settlement` values. */
export type SettlementsConnectionGroupedAggregatesArgs = {
  groupBy: Array<SettlementsGroupBy>;
  having?: Maybe<SettlementsHavingInput>;
};

/** A `Settlement` edge in the connection. */
export type SettlementsEdge = {
  __typename?: 'SettlementsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Settlement` at the end of the edge. */
  node?: Maybe<Settlement>;
};

/** Grouping methods for `Settlement` for usage during aggregation. */
export enum SettlementsGroupBy {
  Addresses = 'ADDRESSES',
  Result = 'RESULT',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `Settlement` aggregates. */
export type SettlementsHavingInput = {
  AND?: Maybe<Array<SettlementsHavingInput>>;
  OR?: Maybe<Array<SettlementsHavingInput>>;
};

/** Methods to use when ordering `Settlement`. */
export enum SettlementsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  AddressesAsc = 'ADDRESSES_ASC',
  AddressesDesc = 'ADDRESSES_DESC',
  ResultAsc = 'RESULT_ASC',
  ResultDesc = 'RESULT_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  LegsCountAsc = 'LEGS_COUNT_ASC',
  LegsCountDesc = 'LEGS_COUNT_DESC',
}

export type StakingEvent = Node & {
  __typename?: 'StakingEvent';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  stashAccount?: Maybe<Scalars['String']>;
  identityId?: Maybe<Scalars['String']>;
  eventId: Scalars['String'];
  amount?: Maybe<Scalars['BigFloat']>;
  nominatedValidators?: Maybe<Scalars['JSON']>;
  transactionId?: Maybe<Scalars['String']>;
  datetime: Scalars['Datetime'];
  createdBlockId: Scalars['String'];
  updatedBlockId: Scalars['String'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Identity` that is related to this `StakingEvent`. */
  identity?: Maybe<Identity>;
  /** Reads a single `Block` that is related to this `StakingEvent`. */
  createdBlock?: Maybe<Block>;
  /** Reads a single `Block` that is related to this `StakingEvent`. */
  updatedBlock?: Maybe<Block>;
};

export type StakingEventAggregates = {
  __typename?: 'StakingEventAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `StakingEvent` object types. All fields are combined with a logical ‘and.’ */
export type StakingEventFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `stashAccount` field. */
  stashAccount?: Maybe<StringFilter>;
  /** Filter by the object’s `identityId` field. */
  identityId?: Maybe<StringFilter>;
  /** Filter by the object’s `eventId` field. */
  eventId?: Maybe<StringFilter>;
  /** Filter by the object’s `amount` field. */
  amount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `nominatedValidators` field. */
  nominatedValidators?: Maybe<JsonFilter>;
  /** Filter by the object’s `transactionId` field. */
  transactionId?: Maybe<StringFilter>;
  /** Filter by the object’s `datetime` field. */
  datetime?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<StakingEventFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<StakingEventFilter>>;
  /** Negates the expression. */
  not?: Maybe<StakingEventFilter>;
};

/** A connection to a list of `StakingEvent` values. */
export type StakingEventsConnection = {
  __typename?: 'StakingEventsConnection';
  /** A list of `StakingEvent` objects. */
  nodes: Array<Maybe<StakingEvent>>;
  /** A list of edges which contains the `StakingEvent` and cursor to aid in pagination. */
  edges: Array<StakingEventsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `StakingEvent` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<StakingEventAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<StakingEventAggregates>>;
};

/** A connection to a list of `StakingEvent` values. */
export type StakingEventsConnectionGroupedAggregatesArgs = {
  groupBy: Array<StakingEventsGroupBy>;
  having?: Maybe<StakingEventsHavingInput>;
};

/** A `StakingEvent` edge in the connection. */
export type StakingEventsEdge = {
  __typename?: 'StakingEventsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `StakingEvent` at the end of the edge. */
  node?: Maybe<StakingEvent>;
};

/** Grouping methods for `StakingEvent` for usage during aggregation. */
export enum StakingEventsGroupBy {
  StashAccount = 'STASH_ACCOUNT',
  IdentityId = 'IDENTITY_ID',
  EventId = 'EVENT_ID',
  Amount = 'AMOUNT',
  NominatedValidators = 'NOMINATED_VALIDATORS',
  TransactionId = 'TRANSACTION_ID',
  Datetime = 'DATETIME',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `StakingEvent` aggregates. */
export type StakingEventsHavingInput = {
  AND?: Maybe<Array<StakingEventsHavingInput>>;
  OR?: Maybe<Array<StakingEventsHavingInput>>;
};

/** Methods to use when ordering `StakingEvent`. */
export enum StakingEventsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  StashAccountAsc = 'STASH_ACCOUNT_ASC',
  StashAccountDesc = 'STASH_ACCOUNT_DESC',
  IdentityIdAsc = 'IDENTITY_ID_ASC',
  IdentityIdDesc = 'IDENTITY_ID_DESC',
  EventIdAsc = 'EVENT_ID_ASC',
  EventIdDesc = 'EVENT_ID_DESC',
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  NominatedValidatorsAsc = 'NOMINATED_VALIDATORS_ASC',
  NominatedValidatorsDesc = 'NOMINATED_VALIDATORS_DESC',
  TransactionIdAsc = 'TRANSACTION_ID_ASC',
  TransactionIdDesc = 'TRANSACTION_ID_DESC',
  DatetimeAsc = 'DATETIME_ASC',
  DatetimeDesc = 'DATETIME_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
}

export type StatType = Node & {
  __typename?: 'StatType';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  assetId: Scalars['String'];
  opType: Scalars['String'];
  claimType?: Maybe<Scalars['String']>;
  claimIssuerId?: Maybe<Scalars['String']>;
  createdBlockId: Scalars['String'];
  updatedBlockId: Scalars['String'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Asset` that is related to this `StatType`. */
  asset?: Maybe<Asset>;
  /** Reads a single `Identity` that is related to this `StatType`. */
  claimIssuer?: Maybe<Identity>;
  /** Reads a single `Block` that is related to this `StatType`. */
  createdBlock?: Maybe<Block>;
  /** Reads a single `Block` that is related to this `StatType`. */
  updatedBlock?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliances: TransferCompliancesConnection;
  /** Reads and enables pagination through a set of `Asset`. */
  assetsByTransferComplianceStatTypeIdAndAssetId: StatTypeAssetsByTransferComplianceStatTypeIdAndAssetIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Identity`. */
  identitiesByTransferComplianceStatTypeIdAndClaimIssuerId: StatTypeIdentitiesByTransferComplianceStatTypeIdAndClaimIssuerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTransferComplianceStatTypeIdAndCreatedBlockId: StatTypeBlocksByTransferComplianceStatTypeIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByTransferComplianceStatTypeIdAndUpdatedBlockId: StatTypeBlocksByTransferComplianceStatTypeIdAndUpdatedBlockIdManyToManyConnection;
};

export type StatTypeTransferCompliancesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TransferCompliancesOrderBy>>;
  filter?: Maybe<TransferComplianceFilter>;
};

export type StatTypeAssetsByTransferComplianceStatTypeIdAndAssetIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AssetsOrderBy>>;
  filter?: Maybe<AssetFilter>;
};

export type StatTypeIdentitiesByTransferComplianceStatTypeIdAndClaimIssuerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<IdentitiesOrderBy>>;
  filter?: Maybe<IdentityFilter>;
};

export type StatTypeBlocksByTransferComplianceStatTypeIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type StatTypeBlocksByTransferComplianceStatTypeIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type StatTypeAggregates = {
  __typename?: 'StatTypeAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A connection to a list of `Asset` values, with data from `TransferCompliance`. */
export type StatTypeAssetsByTransferComplianceStatTypeIdAndAssetIdManyToManyConnection = {
  __typename?: 'StatTypeAssetsByTransferComplianceStatTypeIdAndAssetIdManyToManyConnection';
  /** A list of `Asset` objects. */
  nodes: Array<Maybe<Asset>>;
  /** A list of edges which contains the `Asset`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
  edges: Array<StatTypeAssetsByTransferComplianceStatTypeIdAndAssetIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Asset` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AssetAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AssetAggregates>>;
};

/** A connection to a list of `Asset` values, with data from `TransferCompliance`. */
export type StatTypeAssetsByTransferComplianceStatTypeIdAndAssetIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<AssetsGroupBy>;
    having?: Maybe<AssetsHavingInput>;
  };

/** A `Asset` edge in the connection, with data from `TransferCompliance`. */
export type StatTypeAssetsByTransferComplianceStatTypeIdAndAssetIdManyToManyEdge = {
  __typename?: 'StatTypeAssetsByTransferComplianceStatTypeIdAndAssetIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Asset` at the end of the edge. */
  node?: Maybe<Asset>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliances: TransferCompliancesConnection;
};

/** A `Asset` edge in the connection, with data from `TransferCompliance`. */
export type StatTypeAssetsByTransferComplianceStatTypeIdAndAssetIdManyToManyEdgeTransferCompliancesArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TransferCompliancesOrderBy>>;
    filter?: Maybe<TransferComplianceFilter>;
  };

/** A connection to a list of `Block` values, with data from `TransferCompliance`. */
export type StatTypeBlocksByTransferComplianceStatTypeIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'StatTypeBlocksByTransferComplianceStatTypeIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
  edges: Array<StatTypeBlocksByTransferComplianceStatTypeIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `TransferCompliance`. */
export type StatTypeBlocksByTransferComplianceStatTypeIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TransferCompliance`. */
export type StatTypeBlocksByTransferComplianceStatTypeIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'StatTypeBlocksByTransferComplianceStatTypeIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliancesByCreatedBlockId: TransferCompliancesConnection;
};

/** A `Block` edge in the connection, with data from `TransferCompliance`. */
export type StatTypeBlocksByTransferComplianceStatTypeIdAndCreatedBlockIdManyToManyEdgeTransferCompliancesByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TransferCompliancesOrderBy>>;
    filter?: Maybe<TransferComplianceFilter>;
  };

/** A connection to a list of `Block` values, with data from `TransferCompliance`. */
export type StatTypeBlocksByTransferComplianceStatTypeIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'StatTypeBlocksByTransferComplianceStatTypeIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
  edges: Array<StatTypeBlocksByTransferComplianceStatTypeIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `TransferCompliance`. */
export type StatTypeBlocksByTransferComplianceStatTypeIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `TransferCompliance`. */
export type StatTypeBlocksByTransferComplianceStatTypeIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'StatTypeBlocksByTransferComplianceStatTypeIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliancesByUpdatedBlockId: TransferCompliancesConnection;
};

/** A `Block` edge in the connection, with data from `TransferCompliance`. */
export type StatTypeBlocksByTransferComplianceStatTypeIdAndUpdatedBlockIdManyToManyEdgeTransferCompliancesByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TransferCompliancesOrderBy>>;
    filter?: Maybe<TransferComplianceFilter>;
  };

/** A filter to be used against `StatType` object types. All fields are combined with a logical ‘and.’ */
export type StatTypeFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `assetId` field. */
  assetId?: Maybe<StringFilter>;
  /** Filter by the object’s `opType` field. */
  opType?: Maybe<StringFilter>;
  /** Filter by the object’s `claimType` field. */
  claimType?: Maybe<StringFilter>;
  /** Filter by the object’s `claimIssuerId` field. */
  claimIssuerId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<StatTypeFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<StatTypeFilter>>;
  /** Negates the expression. */
  not?: Maybe<StatTypeFilter>;
};

/** A connection to a list of `Identity` values, with data from `TransferCompliance`. */
export type StatTypeIdentitiesByTransferComplianceStatTypeIdAndClaimIssuerIdManyToManyConnection = {
  __typename?: 'StatTypeIdentitiesByTransferComplianceStatTypeIdAndClaimIssuerIdManyToManyConnection';
  /** A list of `Identity` objects. */
  nodes: Array<Maybe<Identity>>;
  /** A list of edges which contains the `Identity`, info from the `TransferCompliance`, and the cursor to aid in pagination. */
  edges: Array<StatTypeIdentitiesByTransferComplianceStatTypeIdAndClaimIssuerIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Identity` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<IdentityAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<IdentityAggregates>>;
};

/** A connection to a list of `Identity` values, with data from `TransferCompliance`. */
export type StatTypeIdentitiesByTransferComplianceStatTypeIdAndClaimIssuerIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<IdentitiesGroupBy>;
    having?: Maybe<IdentitiesHavingInput>;
  };

/** A `Identity` edge in the connection, with data from `TransferCompliance`. */
export type StatTypeIdentitiesByTransferComplianceStatTypeIdAndClaimIssuerIdManyToManyEdge = {
  __typename?: 'StatTypeIdentitiesByTransferComplianceStatTypeIdAndClaimIssuerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Identity` at the end of the edge. */
  node?: Maybe<Identity>;
  /** Reads and enables pagination through a set of `TransferCompliance`. */
  transferCompliancesByClaimIssuerId: TransferCompliancesConnection;
};

/** A `Identity` edge in the connection, with data from `TransferCompliance`. */
export type StatTypeIdentitiesByTransferComplianceStatTypeIdAndClaimIssuerIdManyToManyEdgeTransferCompliancesByClaimIssuerIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<TransferCompliancesOrderBy>>;
    filter?: Maybe<TransferComplianceFilter>;
  };

/** A connection to a list of `StatType` values. */
export type StatTypesConnection = {
  __typename?: 'StatTypesConnection';
  /** A list of `StatType` objects. */
  nodes: Array<Maybe<StatType>>;
  /** A list of edges which contains the `StatType` and cursor to aid in pagination. */
  edges: Array<StatTypesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `StatType` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<StatTypeAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<StatTypeAggregates>>;
};

/** A connection to a list of `StatType` values. */
export type StatTypesConnectionGroupedAggregatesArgs = {
  groupBy: Array<StatTypesGroupBy>;
  having?: Maybe<StatTypesHavingInput>;
};

/** A `StatType` edge in the connection. */
export type StatTypesEdge = {
  __typename?: 'StatTypesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `StatType` at the end of the edge. */
  node?: Maybe<StatType>;
};

/** Grouping methods for `StatType` for usage during aggregation. */
export enum StatTypesGroupBy {
  AssetId = 'ASSET_ID',
  OpType = 'OP_TYPE',
  ClaimType = 'CLAIM_TYPE',
  ClaimIssuerId = 'CLAIM_ISSUER_ID',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `StatType` aggregates. */
export type StatTypesHavingInput = {
  AND?: Maybe<Array<StatTypesHavingInput>>;
  OR?: Maybe<Array<StatTypesHavingInput>>;
};

/** Methods to use when ordering `StatType`. */
export enum StatTypesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  AssetIdAsc = 'ASSET_ID_ASC',
  AssetIdDesc = 'ASSET_ID_DESC',
  OpTypeAsc = 'OP_TYPE_ASC',
  OpTypeDesc = 'OP_TYPE_DESC',
  ClaimTypeAsc = 'CLAIM_TYPE_ASC',
  ClaimTypeDesc = 'CLAIM_TYPE_DESC',
  ClaimIssuerIdAsc = 'CLAIM_ISSUER_ID_ASC',
  ClaimIssuerIdDesc = 'CLAIM_ISSUER_ID_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TransferCompliancesCountAsc = 'TRANSFER_COMPLIANCES_COUNT_ASC',
  TransferCompliancesCountDesc = 'TRANSFER_COMPLIANCES_COUNT_DESC',
}

export type Sto = Node & {
  __typename?: 'Sto';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  offeringAssetId: Scalars['String'];
  createdBlockId: Scalars['String'];
  updatedBlockId: Scalars['String'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Asset` that is related to this `Sto`. */
  offeringAsset?: Maybe<Asset>;
  /** Reads a single `Block` that is related to this `Sto`. */
  createdBlock?: Maybe<Block>;
  /** Reads a single `Block` that is related to this `Sto`. */
  updatedBlock?: Maybe<Block>;
};

export type StoAggregates = {
  __typename?: 'StoAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `Sto` object types. All fields are combined with a logical ‘and.’ */
export type StoFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `offeringAssetId` field. */
  offeringAssetId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<StoFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<StoFilter>>;
  /** Negates the expression. */
  not?: Maybe<StoFilter>;
};

/** A connection to a list of `Sto` values. */
export type StosConnection = {
  __typename?: 'StosConnection';
  /** A list of `Sto` objects. */
  nodes: Array<Maybe<Sto>>;
  /** A list of edges which contains the `Sto` and cursor to aid in pagination. */
  edges: Array<StosEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Sto` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<StoAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<StoAggregates>>;
};

/** A connection to a list of `Sto` values. */
export type StosConnectionGroupedAggregatesArgs = {
  groupBy: Array<StosGroupBy>;
  having?: Maybe<StosHavingInput>;
};

/** A `Sto` edge in the connection. */
export type StosEdge = {
  __typename?: 'StosEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Sto` at the end of the edge. */
  node?: Maybe<Sto>;
};

/** Grouping methods for `Sto` for usage during aggregation. */
export enum StosGroupBy {
  OfferingAssetId = 'OFFERING_ASSET_ID',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `Sto` aggregates. */
export type StosHavingInput = {
  AND?: Maybe<Array<StosHavingInput>>;
  OR?: Maybe<Array<StosHavingInput>>;
};

/** Methods to use when ordering `Sto`. */
export enum StosOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  OfferingAssetIdAsc = 'OFFERING_ASSET_ID_ASC',
  OfferingAssetIdDesc = 'OFFERING_ASSET_ID_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
}

/** A filter to be used against String fields. All fields are combined with a logical ‘and.’ */
export type StringFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['String']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['String']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['String']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['String']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['String']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['String']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['String']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['String']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['String']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['String']>;
  /** Contains the specified string (case-sensitive). */
  includes?: Maybe<Scalars['String']>;
  /** Does not contain the specified string (case-sensitive). */
  notIncludes?: Maybe<Scalars['String']>;
  /** Contains the specified string (case-insensitive). */
  includesInsensitive?: Maybe<Scalars['String']>;
  /** Does not contain the specified string (case-insensitive). */
  notIncludesInsensitive?: Maybe<Scalars['String']>;
  /** Starts with the specified string (case-sensitive). */
  startsWith?: Maybe<Scalars['String']>;
  /** Does not start with the specified string (case-sensitive). */
  notStartsWith?: Maybe<Scalars['String']>;
  /** Starts with the specified string (case-insensitive). */
  startsWithInsensitive?: Maybe<Scalars['String']>;
  /** Does not start with the specified string (case-insensitive). */
  notStartsWithInsensitive?: Maybe<Scalars['String']>;
  /** Ends with the specified string (case-sensitive). */
  endsWith?: Maybe<Scalars['String']>;
  /** Does not end with the specified string (case-sensitive). */
  notEndsWith?: Maybe<Scalars['String']>;
  /** Ends with the specified string (case-insensitive). */
  endsWithInsensitive?: Maybe<Scalars['String']>;
  /** Does not end with the specified string (case-insensitive). */
  notEndsWithInsensitive?: Maybe<Scalars['String']>;
  /** Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  like?: Maybe<Scalars['String']>;
  /** Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLike?: Maybe<Scalars['String']>;
  /** Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  likeInsensitive?: Maybe<Scalars['String']>;
  /** Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLikeInsensitive?: Maybe<Scalars['String']>;
  /** Equal to the specified value (case-insensitive). */
  equalToInsensitive?: Maybe<Scalars['String']>;
  /** Not equal to the specified value (case-insensitive). */
  notEqualToInsensitive?: Maybe<Scalars['String']>;
  /** Not equal to the specified value, treating null like an ordinary value (case-insensitive). */
  distinctFromInsensitive?: Maybe<Scalars['String']>;
  /** Equal to the specified value, treating null like an ordinary value (case-insensitive). */
  notDistinctFromInsensitive?: Maybe<Scalars['String']>;
  /** Included in the specified list (case-insensitive). */
  inInsensitive?: Maybe<Array<Scalars['String']>>;
  /** Not included in the specified list (case-insensitive). */
  notInInsensitive?: Maybe<Array<Scalars['String']>>;
  /** Less than the specified value (case-insensitive). */
  lessThanInsensitive?: Maybe<Scalars['String']>;
  /** Less than or equal to the specified value (case-insensitive). */
  lessThanOrEqualToInsensitive?: Maybe<Scalars['String']>;
  /** Greater than the specified value (case-insensitive). */
  greaterThanInsensitive?: Maybe<Scalars['String']>;
  /** Greater than or equal to the specified value (case-insensitive). */
  greaterThanOrEqualToInsensitive?: Maybe<Scalars['String']>;
};

/** A connection to a list of `Subquery` values. */
export type SubqueriesConnection = {
  __typename?: 'SubqueriesConnection';
  /** A list of `Subquery` objects. */
  nodes: Array<Maybe<Subquery>>;
  /** A list of edges which contains the `Subquery` and cursor to aid in pagination. */
  edges: Array<SubqueriesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Subquery` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<SubqueryAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<SubqueryAggregates>>;
};

/** A connection to a list of `Subquery` values. */
export type SubqueriesConnectionGroupedAggregatesArgs = {
  groupBy: Array<SubqueriesGroupBy>;
  having?: Maybe<SubqueriesHavingInput>;
};

/** A `Subquery` edge in the connection. */
export type SubqueriesEdge = {
  __typename?: 'SubqueriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Subquery` at the end of the edge. */
  node?: Maybe<Subquery>;
};

/** Grouping methods for `Subquery` for usage during aggregation. */
export enum SubqueriesGroupBy {
  DbSchema = 'DB_SCHEMA',
  Version = 'VERSION',
  Hash = 'HASH',
  NextBlockHeight = 'NEXT_BLOCK_HEIGHT',
  Network = 'NETWORK',
  NetworkGenesis = 'NETWORK_GENESIS',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `Subquery` aggregates. */
export type SubqueriesHavingInput = {
  AND?: Maybe<Array<SubqueriesHavingInput>>;
  OR?: Maybe<Array<SubqueriesHavingInput>>;
};

/** Methods to use when ordering `Subquery`. */
export enum SubqueriesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  DbSchemaAsc = 'DB_SCHEMA_ASC',
  DbSchemaDesc = 'DB_SCHEMA_DESC',
  VersionAsc = 'VERSION_ASC',
  VersionDesc = 'VERSION_DESC',
  HashAsc = 'HASH_ASC',
  HashDesc = 'HASH_DESC',
  NextBlockHeightAsc = 'NEXT_BLOCK_HEIGHT_ASC',
  NextBlockHeightDesc = 'NEXT_BLOCK_HEIGHT_DESC',
  NetworkAsc = 'NETWORK_ASC',
  NetworkDesc = 'NETWORK_DESC',
  NetworkGenesisAsc = 'NETWORK_GENESIS_ASC',
  NetworkGenesisDesc = 'NETWORK_GENESIS_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
}

export type Subquery = Node & {
  __typename?: 'Subquery';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name: Scalars['String'];
  dbSchema: Scalars['String'];
  version: Scalars['Int'];
  hash: Scalars['String'];
  nextBlockHeight: Scalars['Int'];
  network?: Maybe<Scalars['String']>;
  networkGenesis?: Maybe<Scalars['String']>;
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
};

export type SubqueryAggregates = {
  __typename?: 'SubqueryAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `Subquery` object types. All fields are combined with a logical ‘and.’ */
export type SubqueryFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `dbSchema` field. */
  dbSchema?: Maybe<StringFilter>;
  /** Filter by the object’s `version` field. */
  version?: Maybe<IntFilter>;
  /** Filter by the object’s `hash` field. */
  hash?: Maybe<StringFilter>;
  /** Filter by the object’s `nextBlockHeight` field. */
  nextBlockHeight?: Maybe<IntFilter>;
  /** Filter by the object’s `network` field. */
  network?: Maybe<StringFilter>;
  /** Filter by the object’s `networkGenesis` field. */
  networkGenesis?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<SubqueryFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<SubqueryFilter>>;
  /** Negates the expression. */
  not?: Maybe<SubqueryFilter>;
};

export type TableEstimate = {
  __typename?: 'TableEstimate';
  table?: Maybe<Scalars['String']>;
  estimate?: Maybe<Scalars['Int']>;
};

export type TickerExternalAgent = Node & {
  __typename?: 'TickerExternalAgent';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  assetId: Scalars['String'];
  callerId: Scalars['String'];
  eventIdx: Scalars['Int'];
  datetime: Scalars['Datetime'];
  createdBlockId: Scalars['String'];
  updatedBlockId: Scalars['String'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Asset` that is related to this `TickerExternalAgent`. */
  asset?: Maybe<Asset>;
  /** Reads a single `Identity` that is related to this `TickerExternalAgent`. */
  caller?: Maybe<Identity>;
  /** Reads a single `Block` that is related to this `TickerExternalAgent`. */
  createdBlock?: Maybe<Block>;
  /** Reads a single `Block` that is related to this `TickerExternalAgent`. */
  updatedBlock?: Maybe<Block>;
};

export type TickerExternalAgentAction = Node & {
  __typename?: 'TickerExternalAgentAction';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  assetId: Scalars['String'];
  callerId: Scalars['String'];
  palletName: Scalars['String'];
  eventId: Scalars['String'];
  eventIdx: Scalars['Int'];
  datetime: Scalars['Datetime'];
  createdBlockId: Scalars['String'];
  updatedBlockId: Scalars['String'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Asset` that is related to this `TickerExternalAgentAction`. */
  asset?: Maybe<Asset>;
  /** Reads a single `Identity` that is related to this `TickerExternalAgentAction`. */
  caller?: Maybe<Identity>;
  /** Reads a single `Block` that is related to this `TickerExternalAgentAction`. */
  createdBlock?: Maybe<Block>;
  /** Reads a single `Block` that is related to this `TickerExternalAgentAction`. */
  updatedBlock?: Maybe<Block>;
};

export type TickerExternalAgentActionAggregates = {
  __typename?: 'TickerExternalAgentActionAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `TickerExternalAgentAction` object types. All fields are combined with a logical ‘and.’ */
export type TickerExternalAgentActionFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `assetId` field. */
  assetId?: Maybe<StringFilter>;
  /** Filter by the object’s `callerId` field. */
  callerId?: Maybe<StringFilter>;
  /** Filter by the object’s `palletName` field. */
  palletName?: Maybe<StringFilter>;
  /** Filter by the object’s `eventId` field. */
  eventId?: Maybe<StringFilter>;
  /** Filter by the object’s `eventIdx` field. */
  eventIdx?: Maybe<IntFilter>;
  /** Filter by the object’s `datetime` field. */
  datetime?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TickerExternalAgentActionFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TickerExternalAgentActionFilter>>;
  /** Negates the expression. */
  not?: Maybe<TickerExternalAgentActionFilter>;
};

/** A connection to a list of `TickerExternalAgentAction` values. */
export type TickerExternalAgentActionsConnection = {
  __typename?: 'TickerExternalAgentActionsConnection';
  /** A list of `TickerExternalAgentAction` objects. */
  nodes: Array<Maybe<TickerExternalAgentAction>>;
  /** A list of edges which contains the `TickerExternalAgentAction` and cursor to aid in pagination. */
  edges: Array<TickerExternalAgentActionsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TickerExternalAgentAction` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<TickerExternalAgentActionAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<TickerExternalAgentActionAggregates>>;
};

/** A connection to a list of `TickerExternalAgentAction` values. */
export type TickerExternalAgentActionsConnectionGroupedAggregatesArgs = {
  groupBy: Array<TickerExternalAgentActionsGroupBy>;
  having?: Maybe<TickerExternalAgentActionsHavingInput>;
};

/** A `TickerExternalAgentAction` edge in the connection. */
export type TickerExternalAgentActionsEdge = {
  __typename?: 'TickerExternalAgentActionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `TickerExternalAgentAction` at the end of the edge. */
  node?: Maybe<TickerExternalAgentAction>;
};

/** Grouping methods for `TickerExternalAgentAction` for usage during aggregation. */
export enum TickerExternalAgentActionsGroupBy {
  AssetId = 'ASSET_ID',
  CallerId = 'CALLER_ID',
  PalletName = 'PALLET_NAME',
  EventId = 'EVENT_ID',
  EventIdx = 'EVENT_IDX',
  Datetime = 'DATETIME',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `TickerExternalAgentAction` aggregates. */
export type TickerExternalAgentActionsHavingInput = {
  AND?: Maybe<Array<TickerExternalAgentActionsHavingInput>>;
  OR?: Maybe<Array<TickerExternalAgentActionsHavingInput>>;
};

/** Methods to use when ordering `TickerExternalAgentAction`. */
export enum TickerExternalAgentActionsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  AssetIdAsc = 'ASSET_ID_ASC',
  AssetIdDesc = 'ASSET_ID_DESC',
  CallerIdAsc = 'CALLER_ID_ASC',
  CallerIdDesc = 'CALLER_ID_DESC',
  PalletNameAsc = 'PALLET_NAME_ASC',
  PalletNameDesc = 'PALLET_NAME_DESC',
  EventIdAsc = 'EVENT_ID_ASC',
  EventIdDesc = 'EVENT_ID_DESC',
  EventIdxAsc = 'EVENT_IDX_ASC',
  EventIdxDesc = 'EVENT_IDX_DESC',
  DatetimeAsc = 'DATETIME_ASC',
  DatetimeDesc = 'DATETIME_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
}

export type TickerExternalAgentAggregates = {
  __typename?: 'TickerExternalAgentAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `TickerExternalAgent` object types. All fields are combined with a logical ‘and.’ */
export type TickerExternalAgentFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `assetId` field. */
  assetId?: Maybe<StringFilter>;
  /** Filter by the object’s `callerId` field. */
  callerId?: Maybe<StringFilter>;
  /** Filter by the object’s `eventIdx` field. */
  eventIdx?: Maybe<IntFilter>;
  /** Filter by the object’s `datetime` field. */
  datetime?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TickerExternalAgentFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TickerExternalAgentFilter>>;
  /** Negates the expression. */
  not?: Maybe<TickerExternalAgentFilter>;
};

/** A connection to a list of `TickerExternalAgentHistory` values. */
export type TickerExternalAgentHistoriesConnection = {
  __typename?: 'TickerExternalAgentHistoriesConnection';
  /** A list of `TickerExternalAgentHistory` objects. */
  nodes: Array<Maybe<TickerExternalAgentHistory>>;
  /** A list of edges which contains the `TickerExternalAgentHistory` and cursor to aid in pagination. */
  edges: Array<TickerExternalAgentHistoriesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TickerExternalAgentHistory` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<TickerExternalAgentHistoryAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<TickerExternalAgentHistoryAggregates>>;
};

/** A connection to a list of `TickerExternalAgentHistory` values. */
export type TickerExternalAgentHistoriesConnectionGroupedAggregatesArgs = {
  groupBy: Array<TickerExternalAgentHistoriesGroupBy>;
  having?: Maybe<TickerExternalAgentHistoriesHavingInput>;
};

/** A `TickerExternalAgentHistory` edge in the connection. */
export type TickerExternalAgentHistoriesEdge = {
  __typename?: 'TickerExternalAgentHistoriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `TickerExternalAgentHistory` at the end of the edge. */
  node?: Maybe<TickerExternalAgentHistory>;
};

/** Grouping methods for `TickerExternalAgentHistory` for usage during aggregation. */
export enum TickerExternalAgentHistoriesGroupBy {
  AssetId = 'ASSET_ID',
  IdentityId = 'IDENTITY_ID',
  Datetime = 'DATETIME',
  Type = 'TYPE',
  Permissions = 'PERMISSIONS',
  EventIdx = 'EVENT_IDX',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `TickerExternalAgentHistory` aggregates. */
export type TickerExternalAgentHistoriesHavingInput = {
  AND?: Maybe<Array<TickerExternalAgentHistoriesHavingInput>>;
  OR?: Maybe<Array<TickerExternalAgentHistoriesHavingInput>>;
};

/** Methods to use when ordering `TickerExternalAgentHistory`. */
export enum TickerExternalAgentHistoriesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  AssetIdAsc = 'ASSET_ID_ASC',
  AssetIdDesc = 'ASSET_ID_DESC',
  IdentityIdAsc = 'IDENTITY_ID_ASC',
  IdentityIdDesc = 'IDENTITY_ID_DESC',
  DatetimeAsc = 'DATETIME_ASC',
  DatetimeDesc = 'DATETIME_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  PermissionsAsc = 'PERMISSIONS_ASC',
  PermissionsDesc = 'PERMISSIONS_DESC',
  EventIdxAsc = 'EVENT_IDX_ASC',
  EventIdxDesc = 'EVENT_IDX_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
}

export type TickerExternalAgentHistory = Node & {
  __typename?: 'TickerExternalAgentHistory';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  assetId: Scalars['String'];
  identityId: Scalars['String'];
  datetime: Scalars['Datetime'];
  type: Scalars['String'];
  permissions?: Maybe<Scalars['String']>;
  eventIdx: Scalars['Int'];
  createdBlockId: Scalars['String'];
  updatedBlockId: Scalars['String'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Asset` that is related to this `TickerExternalAgentHistory`. */
  asset?: Maybe<Asset>;
  /** Reads a single `Identity` that is related to this `TickerExternalAgentHistory`. */
  identity?: Maybe<Identity>;
  /** Reads a single `Block` that is related to this `TickerExternalAgentHistory`. */
  createdBlock?: Maybe<Block>;
  /** Reads a single `Block` that is related to this `TickerExternalAgentHistory`. */
  updatedBlock?: Maybe<Block>;
};

export type TickerExternalAgentHistoryAggregates = {
  __typename?: 'TickerExternalAgentHistoryAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `TickerExternalAgentHistory` object types. All fields are combined with a logical ‘and.’ */
export type TickerExternalAgentHistoryFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `assetId` field. */
  assetId?: Maybe<StringFilter>;
  /** Filter by the object’s `identityId` field. */
  identityId?: Maybe<StringFilter>;
  /** Filter by the object’s `datetime` field. */
  datetime?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `type` field. */
  type?: Maybe<StringFilter>;
  /** Filter by the object’s `permissions` field. */
  permissions?: Maybe<StringFilter>;
  /** Filter by the object’s `eventIdx` field. */
  eventIdx?: Maybe<IntFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TickerExternalAgentHistoryFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TickerExternalAgentHistoryFilter>>;
  /** Negates the expression. */
  not?: Maybe<TickerExternalAgentHistoryFilter>;
};

/** A connection to a list of `TickerExternalAgent` values. */
export type TickerExternalAgentsConnection = {
  __typename?: 'TickerExternalAgentsConnection';
  /** A list of `TickerExternalAgent` objects. */
  nodes: Array<Maybe<TickerExternalAgent>>;
  /** A list of edges which contains the `TickerExternalAgent` and cursor to aid in pagination. */
  edges: Array<TickerExternalAgentsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TickerExternalAgent` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<TickerExternalAgentAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<TickerExternalAgentAggregates>>;
};

/** A connection to a list of `TickerExternalAgent` values. */
export type TickerExternalAgentsConnectionGroupedAggregatesArgs = {
  groupBy: Array<TickerExternalAgentsGroupBy>;
  having?: Maybe<TickerExternalAgentsHavingInput>;
};

/** A `TickerExternalAgent` edge in the connection. */
export type TickerExternalAgentsEdge = {
  __typename?: 'TickerExternalAgentsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `TickerExternalAgent` at the end of the edge. */
  node?: Maybe<TickerExternalAgent>;
};

/** Grouping methods for `TickerExternalAgent` for usage during aggregation. */
export enum TickerExternalAgentsGroupBy {
  AssetId = 'ASSET_ID',
  CallerId = 'CALLER_ID',
  EventIdx = 'EVENT_IDX',
  Datetime = 'DATETIME',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `TickerExternalAgent` aggregates. */
export type TickerExternalAgentsHavingInput = {
  AND?: Maybe<Array<TickerExternalAgentsHavingInput>>;
  OR?: Maybe<Array<TickerExternalAgentsHavingInput>>;
};

/** Methods to use when ordering `TickerExternalAgent`. */
export enum TickerExternalAgentsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  AssetIdAsc = 'ASSET_ID_ASC',
  AssetIdDesc = 'ASSET_ID_DESC',
  CallerIdAsc = 'CALLER_ID_ASC',
  CallerIdDesc = 'CALLER_ID_DESC',
  EventIdxAsc = 'EVENT_IDX_ASC',
  EventIdxDesc = 'EVENT_IDX_DESC',
  DatetimeAsc = 'DATETIME_ASC',
  DatetimeDesc = 'DATETIME_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
}

export type TransferCompliance = Node & {
  __typename?: 'TransferCompliance';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  assetId: Scalars['String'];
  type: Scalars['String'];
  statTypeId: Scalars['String'];
  value?: Maybe<Scalars['BigFloat']>;
  claimType?: Maybe<Scalars['String']>;
  claimValue?: Maybe<Scalars['String']>;
  claimIssuerId?: Maybe<Scalars['String']>;
  min?: Maybe<Scalars['BigFloat']>;
  max?: Maybe<Scalars['BigFloat']>;
  createdBlockId: Scalars['String'];
  updatedBlockId: Scalars['String'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Asset` that is related to this `TransferCompliance`. */
  asset?: Maybe<Asset>;
  /** Reads a single `StatType` that is related to this `TransferCompliance`. */
  statType?: Maybe<StatType>;
  /** Reads a single `Identity` that is related to this `TransferCompliance`. */
  claimIssuer?: Maybe<Identity>;
  /** Reads a single `Block` that is related to this `TransferCompliance`. */
  createdBlock?: Maybe<Block>;
  /** Reads a single `Block` that is related to this `TransferCompliance`. */
  updatedBlock?: Maybe<Block>;
};

export type TransferComplianceAggregates = {
  __typename?: 'TransferComplianceAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

export type TransferComplianceExemption = Node & {
  __typename?: 'TransferComplianceExemption';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  assetId: Scalars['String'];
  opType: Scalars['String'];
  claimType?: Maybe<Scalars['String']>;
  exemptedEntityId: Scalars['String'];
  createdBlockId: Scalars['String'];
  updatedBlockId: Scalars['String'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Asset` that is related to this `TransferComplianceExemption`. */
  asset?: Maybe<Asset>;
  /** Reads a single `Block` that is related to this `TransferComplianceExemption`. */
  createdBlock?: Maybe<Block>;
  /** Reads a single `Block` that is related to this `TransferComplianceExemption`. */
  updatedBlock?: Maybe<Block>;
};

export type TransferComplianceExemptionAggregates = {
  __typename?: 'TransferComplianceExemptionAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `TransferComplianceExemption` object types. All fields are combined with a logical ‘and.’ */
export type TransferComplianceExemptionFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `assetId` field. */
  assetId?: Maybe<StringFilter>;
  /** Filter by the object’s `opType` field. */
  opType?: Maybe<StringFilter>;
  /** Filter by the object’s `claimType` field. */
  claimType?: Maybe<StringFilter>;
  /** Filter by the object’s `exemptedEntityId` field. */
  exemptedEntityId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TransferComplianceExemptionFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TransferComplianceExemptionFilter>>;
  /** Negates the expression. */
  not?: Maybe<TransferComplianceExemptionFilter>;
};

/** A connection to a list of `TransferComplianceExemption` values. */
export type TransferComplianceExemptionsConnection = {
  __typename?: 'TransferComplianceExemptionsConnection';
  /** A list of `TransferComplianceExemption` objects. */
  nodes: Array<Maybe<TransferComplianceExemption>>;
  /** A list of edges which contains the `TransferComplianceExemption` and cursor to aid in pagination. */
  edges: Array<TransferComplianceExemptionsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TransferComplianceExemption` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<TransferComplianceExemptionAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<TransferComplianceExemptionAggregates>>;
};

/** A connection to a list of `TransferComplianceExemption` values. */
export type TransferComplianceExemptionsConnectionGroupedAggregatesArgs = {
  groupBy: Array<TransferComplianceExemptionsGroupBy>;
  having?: Maybe<TransferComplianceExemptionsHavingInput>;
};

/** A `TransferComplianceExemption` edge in the connection. */
export type TransferComplianceExemptionsEdge = {
  __typename?: 'TransferComplianceExemptionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `TransferComplianceExemption` at the end of the edge. */
  node?: Maybe<TransferComplianceExemption>;
};

/** Grouping methods for `TransferComplianceExemption` for usage during aggregation. */
export enum TransferComplianceExemptionsGroupBy {
  AssetId = 'ASSET_ID',
  OpType = 'OP_TYPE',
  ClaimType = 'CLAIM_TYPE',
  ExemptedEntityId = 'EXEMPTED_ENTITY_ID',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `TransferComplianceExemption` aggregates. */
export type TransferComplianceExemptionsHavingInput = {
  AND?: Maybe<Array<TransferComplianceExemptionsHavingInput>>;
  OR?: Maybe<Array<TransferComplianceExemptionsHavingInput>>;
};

/** Methods to use when ordering `TransferComplianceExemption`. */
export enum TransferComplianceExemptionsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  AssetIdAsc = 'ASSET_ID_ASC',
  AssetIdDesc = 'ASSET_ID_DESC',
  OpTypeAsc = 'OP_TYPE_ASC',
  OpTypeDesc = 'OP_TYPE_DESC',
  ClaimTypeAsc = 'CLAIM_TYPE_ASC',
  ClaimTypeDesc = 'CLAIM_TYPE_DESC',
  ExemptedEntityIdAsc = 'EXEMPTED_ENTITY_ID_ASC',
  ExemptedEntityIdDesc = 'EXEMPTED_ENTITY_ID_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
}

/** A filter to be used against `TransferCompliance` object types. All fields are combined with a logical ‘and.’ */
export type TransferComplianceFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `assetId` field. */
  assetId?: Maybe<StringFilter>;
  /** Filter by the object’s `type` field. */
  type?: Maybe<StringFilter>;
  /** Filter by the object’s `statTypeId` field. */
  statTypeId?: Maybe<StringFilter>;
  /** Filter by the object’s `value` field. */
  value?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `claimType` field. */
  claimType?: Maybe<StringFilter>;
  /** Filter by the object’s `claimValue` field. */
  claimValue?: Maybe<StringFilter>;
  /** Filter by the object’s `claimIssuerId` field. */
  claimIssuerId?: Maybe<StringFilter>;
  /** Filter by the object’s `min` field. */
  min?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `max` field. */
  max?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TransferComplianceFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TransferComplianceFilter>>;
  /** Negates the expression. */
  not?: Maybe<TransferComplianceFilter>;
};

/** A connection to a list of `TransferCompliance` values. */
export type TransferCompliancesConnection = {
  __typename?: 'TransferCompliancesConnection';
  /** A list of `TransferCompliance` objects. */
  nodes: Array<Maybe<TransferCompliance>>;
  /** A list of edges which contains the `TransferCompliance` and cursor to aid in pagination. */
  edges: Array<TransferCompliancesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TransferCompliance` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<TransferComplianceAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<TransferComplianceAggregates>>;
};

/** A connection to a list of `TransferCompliance` values. */
export type TransferCompliancesConnectionGroupedAggregatesArgs = {
  groupBy: Array<TransferCompliancesGroupBy>;
  having?: Maybe<TransferCompliancesHavingInput>;
};

/** A `TransferCompliance` edge in the connection. */
export type TransferCompliancesEdge = {
  __typename?: 'TransferCompliancesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `TransferCompliance` at the end of the edge. */
  node?: Maybe<TransferCompliance>;
};

/** Grouping methods for `TransferCompliance` for usage during aggregation. */
export enum TransferCompliancesGroupBy {
  AssetId = 'ASSET_ID',
  Type = 'TYPE',
  StatTypeId = 'STAT_TYPE_ID',
  Value = 'VALUE',
  ClaimType = 'CLAIM_TYPE',
  ClaimValue = 'CLAIM_VALUE',
  ClaimIssuerId = 'CLAIM_ISSUER_ID',
  Min = 'MIN',
  Max = 'MAX',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `TransferCompliance` aggregates. */
export type TransferCompliancesHavingInput = {
  AND?: Maybe<Array<TransferCompliancesHavingInput>>;
  OR?: Maybe<Array<TransferCompliancesHavingInput>>;
};

/** Methods to use when ordering `TransferCompliance`. */
export enum TransferCompliancesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  AssetIdAsc = 'ASSET_ID_ASC',
  AssetIdDesc = 'ASSET_ID_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  StatTypeIdAsc = 'STAT_TYPE_ID_ASC',
  StatTypeIdDesc = 'STAT_TYPE_ID_DESC',
  ValueAsc = 'VALUE_ASC',
  ValueDesc = 'VALUE_DESC',
  ClaimTypeAsc = 'CLAIM_TYPE_ASC',
  ClaimTypeDesc = 'CLAIM_TYPE_DESC',
  ClaimValueAsc = 'CLAIM_VALUE_ASC',
  ClaimValueDesc = 'CLAIM_VALUE_DESC',
  ClaimIssuerIdAsc = 'CLAIM_ISSUER_ID_ASC',
  ClaimIssuerIdDesc = 'CLAIM_ISSUER_ID_DESC',
  MinAsc = 'MIN_ASC',
  MinDesc = 'MIN_DESC',
  MaxAsc = 'MAX_ASC',
  MaxDesc = 'MAX_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
}

export type TransferManager = Node & {
  __typename?: 'TransferManager';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  assetId: Scalars['String'];
  type: Scalars['String'];
  value: Scalars['Int'];
  exemptedEntities: Scalars['JSON'];
  createdBlockId: Scalars['String'];
  updatedBlockId: Scalars['String'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Asset` that is related to this `TransferManager`. */
  asset?: Maybe<Asset>;
  /** Reads a single `Block` that is related to this `TransferManager`. */
  createdBlock?: Maybe<Block>;
  /** Reads a single `Block` that is related to this `TransferManager`. */
  updatedBlock?: Maybe<Block>;
};

export type TransferManagerAggregates = {
  __typename?: 'TransferManagerAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `TransferManager` object types. All fields are combined with a logical ‘and.’ */
export type TransferManagerFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `assetId` field. */
  assetId?: Maybe<StringFilter>;
  /** Filter by the object’s `type` field. */
  type?: Maybe<StringFilter>;
  /** Filter by the object’s `value` field. */
  value?: Maybe<IntFilter>;
  /** Filter by the object’s `exemptedEntities` field. */
  exemptedEntities?: Maybe<JsonFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TransferManagerFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TransferManagerFilter>>;
  /** Negates the expression. */
  not?: Maybe<TransferManagerFilter>;
};

/** A connection to a list of `TransferManager` values. */
export type TransferManagersConnection = {
  __typename?: 'TransferManagersConnection';
  /** A list of `TransferManager` objects. */
  nodes: Array<Maybe<TransferManager>>;
  /** A list of edges which contains the `TransferManager` and cursor to aid in pagination. */
  edges: Array<TransferManagersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TransferManager` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<TransferManagerAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<TransferManagerAggregates>>;
};

/** A connection to a list of `TransferManager` values. */
export type TransferManagersConnectionGroupedAggregatesArgs = {
  groupBy: Array<TransferManagersGroupBy>;
  having?: Maybe<TransferManagersHavingInput>;
};

/** A `TransferManager` edge in the connection. */
export type TransferManagersEdge = {
  __typename?: 'TransferManagersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `TransferManager` at the end of the edge. */
  node?: Maybe<TransferManager>;
};

/** Grouping methods for `TransferManager` for usage during aggregation. */
export enum TransferManagersGroupBy {
  AssetId = 'ASSET_ID',
  Type = 'TYPE',
  Value = 'VALUE',
  ExemptedEntities = 'EXEMPTED_ENTITIES',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `TransferManager` aggregates. */
export type TransferManagersHavingInput = {
  AND?: Maybe<Array<TransferManagersHavingInput>>;
  OR?: Maybe<Array<TransferManagersHavingInput>>;
};

/** Methods to use when ordering `TransferManager`. */
export enum TransferManagersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  AssetIdAsc = 'ASSET_ID_ASC',
  AssetIdDesc = 'ASSET_ID_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  ValueAsc = 'VALUE_ASC',
  ValueDesc = 'VALUE_DESC',
  ExemptedEntitiesAsc = 'EXEMPTED_ENTITIES_ASC',
  ExemptedEntitiesDesc = 'EXEMPTED_ENTITIES_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
}

export type TrustedClaimIssuer = Node & {
  __typename?: 'TrustedClaimIssuer';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  assetId: Scalars['String'];
  issuer: Scalars['String'];
  eventIdx: Scalars['Int'];
  createdBlockId: Scalars['String'];
  updatedBlockId: Scalars['String'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Asset` that is related to this `TrustedClaimIssuer`. */
  asset?: Maybe<Asset>;
  /** Reads a single `Block` that is related to this `TrustedClaimIssuer`. */
  createdBlock?: Maybe<Block>;
  /** Reads a single `Block` that is related to this `TrustedClaimIssuer`. */
  updatedBlock?: Maybe<Block>;
};

export type TrustedClaimIssuerAggregates = {
  __typename?: 'TrustedClaimIssuerAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `TrustedClaimIssuer` object types. All fields are combined with a logical ‘and.’ */
export type TrustedClaimIssuerFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `assetId` field. */
  assetId?: Maybe<StringFilter>;
  /** Filter by the object’s `issuer` field. */
  issuer?: Maybe<StringFilter>;
  /** Filter by the object’s `eventIdx` field. */
  eventIdx?: Maybe<IntFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TrustedClaimIssuerFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TrustedClaimIssuerFilter>>;
  /** Negates the expression. */
  not?: Maybe<TrustedClaimIssuerFilter>;
};

/** A connection to a list of `TrustedClaimIssuer` values. */
export type TrustedClaimIssuersConnection = {
  __typename?: 'TrustedClaimIssuersConnection';
  /** A list of `TrustedClaimIssuer` objects. */
  nodes: Array<Maybe<TrustedClaimIssuer>>;
  /** A list of edges which contains the `TrustedClaimIssuer` and cursor to aid in pagination. */
  edges: Array<TrustedClaimIssuersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TrustedClaimIssuer` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<TrustedClaimIssuerAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<TrustedClaimIssuerAggregates>>;
};

/** A connection to a list of `TrustedClaimIssuer` values. */
export type TrustedClaimIssuersConnectionGroupedAggregatesArgs = {
  groupBy: Array<TrustedClaimIssuersGroupBy>;
  having?: Maybe<TrustedClaimIssuersHavingInput>;
};

/** A `TrustedClaimIssuer` edge in the connection. */
export type TrustedClaimIssuersEdge = {
  __typename?: 'TrustedClaimIssuersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `TrustedClaimIssuer` at the end of the edge. */
  node?: Maybe<TrustedClaimIssuer>;
};

/** Grouping methods for `TrustedClaimIssuer` for usage during aggregation. */
export enum TrustedClaimIssuersGroupBy {
  AssetId = 'ASSET_ID',
  Issuer = 'ISSUER',
  EventIdx = 'EVENT_IDX',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `TrustedClaimIssuer` aggregates. */
export type TrustedClaimIssuersHavingInput = {
  AND?: Maybe<Array<TrustedClaimIssuersHavingInput>>;
  OR?: Maybe<Array<TrustedClaimIssuersHavingInput>>;
};

/** Methods to use when ordering `TrustedClaimIssuer`. */
export enum TrustedClaimIssuersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  AssetIdAsc = 'ASSET_ID_ASC',
  AssetIdDesc = 'ASSET_ID_DESC',
  IssuerAsc = 'ISSUER_ASC',
  IssuerDesc = 'ISSUER_DESC',
  EventIdxAsc = 'EVENT_IDX_ASC',
  EventIdxDesc = 'EVENT_IDX_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
}

export type Venue = Node & {
  __typename?: 'Venue';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  ownerId: Scalars['String'];
  type: Scalars['String'];
  details?: Maybe<Scalars['String']>;
  createdBlockId: Scalars['String'];
  updatedBlockId: Scalars['String'];
  createdAt: Scalars['Datetime'];
  updatedAt: Scalars['Datetime'];
  /** Reads a single `Identity` that is related to this `Venue`. */
  owner?: Maybe<Identity>;
  /** Reads a single `Block` that is related to this `Venue`. */
  createdBlock?: Maybe<Block>;
  /** Reads a single `Block` that is related to this `Venue`. */
  updatedBlock?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Instruction`. */
  instructions: InstructionsConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByInstructionVenueIdAndCreatedBlockId: VenueBlocksByInstructionVenueIdAndCreatedBlockIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Block`. */
  blocksByInstructionVenueIdAndUpdatedBlockId: VenueBlocksByInstructionVenueIdAndUpdatedBlockIdManyToManyConnection;
};

export type VenueInstructionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<InstructionsOrderBy>>;
  filter?: Maybe<InstructionFilter>;
};

export type VenueBlocksByInstructionVenueIdAndCreatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type VenueBlocksByInstructionVenueIdAndUpdatedBlockIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<BlocksOrderBy>>;
  filter?: Maybe<BlockFilter>;
};

export type VenueAggregates = {
  __typename?: 'VenueAggregates';
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A connection to a list of `Block` values, with data from `Instruction`. */
export type VenueBlocksByInstructionVenueIdAndCreatedBlockIdManyToManyConnection = {
  __typename?: 'VenueBlocksByInstructionVenueIdAndCreatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Instruction`, and the cursor to aid in pagination. */
  edges: Array<VenueBlocksByInstructionVenueIdAndCreatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Instruction`. */
export type VenueBlocksByInstructionVenueIdAndCreatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Instruction`. */
export type VenueBlocksByInstructionVenueIdAndCreatedBlockIdManyToManyEdge = {
  __typename?: 'VenueBlocksByInstructionVenueIdAndCreatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Instruction`. */
  instructionsByCreatedBlockId: InstructionsConnection;
};

/** A `Block` edge in the connection, with data from `Instruction`. */
export type VenueBlocksByInstructionVenueIdAndCreatedBlockIdManyToManyEdgeInstructionsByCreatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<InstructionsOrderBy>>;
    filter?: Maybe<InstructionFilter>;
  };

/** A connection to a list of `Block` values, with data from `Instruction`. */
export type VenueBlocksByInstructionVenueIdAndUpdatedBlockIdManyToManyConnection = {
  __typename?: 'VenueBlocksByInstructionVenueIdAndUpdatedBlockIdManyToManyConnection';
  /** A list of `Block` objects. */
  nodes: Array<Maybe<Block>>;
  /** A list of edges which contains the `Block`, info from the `Instruction`, and the cursor to aid in pagination. */
  edges: Array<VenueBlocksByInstructionVenueIdAndUpdatedBlockIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
};

/** A connection to a list of `Block` values, with data from `Instruction`. */
export type VenueBlocksByInstructionVenueIdAndUpdatedBlockIdManyToManyConnectionGroupedAggregatesArgs =
  {
    groupBy: Array<BlocksGroupBy>;
    having?: Maybe<BlocksHavingInput>;
  };

/** A `Block` edge in the connection, with data from `Instruction`. */
export type VenueBlocksByInstructionVenueIdAndUpdatedBlockIdManyToManyEdge = {
  __typename?: 'VenueBlocksByInstructionVenueIdAndUpdatedBlockIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Block` at the end of the edge. */
  node?: Maybe<Block>;
  /** Reads and enables pagination through a set of `Instruction`. */
  instructionsByUpdatedBlockId: InstructionsConnection;
};

/** A `Block` edge in the connection, with data from `Instruction`. */
export type VenueBlocksByInstructionVenueIdAndUpdatedBlockIdManyToManyEdgeInstructionsByUpdatedBlockIdArgs =
  {
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    before?: Maybe<Scalars['Cursor']>;
    after?: Maybe<Scalars['Cursor']>;
    orderBy?: Maybe<Array<InstructionsOrderBy>>;
    filter?: Maybe<InstructionFilter>;
  };

/** A filter to be used against `Venue` object types. All fields are combined with a logical ‘and.’ */
export type VenueFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: Maybe<StringFilter>;
  /** Filter by the object’s `type` field. */
  type?: Maybe<StringFilter>;
  /** Filter by the object’s `details` field. */
  details?: Maybe<StringFilter>;
  /** Filter by the object’s `createdBlockId` field. */
  createdBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `updatedBlockId` field. */
  updatedBlockId?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<VenueFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<VenueFilter>>;
  /** Negates the expression. */
  not?: Maybe<VenueFilter>;
};

/** A connection to a list of `Venue` values. */
export type VenuesConnection = {
  __typename?: 'VenuesConnection';
  /** A list of `Venue` objects. */
  nodes: Array<Maybe<Venue>>;
  /** A list of edges which contains the `Venue` and cursor to aid in pagination. */
  edges: Array<VenuesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Venue` you could get from the connection. */
  totalCount: Scalars['Int'];
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<VenueAggregates>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<VenueAggregates>>;
};

/** A connection to a list of `Venue` values. */
export type VenuesConnectionGroupedAggregatesArgs = {
  groupBy: Array<VenuesGroupBy>;
  having?: Maybe<VenuesHavingInput>;
};

/** A `Venue` edge in the connection. */
export type VenuesEdge = {
  __typename?: 'VenuesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Venue` at the end of the edge. */
  node?: Maybe<Venue>;
};

/** Grouping methods for `Venue` for usage during aggregation. */
export enum VenuesGroupBy {
  OwnerId = 'OWNER_ID',
  Type = 'TYPE',
  Details = 'DETAILS',
  CreatedBlockId = 'CREATED_BLOCK_ID',
  UpdatedBlockId = 'UPDATED_BLOCK_ID',
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
}

/** Conditions for `Venue` aggregates. */
export type VenuesHavingInput = {
  AND?: Maybe<Array<VenuesHavingInput>>;
  OR?: Maybe<Array<VenuesHavingInput>>;
};

/** Methods to use when ordering `Venue`. */
export enum VenuesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  DetailsAsc = 'DETAILS_ASC',
  DetailsDesc = 'DETAILS_DESC',
  CreatedBlockIdAsc = 'CREATED_BLOCK_ID_ASC',
  CreatedBlockIdDesc = 'CREATED_BLOCK_ID_DESC',
  UpdatedBlockIdAsc = 'UPDATED_BLOCK_ID_ASC',
  UpdatedBlockIdDesc = 'UPDATED_BLOCK_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  InstructionsCountAsc = 'INSTRUCTIONS_COUNT_ASC',
  InstructionsCountDesc = 'INSTRUCTIONS_COUNT_DESC',
}

export type _Metadata = {
  __typename?: '_Metadata';
  lastProcessedHeight?: Maybe<Scalars['Int']>;
  lastProcessedTimestamp?: Maybe<Scalars['Date']>;
  targetHeight?: Maybe<Scalars['Int']>;
  chain?: Maybe<Scalars['String']>;
  specName?: Maybe<Scalars['String']>;
  genesisHash?: Maybe<Scalars['String']>;
  indexerHealthy?: Maybe<Scalars['Boolean']>;
  indexerNodeVersion?: Maybe<Scalars['String']>;
  queryNodeVersion?: Maybe<Scalars['String']>;
  rowCountEstimate?: Maybe<Array<Maybe<TableEstimate>>>;
  dynamicDatasources?: Maybe<Scalars['String']>;
};
